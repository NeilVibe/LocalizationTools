name: QuickTranslate Build & Release

on:
  push:
    paths:
      - 'QUICKTRANSLATE_BUILD.txt'
  workflow_dispatch:
    inputs:
      skip_safety:
        description: 'Skip safety checks (not recommended)'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write

env:
  PROJECT_PATH: RessourcesForCodingTheProject/NewScripts/QuickTranslate
  APP_NAME: QuickTranslate
  PYTHON_VERSION: '3.11'

jobs:
  # =============================================================================
  # JOB 1: VALIDATION
  # =============================================================================
  validate:
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check build trigger
        id: check
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "Manual trigger - building"
          elif git diff --name-only HEAD~1 | grep -q "QUICKTRANSLATE_BUILD.txt"; then
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "Build trigger file changed - building"
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
            echo "No build trigger - skipping"
          fi

      - name: Generate version
        id: version
        if: steps.check.outputs.should_build == 'true'
        run: |
          VERSION=$(TZ='Asia/Seoul' date '+%y.%-m%d.%H%M')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Generated version: $VERSION"

  # =============================================================================
  # JOB 2: SAFETY CHECKS (Linux)
  # =============================================================================
  safety-checks:
    needs: validate
    if: needs.validate.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r ${{ env.PROJECT_PATH }}/requirements.txt
          pip install flake8 pip-audit pytest

      - name: Python syntax validation
        run: |
          echo "=== Syntax Validation ==="
          cd ${{ env.PROJECT_PATH }}
          python -m py_compile main.py
          python -m py_compile config.py
          find . -name "*.py" -type f ! -path "./__pycache__/*" ! -name "scriptreference*" | xargs -I {} python -m py_compile {}
          echo "All Python files have valid syntax"

      - name: Module import validation
        run: |
          echo "=== Import Validation ==="
          cd ${{ env.PROJECT_PATH }}
          python -c "
          import sys
          sys.path.insert(0, '.')

          # Test config imports
          from config import MATCHING_MODES, SCRIPT_CATEGORIES, SPECIAL_KEY_FIELDS
          from config import LANGUAGE_ORDER, LANGUAGE_NAMES, ensure_output_folder
          from config import LOC_FOLDER, EXPORT_FOLDER, get_settings, reload_settings
          print('config imports: OK')

          # Test core module imports
          from core import (
              sanitize_xml_content, parse_xml_file,
              is_korean_text, find_matches,
              find_matches_stringid_only, find_matches_strict,
              build_sequencer_strorigin_index, discover_language_files,
              find_missing_translations_per_language,
          )
          print('core imports: OK')

          # Test utils imports
          from utils import read_text_file_lines
          print('utils imports: OK')

          print('All imports validated successfully')
          "

      - name: Full application test (MUST PASS)
        run: |
          echo "=== Application Test ==="
          cd ${{ env.PROJECT_PATH }}

          # Test imports work
          python -c "import config; print('✓ config')"
          python -c "from core import *; print('✓ core')"
          python -c "from utils import *; print('✓ utils')"

          echo "✓ All module imports validated"
          echo "Application test complete"

      - name: Flake8 critical errors (MUST PASS)
        run: |
          echo "=== Flake8 Critical Errors (FAILS BUILD!) ==="
          cd ${{ env.PROJECT_PATH }}
          # E9: Runtime errors (syntax, IO)
          # F63: Invalid comparisons
          # F7: Syntax errors
          # F82: Undefined names (CRITICAL - catches missing variables!)
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude=archive
          echo "Flake8 passed - no critical errors"

      - name: Security audit
        run: |
          echo "=== Security Audit ==="
          pip-audit --requirement ${{ env.PROJECT_PATH }}/requirements.txt || true

  # =============================================================================
  # JOB 3: BUILD & RELEASE (Windows)
  # =============================================================================
  build-release:
    needs: [validate, safety-checks]
    if: needs.validate.outputs.should_build == 'true'
    runs-on: windows-latest
    env:
      VERSION: ${{ needs.validate.outputs.version }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install --no-cache-dir -r ${{ env.PROJECT_PATH }}/requirements.txt

          # Step 1: Install CPU-only torch FIRST (from PyTorch's CPU wheel index)
          pip install --no-cache-dir torch --index-url https://download.pytorch.org/whl/cpu

          # Step 2: Install ML deps. torch is already satisfied so pip won't re-download.
          # NO --extra-index-url (that lets pip find CUDA torch on PyPI and override!)
          # scipy + scikit-learn are REQUIRED by sentence-transformers (top-level imports)
          # requests + deps are REQUIRED by transformers/huggingface_hub (model downloads)
          pip install --no-cache-dir sentence-transformers faiss-cpu numpy scipy scikit-learn
          pip install --no-cache-dir requests urllib3 certifi charset-normalizer idna

          # Step 3: Build tools
          pip install --no-cache-dir "pyinstaller>=6.0,<7.0" pyinstaller-hooks-contrib

      - name: Verify ML dependencies (MUST PASS)
        run: |
          python -c "
          import torch
          v = torch.__version__
          print(f'torch {v}')
          # CPU-only torch has +cpu in version string
          assert '+cpu' in v, f'FATAL: Expected CPU-only torch (+cpu), got {v}. CUDA torch will bloat the build!'

          import sentence_transformers
          print(f'sentence-transformers {sentence_transformers.__version__}')
          import faiss
          print(f'faiss OK')
          import numpy
          print(f'numpy {numpy.__version__}')
          import tqdm, regex, packaging, filelock, tokenizers
          print('All transitive deps OK')

          # requests + its full dependency tree (MUST be present for transformers/huggingface_hub)
          import requests
          print(f'requests {requests.__version__}')
          import urllib3
          print(f'urllib3 {urllib3.__version__}')
          import certifi
          print(f'certifi {certifi.__version__}')
          import charset_normalizer
          print(f'charset_normalizer {charset_normalizer.__version__}')
          import idna
          print(f'idna {idna.__version__}')

          import scipy
          print(f'scipy {scipy.__version__}')
          import sklearn
          print(f'scikit-learn OK')

          print('ALL ML DEPENDENCIES VERIFIED - CPU-only torch confirmed')
          "

      - name: Check disk space before build
        run: Get-PSDrive C | Select-Object Used, Free

      - name: Build with PyInstaller
        run: |
          cd ${{ env.PROJECT_PATH }}
          pyinstaller QuickTranslate.spec --clean
          echo "PyInstaller build complete"

      - name: Verify build output (MUST PASS)
        run: |
          $distPath = "${{ env.PROJECT_PATH }}\dist\QuickTranslate"

          # 1. Verify QuickTranslate.exe exists
          if (-Not (Test-Path "$distPath\QuickTranslate.exe")) {
            Write-Error "FATAL: QuickTranslate.exe not found in dist!"
            exit 1
          }
          Write-Host "QuickTranslate.exe: OK"

          # 2. Verify clean layout (_internal/ contains all dependencies)
          if (-Not (Test-Path "$distPath\_internal")) {
            Write-Error "FATAL: _internal/ directory not found! PyInstaller layout is wrong."
            exit 1
          }
          Write-Host "_internal/ directory: OK"

          # 3. Verify root is CLEAN (only exe + _internal + working folders)
          $rootFiles = Get-ChildItem -Path $distPath -File | Where-Object { $_.Name -ne "QuickTranslate.exe" }
          $dllsInRoot = $rootFiles | Where-Object { $_.Extension -eq ".dll" }
          if ($dllsInRoot.Count -gt 0) {
            Write-Error "FATAL: DLLs found in root folder! Layout is not clean."
            $dllsInRoot | ForEach-Object { Write-Host "  Unwanted: $($_.Name)" }
            exit 1
          }
          Write-Host "Clean root (no DLLs alongside exe): OK"

          # 4. Check critical DLLs inside _internal/
          $internalPath = "$distPath\_internal"
          $vcrt = Get-ChildItem -Path $internalPath -Recurse -Filter "vcruntime140.dll" -ErrorAction SilentlyContinue
          if ($vcrt) {
            Write-Host "vcruntime140.dll: $($vcrt.FullName)"
          } else {
            Write-Error "FATAL: vcruntime140.dll not in _internal/! App will crash on fresh machines!"
            exit 1
          }

          # 5. Check torch DLLs exist inside _internal/
          $torchDlls = @("c10.dll", "torch_cpu.dll")
          foreach ($dll in $torchDlls) {
            $found = Get-ChildItem -Path $internalPath -Recurse -Filter $dll -ErrorAction SilentlyContinue
            if ($found) {
              Write-Host "${dll}: $($found.FullName)"
            } else {
              Write-Error "FATAL: ${dll} not found in _internal/!"
              exit 1
            }
          }

          # 6. Check sentence_transformers package exists
          $stPath = Get-ChildItem -Path $internalPath -Recurse -Directory -Filter "sentence_transformers" -ErrorAction SilentlyContinue
          if ($stPath) {
            Write-Host "sentence_transformers: $($stPath.FullName)"
          } else {
            Write-Error "FATAL: sentence_transformers not found in _internal/!"
            exit 1
          }

          # 7. Check runtime hook is bundled
          $hookFile = Get-ChildItem -Path $internalPath -Recurse -Filter "runtime_hook_torch*" -ErrorAction SilentlyContinue
          if ($hookFile) {
            Write-Host "runtime_hook_torch: $($hookFile.FullName)"
          } else {
            Write-Host "WARNING: runtime_hook_torch not found as file (may be compiled into exe)"
          }

          Write-Host ""
          Write-Host "POST-BUILD VERIFICATION PASSED"
          Write-Host "Layout: QuickTranslate.exe + _internal/ (clean, professional)"

      - name: Smoke test - run actual exe (MUST PASS)
        run: |
          $distPath = "${{ env.PROJECT_PATH }}\dist\QuickTranslate"
          $exePath = "$distPath\QuickTranslate.exe"

          Write-Host "Running QuickTranslate.exe --smoke-test..."
          Write-Host "This tests ALL imports inside the ACTUAL built executable."
          Write-Host ""

          # Run the ACTUAL built exe with --smoke-test flag.
          # This runs INSIDE the PyInstaller bundle, using ONLY packaged modules.
          # No system Python, no pip packages - just what PyInstaller bundled.
          # Stderr is redirected to a file (console=False means no stdout).
          $stderrFile = "$distPath\smoke_test_output.txt"
          $proc = Start-Process -FilePath $exePath -ArgumentList "--smoke-test" -Wait -PassThru -NoNewWindow -RedirectStandardError $stderrFile 2>$null

          # Display output
          if (Test-Path $stderrFile) {
            Get-Content $stderrFile
          }

          # Check crash log too
          $crashLog = "$distPath\QuickTranslate_crash.log"
          if (Test-Path $crashLog) {
            Write-Host ""
            Write-Host "=== CRASH LOG ==="
            Get-Content $crashLog
          }

          # Verify exit code
          if ($proc.ExitCode -ne 0) {
            Write-Error "FATAL: Smoke test FAILED! Exit code: $($proc.ExitCode)"
            exit 1
          }

          # Verify SMOKE_TEST_PASSED appears in output
          if (Test-Path $stderrFile) {
            $output = Get-Content $stderrFile -Raw
            if ($output -match "SMOKE_TEST_PASSED") {
              Write-Host ""
              Write-Host "SMOKE TEST PASSED - All imports verified in actual exe!"
            } else {
              Write-Error "FATAL: Smoke test did not output SMOKE_TEST_PASSED!"
              exit 1
            }
          } else {
            Write-Error "FATAL: No smoke test output file!"
            exit 1
          }

      - name: Build size validation (MUST PASS)
        run: |
          $distPath = "${{ env.PROJECT_PATH }}\dist\QuickTranslate"
          $distSize = (Get-ChildItem -Path $distPath -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB
          $distSizeRounded = [math]::Round($distSize, 1)
          Write-Host "Total dist size: $distSizeRounded MB"

          # CPU-only torch build should be 400-1200 MB
          # If CUDA torch got bundled, it would be 2000+ MB
          if ($distSize -gt 1500) {
            Write-Error "FATAL: Dist is $distSizeRounded MB - CUDA torch may have been bundled!"
            exit 1
          }
          Write-Host "Build size OK (under 1500 MB limit)"

      - name: Create output directory and working folders
        run: |
          $projectPath = "${{ env.PROJECT_PATH }}"
          $distPath = "$projectPath\dist\QuickTranslate"

          # Create centralized output directory for all artifacts
          New-Item -ItemType Directory -Path "$projectPath\installer_output" -Force

          # Create working folders in dist
          $workingFolders = @("Output")
          foreach ($folder in $workingFolders) {
            $path = "$distPath\$folder"
            New-Item -ItemType Directory -Path $path -Force | Out-Null
            New-Item -ItemType File -Path "$path\.gitkeep" -Force | Out-Null
          }

          Write-Host "Working folders created with .gitkeep files"

      - name: Build Inno Setup installer
        run: |
          choco install innosetup -y

          $projectPath = "${{ env.PROJECT_PATH }}"
          $version = "${{ env.VERSION }}"
          $issPath = "$projectPath\installer\QuickTranslate.iss"
          $outputDir = "$projectPath\installer_output"

          # Build installer with version and output directory
          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" /DAppVersion=$version /O"$outputDir" $issPath

          # Rename output to include version
          $installerFile = Get-ChildItem -Path $outputDir -Filter "*.exe" | Select-Object -First 1
          if ($installerFile) {
            $newName = "QuickTranslate_v${version}_Setup.exe"
            Rename-Item -Path $installerFile.FullName -NewName $newName
            Write-Host "Installer: $newName"
          }

      - name: Create portable ZIP
        run: |
          $version = "${{ env.VERSION }}"
          $projectPath = "${{ env.PROJECT_PATH }}"
          $distPath = "$projectPath\dist\QuickTranslate"
          $zipPath = "$projectPath\installer_output\QuickTranslate_v${version}_Portable.zip"

          # Create portable ZIP from dist folder
          Compress-Archive -Path "$distPath\*" -DestinationPath $zipPath -Force

          $size = (Get-Item $zipPath).Length / 1MB
          Write-Host "Portable ZIP: $([math]::Round($size, 1)) MB"

      - name: Create source ZIP
        run: |
          $version = "${{ env.VERSION }}"
          $projectPath = "${{ env.PROJECT_PATH }}"
          $zipPath = "$projectPath\installer_output\QuickTranslate_v${version}_Source.zip"

          # Create temp directory for clean source
          $tempDir = New-Item -ItemType Directory -Path "$env:TEMP\QT_Source" -Force
          $excludes = @("dist", "build", "__pycache__", "*.pyc", "installer_output", ".pytest_cache", "archive")

          # Copy source files excluding build artifacts
          Get-ChildItem -Path $projectPath -Exclude $excludes | Copy-Item -Destination $tempDir -Recurse -Force

          # Remove any __pycache__ directories that got copied
          Get-ChildItem -Path $tempDir -Recurse -Directory -Filter "__pycache__" | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue

          # Create working folders in source bundle
          $sourceFolders = @("Output")
          foreach ($folder in $sourceFolders) {
            $path = "$tempDir\$folder"
            New-Item -ItemType Directory -Path $path -Force | Out-Null
            New-Item -ItemType File -Path "$path\.gitkeep" -Force | Out-Null
          }

          # Create source ZIP
          Compress-Archive -Path "$tempDir\*" -DestinationPath $zipPath -Force

          # Cleanup temp directory
          Remove-Item -Path $tempDir -Recurse -Force

          $size = (Get-Item $zipPath).Length / 1MB
          Write-Host "Source ZIP: $([math]::Round($size, 1)) MB"

      - name: Upload Setup artifact
        uses: actions/upload-artifact@v4
        with:
          name: QuickTranslate-Setup
          path: ${{ env.PROJECT_PATH }}/installer_output/*_Setup.exe
          retention-days: 30

      - name: Upload Portable artifact
        uses: actions/upload-artifact@v4
        with:
          name: QuickTranslate-Portable
          path: ${{ env.PROJECT_PATH }}/installer_output/*_Portable.zip
          retention-days: 30

      - name: Upload Source artifact
        uses: actions/upload-artifact@v4
        with:
          name: QuickTranslate-Source
          path: ${{ env.PROJECT_PATH }}/installer_output/*_Source.zip
          retention-days: 30

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: quicktranslate-v${{ env.VERSION }}
          name: QuickTranslate v${{ env.VERSION }}
          body: |
            ## QuickTranslate v${{ env.VERSION }}

            Translation lookup and transfer tool for Korean text matching in XML files.

            ### Features
            **Match Types:**
            - **Substring Match**: Original - finds text in StrOrigin
            - **StringID-Only (SCRIPT)**: For Sequencer/Dialog strings
            - **Strict (StringID + StrOrigin)**: Most precise matching
            - **Special Key Match**: Match by StringID + Category

            **Input Modes:**
            - File (single) or Folder (recursive)
            - Excel (.xlsx) or XML (.xml) format

            **Core Features:**
            - **LOOKUP**: Find translations across 17 languages
            - **TRANSFER**: Apply corrections to XML files
            - **Find Missing Translations**: Per-language XML + Excel report with Korean word counts
            - **Reverse Lookup**: Input text in any language -> find all translations
            - **Direct StringID Lookup**: Quick lookup by StringID
            - **Settings**: Configurable LOC/EXPORT paths (persisted to settings.json)

            ### Downloads
            - **Setup.exe**: Installer with drive selection
            - **Portable.zip**: Standalone executable with working folders
            - **Source.zip**: Python source code

            ### Supported Languages
            Korean (KOR), English (ENG), French (FRE), German (GER), Spanish (SPA), Portuguese (POR), Italian (ITA), Russian (RUS), Turkish (TUR), Polish (POL), Chinese Simplified (ZHO-CN), Chinese Traditional (ZHO-TW), Japanese (JPN), Thai (THA), Vietnamese (VIE), Indonesian (IND), Malay (MSA)

          files: |
            ${{ env.PROJECT_PATH }}/installer_output/*.exe
            ${{ env.PROJECT_PATH }}/installer_output/*.zip
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
