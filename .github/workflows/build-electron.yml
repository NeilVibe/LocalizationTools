name: Build LocaNext Installer

# ============================================================================
# DEV MODE IS DEAD. Workers make all tests fast. QA is now the only mode.
#
# GitHub supports:
#   - Build / Build QA: ALL tests (~1000+), light installer (~150MB)
#   - TROUBLESHOOT: Smart checkpoint mode
#
# GitHub REJECTS:
#   - Build QA FULL: REJECTED (LFS bandwidth limits, use Gitea instead)
#
# QA FULL is GITEA ONLY. Never GitHub.
# ============================================================================

on:
  push:
    branches: [ main ]
    paths:
      - 'BUILD_TRIGGER.txt'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  check-build-trigger:
    name: Check Build Trigger
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      version: ${{ steps.check.outputs.version }}
      mode: ${{ steps.check.outputs.mode }}
      skip_build: ${{ steps.check.outputs.skip_build }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check BUILD_TRIGGER.txt
        id: check
        run: |
          # ============================================================
          # DEV MODE IS DEAD. QA is now the only mode.
          # GitHub REJECTS QA FULL (use Gitea for offline builds)
          # ============================================================
          TRIGGER=$(cat BUILD_TRIGGER.txt | grep -E "^Build( QA)?( FULL)?$|^TROUBLESHOOT" | tail -1)
          echo "Trigger line: $TRIGGER"

          # REJECT QA FULL on GitHub (LFS bandwidth limits)
          if echo "$TRIGGER" | grep -q "QA FULL"; then
            echo ""
            echo "============================================"
            echo "[REJECTED] QA FULL is GITEA ONLY"
            echo "============================================"
            echo "GitHub has LFS bandwidth limits."
            echo "QA FULL builds (~2GB) must use Gitea."
            echo ""
            echo "Use: git push gitea main"
            echo "============================================"
            echo ""
            echo "should_build=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ -n "$TRIGGER" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT

            # AUTO-GENERATE VERSION: YY.MDD.HHMM format (semver-compatible, no leading zeros)
            # electron-updater requires valid semver: MAJOR.MINOR.PATCH (no leading zeros)
            VERSION=$(TZ='Asia/Seoul' date '+%y.%-m%d.%H%M')
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "[OK] Auto-generated version: $VERSION (semver-compatible)"

            # Detect mode
            if echo "$TRIGGER" | grep -q "^TROUBLESHOOT"; then
              echo "mode=troubleshoot" >> $GITHUB_OUTPUT
              echo "skip_build=yes" >> $GITHUB_OUTPUT
              echo "[TROUBLESHOOT] Test-only mode (no Windows build)"
            else
              echo "mode=official" >> $GITHUB_OUTPUT
              echo "skip_build=no" >> $GITHUB_OUTPUT
              echo "[QA MODE] Running ALL tests (~1000+) - this is now the default"
            fi
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
            echo "No build trigger found"
          fi

  # ============================================================
  # SAFETY CHECKS - Must pass before build proceeds
  # ============================================================
  safety-checks:
    name: Safety Checks (Tests, Security, Version)
    runs-on: ubuntu-latest
    needs: check-build-trigger
    if: needs.check-build-trigger.outputs.should_build == 'true'

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: locanext
          POSTGRES_PASSWORD: locanext_test
          POSTGRES_DB: locanext_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      BUILD_MODE: ${{ needs.check-build-trigger.outputs.mode }}
      # Server config.py uses individual POSTGRES_* env vars, not DATABASE_URL
      POSTGRES_USER: locanext
      POSTGRES_PASSWORD: locanext_test
      POSTGRES_DB: locanext_test
      POSTGRES_HOST: localhost
      POSTGRES_PORT: "5432"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Setup Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: locaNext/package-lock.json

      - name: Install Python Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pip-audit

      # ---- ENABLE PG_TRGM EXTENSION (required for TM similarity search) ----
      - name: Enable PostgreSQL Extensions
        run: |
          echo "=== Enabling pg_trgm extension for TM search ==="
          PGPASSWORD=locanext_test psql -h localhost -U locanext -d locanext_test -c "CREATE EXTENSION IF NOT EXISTS pg_trgm;"
          echo "[OK] pg_trgm extension enabled"

      # ============================================================
      # GDP-P10: REPOSITORY PATTERN VERIFICATION
      # Granular Debug Protocol for P10 DB Abstraction Layer
      # These checkpoints verify the Factory+Abstract+Repo pattern
      # works correctly BEFORE running the full test suite.
      # ============================================================
      - name: GDP-P10-1 Repository Imports Check
        run: |
          echo "╔════════════════════════════════════════════════════════════╗"
          echo "║  GDP-P10-1: REPOSITORY IMPORTS CHECK                       ║"
          echo "╚════════════════════════════════════════════════════════════╝"
          python << 'EOF'
          import sys
          errors = []

          # Check all repository interfaces exist
          print("Checking repository interfaces...")
          try:
              from server.repositories.interfaces.tm_repository import TMRepository
              from server.repositories.interfaces.file_repository import FileRepository
              from server.repositories.interfaces.row_repository import RowRepository
              from server.repositories.interfaces.project_repository import ProjectRepository
              from server.repositories.interfaces.folder_repository import FolderRepository
              from server.repositories.interfaces.platform_repository import PlatformRepository
              from server.repositories.interfaces.qa_repository import QAResultRepository
              from server.repositories.interfaces.trash_repository import TrashRepository
              from server.repositories.interfaces.capability_repository import CapabilityRepository
              print("  ✓ All 9 repository interfaces imported")
          except ImportError as e:
              errors.append(f"Interface import failed: {e}")

          # Check factory functions exist
          print("Checking factory functions...")
          try:
              from server.repositories.factory import (
                  get_tm_repository,
                  get_file_repository,
                  get_row_repository,
                  get_project_repository,
                  get_folder_repository,
                  get_platform_repository,
                  get_qa_repository,
                  get_trash_repository,
                  get_capability_repository,
              )
              print("  ✓ All 9 factory functions imported")
          except ImportError as e:
              errors.append(f"Factory import failed: {e}")

          # Check PostgreSQL adapters exist
          print("Checking PostgreSQL adapters...")
          try:
              from server.repositories.postgresql.tm_repo import PostgreSQLTMRepository
              from server.repositories.postgresql.file_repo import PostgreSQLFileRepository
              from server.repositories.postgresql.row_repo import PostgreSQLRowRepository
              from server.repositories.postgresql.project_repo import PostgreSQLProjectRepository
              from server.repositories.postgresql.folder_repo import PostgreSQLFolderRepository
              from server.repositories.postgresql.platform_repo import PostgreSQLPlatformRepository
              from server.repositories.postgresql.qa_repo import PostgreSQLQAResultRepository
              from server.repositories.postgresql.trash_repo import PostgreSQLTrashRepository
              from server.repositories.postgresql.capability_repo import PostgreSQLCapabilityRepository
              print("  ✓ All 9 PostgreSQL adapters imported")
          except ImportError as e:
              errors.append(f"PostgreSQL adapter import failed: {e}")

          # Check SQLite adapters exist
          print("Checking SQLite adapters...")
          try:
              from server.repositories.sqlite.tm_repo import SQLiteTMRepository
              from server.repositories.sqlite.file_repo import SQLiteFileRepository
              from server.repositories.sqlite.row_repo import SQLiteRowRepository
              from server.repositories.sqlite.project_repo import SQLiteProjectRepository
              from server.repositories.sqlite.folder_repo import SQLiteFolderRepository
              from server.repositories.sqlite.platform_repo import SQLitePlatformRepository
              from server.repositories.sqlite.qa_repo import SQLiteQAResultRepository
              from server.repositories.sqlite.trash_repo import SQLiteTrashRepository
              from server.repositories.sqlite.capability_repo import SQLiteCapabilityRepository
              print("  ✓ All 9 SQLite adapters imported")
          except ImportError as e:
              errors.append(f"SQLite adapter import failed: {e}")

          if errors:
              print("\n❌ GDP-P10-1 FAILED:")
              for e in errors:
                  print(f"  - {e}")
              sys.exit(1)
          else:
              print("\n✅ GDP-P10-1 PASSED: All repository imports OK")
          EOF

      - name: GDP-P10-2 Factory Pattern Test
        run: |
          echo "╔════════════════════════════════════════════════════════════╗"
          echo "║  GDP-P10-2: FACTORY PATTERN TEST                           ║"
          echo "╚════════════════════════════════════════════════════════════╝"
          python << 'EOF'
          import sys
          from abc import ABC

          # Test that factory functions return correct types based on mode
          print("Testing factory pattern...")

          # Import factory module
          from server.repositories import factory

          # Check _is_offline_mode function exists
          if not hasattr(factory, '_is_offline_mode'):
              print("❌ _is_offline_mode function not found in factory")
              sys.exit(1)
          print("  ✓ _is_offline_mode function exists")

          # Check all factory functions have correct signature
          factory_funcs = [
              'get_tm_repository',
              'get_file_repository',
              'get_row_repository',
              'get_project_repository',
              'get_folder_repository',
              'get_platform_repository',
              'get_qa_repository',
              'get_trash_repository',
              'get_capability_repository',
          ]

          for func_name in factory_funcs:
              if not hasattr(factory, func_name):
                  print(f"❌ {func_name} not found in factory")
                  sys.exit(1)
          print(f"  ✓ All {len(factory_funcs)} factory functions exist")

          print("\n✅ GDP-P10-2 PASSED: Factory pattern OK")
          EOF

      - name: GDP-P10-3 Abstract Interface Test
        run: |
          echo "╔════════════════════════════════════════════════════════════╗"
          echo "║  GDP-P10-3: ABSTRACT INTERFACE TEST                        ║"
          echo "╚════════════════════════════════════════════════════════════╝"
          python << 'EOF'
          import sys
          from abc import ABC, abstractmethod

          print("Testing abstract interfaces...")

          # Import and verify TMRepository interface
          from server.repositories.interfaces.tm_repository import TMRepository

          # Check it's abstract
          if not issubclass(TMRepository, ABC):
              print("❌ TMRepository is not an ABC")
              sys.exit(1)
          print("  ✓ TMRepository is abstract")

          # Check required methods exist
          required_methods = ['get', 'get_all', 'create', 'delete']
          for method in required_methods:
              if not hasattr(TMRepository, method):
                  print(f"❌ TMRepository missing method: {method}")
                  sys.exit(1)
          print(f"  ✓ TMRepository has required methods: {required_methods}")

          # Verify PostgreSQL adapter implements interface
          from server.repositories.postgresql.tm_repo import PostgreSQLTMRepository
          if not issubclass(PostgreSQLTMRepository, TMRepository):
              print("❌ PostgreSQLTMRepository doesn't implement TMRepository")
              sys.exit(1)
          print("  ✓ PostgreSQLTMRepository implements TMRepository")

          # Verify SQLite adapter implements interface
          from server.repositories.sqlite.tm_repo import SQLiteTMRepository
          if not issubclass(SQLiteTMRepository, TMRepository):
              print("❌ SQLiteTMRepository doesn't implement TMRepository")
              sys.exit(1)
          print("  ✓ SQLiteTMRepository implements TMRepository")

          print("\n✅ GDP-P10-3 PASSED: Abstract interfaces OK")
          EOF

      - name: GDP-P10-4 Test File Imports Check
        run: |
          echo "╔════════════════════════════════════════════════════════════╗"
          echo "║  GDP-P10-4: TEST FILE IMPORTS CHECK                        ║"
          echo "╚════════════════════════════════════════════════════════════╝"
          python << 'EOF'
          import sys

          print("Checking test files can import repository mocks...")

          # Check test_mocked_full.py imports work
          try:
              # These are the exact imports from the test file
              from server.repositories.factory import (
                  get_project_repository,
                  get_file_repository,
                  get_folder_repository,
                  get_row_repository,
                  get_tm_repository,
                  get_platform_repository,
                  get_qa_repository,
                  get_trash_repository,
                  get_capability_repository,
              )
              print("  ✓ test_mocked_full.py imports OK")
          except ImportError as e:
              print(f"❌ test_mocked_full.py import failed: {e}")
              sys.exit(1)

          # Check server.main imports (for FastAPI app)
          try:
              from server.main import app as wrapped_app
              fastapi_app = wrapped_app.other_asgi_app
              print("  ✓ server.main app import OK")
          except Exception as e:
              print(f"❌ server.main import failed: {e}")
              sys.exit(1)

          # Check dependencies import
          try:
              from server.utils.dependencies import get_current_active_user_async
              print("  ✓ dependencies import OK")
          except ImportError as e:
              print(f"❌ dependencies import failed: {e}")
              sys.exit(1)

          print("\n✅ GDP-P10-4 PASSED: Test file imports OK")
          EOF
      # ============================================================
      # END GDP-P10: Repository Pattern Verification
      # ============================================================

      - name: Install Node Dependencies
        run: |
          cd locaNext && npm ci

      # ---- P35: SVELTE 5 BUILD HEALTH CHECK ----
      - name: Svelte 5 Build Health Check
        run: |
          echo "=== P35: Checking for Svelte 5 reactivity issues ==="
          chmod +x scripts/check_svelte_build.sh
          ./scripts/check_svelte_build.sh
          echo "[OK] Svelte 5 build health check passed"

      # ---- INJECT VERSION (Pipeline Executive Power) ----
      - name: Inject Version
        run: |
          VERSION="${{ needs.check-build-trigger.outputs.version }}"
          echo "=== PIPELINE EXECUTIVE POWER ==="
          echo "Injecting version: $VERSION (YY.MMDD.HHMM format)"

          # Update version.py (VERSION only - SEMANTIC_VERSION is an alias)
          sed -i "s/VERSION = \"[^\"]*\"/VERSION = \"$VERSION\"/" version.py

          # Update package.json
          sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" locaNext/package.json

          # NOTE: Inno Setup .iss files deprecated (P28) - using electron-builder NSIS now

          echo "[OK] All files updated to version: $VERSION"
          grep "VERSION" version.py | head -1

      # ---- VERSION CHECK ----
      - name: Version Unification Check
        run: |
          echo "=== Checking version unification across all files ==="
          python scripts/check_version_unified.py
          echo "[OK] All versions unified"

      # ---- VERSION INCREMENT CHECK ----
      - name: Check Version Increment
        run: |
          echo "=== Checking version is newer than latest release ==="

          # Get current version from version.py
          CURRENT_VERSION=$(python -c "from version import VERSION; print(VERSION)")
          echo "Current version: $CURRENT_VERSION"

          # Get latest release version from GitHub
          LATEST_TAG=$(gh release list --limit 1 --json tagName -q '.[0].tagName' 2>/dev/null || echo "v0")
          LATEST_VERSION=$(echo "$LATEST_TAG" | sed 's/v//')
          echo "Latest release: $LATEST_VERSION"

          # Compare versions (both are YYMMDDHHMM format, simple numeric comparison)
          if [ "$CURRENT_VERSION" -le "$LATEST_VERSION" ] 2>/dev/null; then
            echo "[WARNING] Current version ($CURRENT_VERSION) is not greater than latest release ($LATEST_VERSION)"
            echo "Consider updating VERSION in version.py"
          else
            echo "[OK] Version $CURRENT_VERSION is newer than $LATEST_VERSION"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ---- START SERVER FOR TESTS ----
      - name: Start Server for Tests
        env:
          POSTGRES_USER: locanext
          POSTGRES_PASSWORD: locanext_test
          POSTGRES_DB: locanext_test
          POSTGRES_HOST: localhost
          POSTGRES_PORT: "5432"
        run: |
          echo "=== Starting server for tests ==="
          python server/main.py &
          echo $! > /tmp/server.pid

          # Wait for server with retries
          for i in {1..15}; do
            sleep 2
            echo "Checking server... ($i/15)"
            if curl -s http://localhost:8888/health | grep -q "healthy"; then
              echo "[OK] Server started successfully (PID: $(cat /tmp/server.pid))"
              exit 0
            fi
          done

          echo "[ERROR] Server failed to start!"
          cat /tmp/server.pid | xargs kill 2>/dev/null || true
          exit 1

      # ---- VERIFY POSTGRESQL CONNECTION (P35 SMOKE TEST) ----
      - name: Verify PostgreSQL Connection
        run: |
          echo "=== P35: Verifying Central Server Connection ==="

          # Get health endpoint data
          HEALTH_JSON=$(curl -s http://localhost:8888/health)
          echo "Health response: $HEALTH_JSON"

          # Extract database_type
          DB_TYPE=$(echo "$HEALTH_JSON" | jq -r '.database_type // "unknown"')
          echo "Database type: $DB_TYPE"

          # FAIL if not PostgreSQL (means fallback to SQLite happened)
          if [ "$DB_TYPE" != "postgresql" ]; then
            echo ""
            echo "=========================================="
            echo "[FAIL] CENTRAL SERVER CONNECTION FAILED!"
            echo "=========================================="
            echo "Expected: postgresql"
            echo "Got: $DB_TYPE"
            echo ""
            echo "This means PostgreSQL was not reachable and server fell back to SQLite."
            echo "Check PostgreSQL service is running on localhost:5432"
            echo ""
            echo "=== Server logs (database section) ==="
            grep -i "database\|postgresql\|sqlite" /tmp/server.log | tail -20
            exit 1
          fi

          echo ""
          echo "=========================================="
          echo "[OK] SUCCESS! Connected to Central Server (PostgreSQL)"
          echo "=========================================="

      # ---- CREATE ADMIN USER FOR TESTS ----
      - name: Create Admin User
        env:
          POSTGRES_USER: locanext
          POSTGRES_PASSWORD: locanext_test
          POSTGRES_DB: locanext_test
          POSTGRES_HOST: localhost
          POSTGRES_PORT: "5432"
        run: |
          echo "=== Creating admin user for tests ==="
          python scripts/create_admin.py || echo "Admin may already exist"
          echo "[OK] Admin user ready"

      # ---- PYTHON TESTS ----
      - name: Run Python Tests
        env:
          POSTGRES_USER: locanext
          POSTGRES_PASSWORD: locanext_test
          POSTGRES_DB: locanext_test
          POSTGRES_HOST: localhost
          POSTGRES_PORT: "5432"
          RUN_API_TESTS: "1"
        run: |
          echo "=== Running all Python tests ==="
          echo "Server: $(curl -s http://localhost:8888/health)"
          # UNIFIED CONFIG (matches Gitea exactly)
          # Deselect model-dependent tests (require 2GB Korean BERT model)
          python -m pytest \
            tests/unit/ \
            tests/integration/ \
            tests/security/ \
            tests/e2e/test_kr_similar_e2e.py \
            tests/e2e/test_xlstransfer_e2e.py \
            tests/e2e/test_quicksearch_e2e.py \
            tests/e2e/test_full_simulation.py \
            --deselect=tests/integration/test_tm_real_model.py \
            --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferEmbeddings::test_05_model_loads \
            --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferEmbeddings::test_06_process_excel_for_dictionary \
            --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferEmbeddings::test_07_save_and_load_dictionary \
            --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferTranslation::test_08_find_best_match \
            --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferTranslation::test_09_translate_with_high_threshold \
            -v --tb=short --no-cov -x
          echo "[OK] All Python tests passed"

      - name: Stop Server
        if: always()
        run: |
          if [ -f /tmp/server.pid ]; then
            cat /tmp/server.pid | xargs kill 2>/dev/null || true
            echo "[OK] Server stopped"
          fi

      # ---- SECURITY AUDITS ----
      - name: Python Security Audit
        run: |
          echo "=== Checking Python dependencies for vulnerabilities ==="
          pip-audit --desc || echo "⚠️ Vulnerabilities found - logged for review"
          echo "[OK] Python security audit complete"
        continue-on-error: true

      - name: NPM Security Audit
        run: |
          cd locaNext
          npm audit || echo "⚠️ Vulnerabilities found - logged for review"
          echo "[OK] NPM security audit complete"
        continue-on-error: true

      - name: Safety Checks Summary
        run: |
          echo "============================================"
          echo "[PASS] SAFETY CHECKS PASSED"
          echo "============================================"

  # ============================================================
  # BUILD WINDOWS INSTALLER
  # ============================================================
  build-windows:
    name: Build Windows LIGHT Installer
    runs-on: windows-latest
    needs: [check-build-trigger, safety-checks]
    if: needs.check-build-trigger.outputs.should_build == 'true' && needs.check-build-trigger.outputs.skip_build != 'yes'

    env:
      BUILD_VERSION: ${{ needs.check-build-trigger.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Setup Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: locaNext/package-lock.json

      # ============================================================
      # STEP 1: Download VC++ Redistributable (bundle in installer)
      # ============================================================
      - name: Download VC++ Redistributable
        run: |
          Write-Host "Downloading VC++ Redistributable x64..."
          New-Item -ItemType Directory -Force -Path "installer\redist"
          Invoke-WebRequest -Uri "https://aka.ms/vs/17/release/vc_redist.x64.exe" -OutFile "installer\redist\vc_redist.x64.exe"
          $size = (Get-Item "installer\redist\vc_redist.x64.exe").length / 1MB
          Write-Host "[OK] Downloaded VC++ Redistributable: $([math]::Round($size, 1)) MB"
        shell: pwsh

      # ============================================================
      # STEP 2: Download Python Embedded (portable, ~15MB)
      # IT-Friendly: No .exe compilation, just portable Python!
      # ============================================================
      - name: Download Python Embedded
        run: |
          Write-Host "Downloading Python Embedded (portable)..."
          New-Item -ItemType Directory -Force -Path "tools\python"

          # Download Python 3.11 embedded (Windows x64)
          $pythonUrl = "https://www.python.org/ftp/python/3.11.9/python-3.11.9-embed-amd64.zip"
          $zipPath = "tools\python-embedded.zip"

          Invoke-WebRequest -Uri $pythonUrl -OutFile $zipPath
          Expand-Archive -Path $zipPath -DestinationPath "tools\python" -Force
          Remove-Item $zipPath

          # Enable pip in embedded Python (uncomment import site)
          $pthFile = Get-ChildItem "tools\python\python*._pth" | Select-Object -First 1
          if ($pthFile) {
            $content = Get-Content $pthFile.FullName
            $content = $content -replace '#import site', 'import site'
            Set-Content -Path $pthFile.FullName -Value $content
          }

          # Download and install pip
          Write-Host "Installing pip in embedded Python..."
          Invoke-WebRequest -Uri "https://bootstrap.pypa.io/get-pip.py" -OutFile "tools\python\get-pip.py"
          & "tools\python\python.exe" "tools\python\get-pip.py" --no-warn-script-location
          Remove-Item "tools\python\get-pip.py"

          # Install huggingface_hub (for model download)
          Write-Host "Installing huggingface_hub..."
          & "tools\python\python.exe" -m pip install --no-warn-script-location huggingface_hub

          # Install LIGHT backend dependencies (heavy ones like torch download post-install)
          Write-Host "Installing light backend dependencies..."
          & "tools\python\python.exe" -m pip install --no-warn-script-location `
            fastapi uvicorn python-multipart python-socketio `
            sqlalchemy aiosqlite psycopg2-binary `
            PyJWT python-jose passlib python-dotenv bcrypt `
            pydantic pydantic-settings email-validator `
            pandas openpyxl xlrd `
            httpx requests loguru tqdm pyyaml

          $totalSize = (Get-ChildItem "tools\python" -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB
          Write-Host "[OK] Python Embedded ready: $([math]::Round($totalSize, 1)) MB"
        shell: pwsh

      - name: Verify Python Embedded + ALL Dependencies
        run: |
          Write-Host "Verifying embedded Python setup..."
          Write-Host ""

          # Check Python works
          & "tools\python\python.exe" --version

          Write-Host ""
          Write-Host "=== Checking ALL critical packages (catches missing deps before build) ==="
          Write-Host ""

          # Core server dependencies
          & "tools\python\python.exe" -c "import fastapi; print(f'[OK] fastapi v{fastapi.__version__}')"
          & "tools\python\python.exe" -c "import uvicorn; print('[OK] uvicorn ready')"
          & "tools\python\python.exe" -c "import socketio; print('[OK] socketio (python-socketio) ready')"

          # Database
          & "tools\python\python.exe" -c "import sqlalchemy; print(f'[OK] sqlalchemy v{sqlalchemy.__version__}')"
          & "tools\python\python.exe" -c "import aiosqlite; print('[OK] aiosqlite ready')"

          # Authentication - CRITICAL: Both jwt packages needed!
          & "tools\python\python.exe" -c "import jwt; print(f'[OK] jwt (PyJWT) v{jwt.__version__}')"
          & "tools\python\python.exe" -c "from jose import jwt as jose_jwt; print('[OK] jose.jwt (python-jose) ready')"
          & "tools\python\python.exe" -c "import passlib; print('[OK] passlib ready')"
          & "tools\python\python.exe" -c "import bcrypt; print('[OK] bcrypt ready')"
          & "tools\python\python.exe" -c "import dotenv; print('[OK] python-dotenv ready')"

          # Validation
          & "tools\python\python.exe" -c "import pydantic; print(f'[OK] pydantic v{pydantic.__version__}')"
          & "tools\python\python.exe" -c "import pydantic_settings; print('[OK] pydantic-settings ready')"
          & "tools\python\python.exe" -c "import email_validator; print('[OK] email-validator ready')"

          # Data processing
          & "tools\python\python.exe" -c "import pandas; print(f'[OK] pandas v{pandas.__version__}')"
          & "tools\python\python.exe" -c "import openpyxl; print('[OK] openpyxl ready')"
          & "tools\python\python.exe" -c "import xlrd; print('[OK] xlrd ready')"

          # HTTP
          & "tools\python\python.exe" -c "import httpx; print('[OK] httpx ready')"
          & "tools\python\python.exe" -c "import requests; print('[OK] requests ready')"

          # Logging & utilities
          & "tools\python\python.exe" -c "import loguru; print('[OK] loguru ready')"
          & "tools\python\python.exe" -c "import tqdm; print('[OK] tqdm ready')"
          & "tools\python\python.exe" -c "import yaml; print('[OK] pyyaml ready')"

          # Model downloading (for LIGHT build post-install)
          & "tools\python\python.exe" -c "import huggingface_hub; print(f'[OK] huggingface_hub v{huggingface_hub.__version__}')"

          Write-Host ""
          Write-Host "=== Checking required files ==="
          Write-Host ""

          # Check version.py exists (CRITICAL - was missing!)
          if (!(Test-Path "version.py")) {
            Write-Error "[ERROR] version.py not found - CRITICAL!"
            exit 1
          }
          Write-Host "[OK] version.py exists"

          # Check tools exist
          if (!(Test-Path "tools\download_model.bat")) {
            Write-Error "[ERROR] download_model.bat not found"
            exit 1
          }
          if (!(Test-Path "tools\download_model.py")) {
            Write-Error "[ERROR] download_model.py not found"
            exit 1
          }
          if (!(Test-Path "tools\install_deps.bat")) {
            Write-Error "[ERROR] install_deps.bat not found"
            exit 1
          }
          if (!(Test-Path "tools\install_deps.py")) {
            Write-Error "[ERROR] install_deps.py not found"
            exit 1
          }
          Write-Host "[OK] All tool scripts exist"

          # Check server exists
          if (!(Test-Path "server\main.py")) {
            Write-Error "[ERROR] server/main.py not found"
            exit 1
          }
          Write-Host "[OK] server/main.py exists"

          Write-Host ""
          Write-Host "[PASS] All embedded Python dependencies verified!"
        shell: pwsh

      - name: Test Server Launch with Embedded Python
        run: |
          Write-Host "=== Testing server can START with embedded Python ==="
          $env:PYTHONPATH = Get-Location
          Write-Host "Testing server imports..."
          & "tools\python\python.exe" -c "import sys; sys.path.insert(0,'.'); from version import VERSION; print(f'version OK: v{VERSION}'); import server.main; print('server.main OK')"
          if ($LASTEXITCODE -ne 0) { Write-Error "Server import test FAILED!"; exit 1 }
          Write-Host "Server launch test passed!"
        shell: pwsh

      # ============================================================
      # STEP 3: Build Electron app
      # ============================================================

      # ============================================================
      # STEP 3.0: Set GitHub Release URL for Auto-Updates
      # This makes apps built by GitHub CI update from GitHub releases
      # (Gitea builds update from Gitea, GitHub builds update from GitHub)
      # ============================================================
      - name: Set GitHub Release URL for Auto-Updates
        run: |
          Write-Host "=== Setting GitHub Release URL ===" -ForegroundColor Cyan

          $pkgPath = "locaNext/package.json"
          $pkg = Get-Content $pkgPath -Raw

          # Replace Gitea URL with GitHub releases URL
          $giteaUrl = "http://172.28.150.120:3000/neilvibe/LocaNext/releases/download/latest"
          $githubUrl = "https://github.com/NeilVibe/LocalizationTools/releases/download/latest"

          $pkg = $pkg -replace [regex]::Escape($giteaUrl), $githubUrl

          # Write back
          [System.IO.File]::WriteAllText($pkgPath, $pkg)

          Write-Host "[OK] Publish URL changed to GitHub releases" -ForegroundColor Green
          Write-Host "    Apps built here will auto-update from GitHub" -ForegroundColor Cyan

          # Verify
          $verify = Get-Content $pkgPath | Select-String "github.com"
          if ($verify) {
            Write-Host "[OK] Verified: $verify" -ForegroundColor Green
          } else {
            Write-Host "[WARN] Could not verify URL change" -ForegroundColor Yellow
          }
        shell: pwsh

      - name: Install Node Dependencies
        run: |
          cd locaNext
          npm ci
        shell: pwsh

      # ============================================================
      # NSIS Include Files (FROM REPO - Always Reliable)
      # Files bundled in installer/nsis-includes/ - no downloads needed
      # ============================================================
      - name: Copy NSIS Include Files from Repo
        run: |
          Write-Host "=== NSIS Include Files (from repo) ===" -ForegroundColor Cyan

          $sourceDir = "installer\nsis-includes"
          $targetDir = "locaNext\node_modules\app-builder-lib\templates\nsis\include"

          # Create target directory
          New-Item -ItemType Directory -Force -Path $targetDir | Out-Null

          # Copy from repo (always available, no downloads)
          Copy-Item -Path "$sourceDir\*.nsh" -Destination $targetDir -Force

          # Verify
          $files = Get-ChildItem "$targetDir\*.nsh"
          Write-Host "[OK] Copied $($files.Count) NSIS include files from repo" -ForegroundColor Green

          # Verify StdUtils.nsh (required by electron-builder)
          if (Test-Path "$targetDir\StdUtils.nsh") {
            Write-Host "[OK] StdUtils.nsh verified" -ForegroundColor Green
          } else {
            Write-Host "[ERROR] StdUtils.nsh missing!" -ForegroundColor Red
            exit 1
          }
        shell: pwsh

      - name: Build Electron App
        run: |
          cd locaNext
          npm run build
          npm run build:electron
        shell: pwsh

      - name: Verify Electron Build
        run: |
          Write-Host "Verifying Electron build output..."

          if (!(Test-Path "locaNext\dist-electron\win-unpacked\LocaNext.exe")) {
            Write-Error "[ERROR] Electron build failed - LocaNext.exe not found"
            exit 1
          }

          Write-Host "[OK] Electron build successful"
          $size = (Get-Item "locaNext\dist-electron\win-unpacked\LocaNext.exe").length / 1MB
          Write-Host "  Executable size: $([math]::Round($size, 1)) MB"

          $totalSize = (Get-ChildItem "locaNext\dist-electron\win-unpacked" -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB
          Write-Host "  Total Electron app size: $([math]::Round($totalSize, 1)) MB"
        shell: pwsh

      # ============================================================
      # STEP 4: Collect NSIS Installer (electron-builder produces it)
      # ============================================================
      - name: Collect NSIS Installer
        run: |
          $version = "${{ needs.check-build-trigger.outputs.version }}"
          $outDir = "installer_output"

          Write-Host "=== Collecting NSIS Installer ==="
          Write-Host "Version: $version"

          # Create output directory
          if (!(Test-Path $outDir)) {
            New-Item -ItemType Directory -Path $outDir -Force
          }

          # Find the NSIS installer produced by electron-builder
          Write-Host "`nLooking for NSIS installer in locaNext/dist-electron:"
          Get-ChildItem "locaNext\dist-electron" | Format-Table Name, Length

          $installer = Get-ChildItem "locaNext\dist-electron\*.exe" -ErrorAction SilentlyContinue |
                       Where-Object { $_.Name -like "*Setup*" } |
                       Select-Object -First 1

          if (!$installer) {
            Write-Error "[ERROR] NSIS installer not found in dist-electron!"
            Write-Host "Available files:"
            Get-ChildItem "locaNext\dist-electron" -Recurse | Select-Object FullName
            exit 1
          }

          Write-Host "[OK] Found installer: $($installer.Name)"

          # Rename to include version
          $newName = "LocaNext_v${version}_Light_Setup.exe"
          Copy-Item $installer.FullName -Destination "$outDir\$newName"

          $size = (Get-Item "$outDir\$newName").Length / 1MB
          Write-Host "[OK] Installer ready: $newName ($([math]::Round($size, 1)) MB)" -ForegroundColor Green
        shell: pwsh

      - name: Verify NSIS Installer
        run: |
          $installer = Get-ChildItem "installer_output\*Setup*.exe" | Select-Object -First 1
          if (!$installer) { Write-Error "[ERROR] No installer found"; exit 1 }
          Write-Host "[OK] NSIS installer verified: $($installer.Name)"
          $size = $installer.Length / 1MB
          Write-Host "  Size: $([math]::Round($size, 1)) MB"
        shell: pwsh

      # ============================================================
      # STEP 5: Generate latest.yml for Auto-Update
      # ============================================================
      - name: Generate latest.yml for Auto-Update
        run: |
          Write-Host "=== Generating latest.yml for electron-updater ==="

          $installer = Get-ChildItem "installer_output\*Setup*.exe" | Select-Object -First 1
          if (!$installer) { Write-Error "[ERROR] No installer found"; exit 1 }

          $fileName = $installer.Name
          $fileSize = $installer.Length
          $hash = (Get-FileHash -Path $installer.FullName -Algorithm SHA512).Hash.ToLower()

          # Extract VERSION (unified format: YY.MMDD.HHMM - valid semver + datetime)
          $versionContent = Get-Content "version.py" -Raw
          if ($versionContent -match 'VERSION\s*=\s*"(\d{2}\.\d{4}\.\d{4})"') {
            $semanticVersion = $Matches[1]
            Write-Host "[OK] Extracted unified VERSION: $semanticVersion (YY.MMDD.HHMM format)"
          } else {
            $semanticVersion = "25.0101.0000"  # Fallback with unified format
            Write-Host "[WARN] Could not extract VERSION, using fallback: $semanticVersion"
          }

          $releaseDate = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ss.fffZ")

          $latestYml = "version: $semanticVersion`nfiles:`n  - url: $fileName`n    sha512: $hash`n    size: $fileSize`npath: $fileName`nsha512: $hash`nreleaseDate: '$releaseDate'"

          $latestYml | Out-File -FilePath "installer_output\latest.yml" -Encoding UTF8 -NoNewline
          Write-Host "[OK] latest.yml generated"
          Get-Content "installer_output\latest.yml"
        shell: pwsh

      # ============================================================
      # STEP 5b: Generate PATCH Update Files (Game-Launcher Style)
      # These enable ~18MB patch updates instead of 595MB full downloads
      # ============================================================
      - name: Generate PATCH Update Files
        env:
          VERSION: ${{ needs.check-build-trigger.outputs.version }}
        run: |
          Write-Host "=== Generating PATCH Update Files ===" -ForegroundColor Cyan

          $resourcesDir = "locaNext\dist-electron\win-unpacked\resources"
          $version = $env:VERSION

          # 1. Copy app.asar for PATCH updates (~18MB instead of 595MB installer)
          $asarPath = "$resourcesDir\app.asar"
          if (Test-Path $asarPath) {
            Copy-Item $asarPath "installer_output\app.asar"
            $asarSize = (Get-Item "installer_output\app.asar").Length
            $asarHash = (Get-FileHash "installer_output\app.asar" -Algorithm SHA256).Hash.ToLower()

            Write-Host "[OK] app.asar copied" -ForegroundColor Green
            Write-Host "    Size: $([math]::Round($asarSize/1MB, 2)) MB"
            Write-Host "    SHA256: $($asarHash.Substring(0,16))..."

            # 2. Generate manifest.json for PATCH updater
            $manifest = @{
              version = $version
              buildDate = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
              components = @{
                "app.asar" = @{
                  version = $version
                  sha256 = $asarHash
                  size = $asarSize
                  url = "app.asar"
                  required = $true
                }
              }
            }

            $manifestJson = $manifest | ConvertTo-Json -Depth 5
            [System.IO.File]::WriteAllText("installer_output\manifest.json", $manifestJson)
            Write-Host "[OK] manifest.json generated" -ForegroundColor Green

          } else {
            Write-Host "[WARN] app.asar not found - PATCH updates disabled" -ForegroundColor Yellow
          }

          # 3. Copy blockmap for SMART/differential updates
          $blockmap = Get-ChildItem "locaNext\dist-electron\*.blockmap" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($blockmap) {
            Copy-Item $blockmap.FullName "installer_output\"
            Write-Host "[OK] Blockmap copied: $($blockmap.Name)" -ForegroundColor Green
            Write-Host "    Enables differential updates (download only changed bytes)"
          } else {
            Write-Host "[WARN] No blockmap found" -ForegroundColor Yellow
          }

          Write-Host ""
          Write-Host "=== PATCH Update Files Ready ===" -ForegroundColor Cyan
          Get-ChildItem "installer_output" | Format-Table Name, @{N='Size';E={"{0:N2} MB" -f ($_.Length/1MB)}}
        shell: pwsh

      - name: Upload Installer Artifact
        uses: actions/upload-artifact@v4
        with:
          name: LocaNext-Windows-LIGHT-Setup
          path: |
            installer_output/*.exe
            installer_output/latest.yml
            installer_output/app.asar
            installer_output/manifest.json
            installer_output/*.blockmap
          retention-days: 7

      # ============================================================
      # POST-BUILD TEST: Install and verify app works
      # This catches issues that only appear after real installation
      # ============================================================
      - name: Test Install (Silent)
        run: |
          Write-Host "=== POST-BUILD TEST: Installing app silently ==="
          Write-Host ""

          # Find the installer
          $installer = Get-ChildItem "installer_output\*.exe" | Select-Object -First 1
          if (!$installer) {
            Write-Error "[ERROR] No installer found"
            exit 1
          }

          Write-Host "Installing: $($installer.Name)"

          # Install silently to temp location
          # NSIS silent flags: /S for silent, /D= for directory (must be last)
          $installDir = "$env:TEMP\LocaNext_Test"

          # Run NSIS installer silently
          Start-Process -FilePath $installer.FullName `
            -ArgumentList "/S", "/D=$installDir" `
            -Wait -NoNewWindow

          Write-Host "[OK] Installation completed"
          Write-Host "  Install location: $installDir"
        shell: pwsh

      - name: Verify Installation Files
        run: |
          Write-Host "=== Verifying installed files (electron-builder NSIS structure) ==="
          Write-Host ""

          $installDir = "$env:TEMP\LocaNext_Test"
          # electron-builder extraResources go to: resources/
          $resourcesDir = "$installDir\resources"

          # Check main executable
          if (!(Test-Path "$installDir\LocaNext.exe")) {
            Write-Error "[ERROR] LocaNext.exe not found"
            exit 1
          }
          Write-Host "[OK] LocaNext.exe exists"

          # Check server files (in resources/)
          if (!(Test-Path "$resourcesDir\server\main.py")) {
            Write-Error "[ERROR] server/main.py not found in resources/"
            exit 1
          }
          Write-Host "[OK] server/main.py exists"

          # Check version.py (in resources/)
          if (!(Test-Path "$resourcesDir\version.py")) {
            Write-Error "[ERROR] version.py not found in resources/"
            exit 1
          }
          Write-Host "[OK] version.py exists"

          # Check embedded Python (in resources/tools/)
          if (!(Test-Path "$resourcesDir\tools\python\python.exe")) {
            Write-Error "[ERROR] Embedded Python not found in resources/"
            exit 1
          }
          Write-Host "[OK] Embedded Python exists"

          # Check first-run setup script
          if (!(Test-Path "$resourcesDir\tools\install_deps.py")) {
            Write-Error "[ERROR] install_deps.py not found"
            exit 1
          }
          Write-Host "[OK] install_deps.py exists"

          Write-Host ""
          Write-Host "[PASS] All critical files present!"
        shell: pwsh

      - name: Test Backend Can Start (Installed App)
        run: |
          Write-Host "=== Testing backend with INSTALLED embedded Python ==="
          $installDir = "$env:TEMP\LocaNext_Test"
          $resourcesDir = "$installDir\resources"
          $pythonExe = "$resourcesDir\tools\python\python.exe"
          $env:PYTHONPATH = $resourcesDir
          Write-Host "Testing server imports with installed Python..."
          Push-Location $resourcesDir
          & $pythonExe -c "import sys; sys.path.insert(0,'.'); from version import VERSION; print(f'version OK: v{VERSION}'); import server.main; print('server.main OK')"
          $exitCode = $LASTEXITCODE
          Pop-Location
          if ($exitCode -ne 0) { Write-Error "Installed app import test FAILED!"; exit 1 }
          Write-Host "Backend import test passed!"
        shell: pwsh

      # NOTE: Server runtime tests removed - no PostgreSQL on Windows runner
      # Linux tests with real PostgreSQL already verify server functionality

      - name: Cleanup Test Installation
        if: always()
        run: |
          $installDir = "$env:TEMP\LocaNext_Test"
          if (Test-Path $installDir) {
            Remove-Item -Recurse -Force $installDir -ErrorAction SilentlyContinue
            Write-Host "[OK] Test installation cleaned up"
          }
        shell: pwsh

  # ============================================================
  # BUILD MACOS INSTALLER
  # ============================================================
  build-macos:
    name: Build macOS Installer
    runs-on: macos-latest
    needs: [check-build-trigger, safety-checks]
    if: needs.check-build-trigger.outputs.should_build == 'true' && needs.check-build-trigger.outputs.skip_build != 'yes'

    env:
      BUILD_VERSION: ${{ needs.check-build-trigger.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: locaNext/package-lock.json

      - name: Install Node Dependencies
        run: |
          cd locaNext && npm ci

      # Set GitHub Release URL for macOS auto-updates (same as Windows)
      - name: Set GitHub Release URL for Auto-Updates
        run: |
          echo "=== Setting GitHub Release URL for macOS ==="

          PKG_PATH="locaNext/package.json"

          # Replace Gitea URL with GitHub releases URL
          sed -i.bak 's|http://172.28.150.120:3000/neilvibe/LocaNext/releases/download/latest|https://github.com/NeilVibe/LocalizationTools/releases/download/latest|g' "$PKG_PATH"

          echo "[OK] Publish URL changed to GitHub releases"
          grep -o 'github.com[^"]*' "$PKG_PATH" | head -1 || echo "[WARN] Could not verify"

      - name: Update version.py
        run: |
          echo "VERSION = \"$BUILD_VERSION\"" > version.py
          echo "BUILD_NUMBER = $(echo $BUILD_VERSION | sed 's/\.//g')" >> version.py
          echo "[OK] version.py updated to: $BUILD_VERSION"
          cat version.py

      - name: Build Electron App for macOS
        run: |
          cd locaNext

          echo "=== Building for macOS ==="

          # Build the Svelte app first
          npm run build

          # Build electron for macOS (unsigned for now)
          # Config is in package.json under "build" key, not separate file
          npx electron-builder --mac --publish never

          echo "[OK] macOS build complete"
          ls -la dist-electron/

      - name: Collect macOS Installer
        run: |
          mkdir -p installer_output

          # Find the DMG file
          DMG=$(find locaNext/dist-electron -name "*.dmg" | head -1)

          if [ -z "$DMG" ]; then
            echo "[ERROR] No DMG file found!"
            ls -la locaNext/dist-electron/
            exit 1
          fi

          # Copy with versioned name
          NEW_NAME="LocaNext_v${BUILD_VERSION}_macOS.dmg"
          cp "$DMG" "installer_output/$NEW_NAME"

          echo "[OK] macOS installer ready: $NEW_NAME"
          ls -lh installer_output/

      # Generate PATCH files for macOS
      - name: Generate PATCH Update Files for macOS
        run: |
          echo "=== Generating PATCH Update Files for macOS ==="

          # macOS app.asar is inside the .app bundle
          APP_PATH=$(find locaNext/dist-electron -name "*.app" -type d | head -1)

          if [ -n "$APP_PATH" ]; then
            ASAR_PATH="$APP_PATH/Contents/Resources/app.asar"

            if [ -f "$ASAR_PATH" ]; then
              cp "$ASAR_PATH" "installer_output/app.asar"
              ASAR_SIZE=$(stat -f%z "installer_output/app.asar" 2>/dev/null || stat -c%s "installer_output/app.asar")
              ASAR_HASH=$(shasum -a 256 "installer_output/app.asar" | cut -d' ' -f1)

              echo "[OK] app.asar copied"
              echo "    Size: $((ASAR_SIZE / 1024 / 1024)) MB"
              echo "    SHA256: ${ASAR_HASH:0:16}..."

              # Generate manifest.json (using printf to avoid YAML parsing issues)
              printf '{\n  "version": "%s",\n  "buildDate": "%s",\n  "components": {\n    "app.asar": {\n      "version": "%s",\n      "sha256": "%s",\n      "size": %s,\n      "url": "app.asar",\n      "required": true\n    }\n  }\n}\n' \
                "$BUILD_VERSION" \
                "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)" \
                "$BUILD_VERSION" \
                "$ASAR_HASH" \
                "$ASAR_SIZE" > installer_output/manifest.json
              echo "[OK] manifest.json generated"
            else
              echo "[WARN] app.asar not found in .app bundle"
            fi
          else
            echo "[WARN] No .app bundle found"
          fi

          # Copy blockmap if exists
          BLOCKMAP=$(find locaNext/dist-electron -name "*.blockmap" | head -1)
          if [ -n "$BLOCKMAP" ]; then
            cp "$BLOCKMAP" installer_output/
            echo "[OK] Blockmap copied"
          fi

          echo ""
          echo "=== macOS PATCH Files ==="
          ls -lh installer_output/

      - name: Upload macOS Artifact
        uses: actions/upload-artifact@v4
        with:
          name: LocaNext-macOS-Setup
          path: |
            installer_output/*.dmg
            installer_output/app.asar
            installer_output/manifest.json
            installer_output/*.blockmap
          retention-days: 7

  # ============================================================
  # CREATE GITHUB RELEASE
  # ============================================================
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [check-build-trigger, build-windows, build-macos]
    if: success() && needs.check-build-trigger.outputs.skip_build != 'yes'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Windows Installer
        uses: actions/download-artifact@v4
        with:
          name: LocaNext-Windows-LIGHT-Setup
          path: artifacts/windows

      - name: Download macOS Installer
        uses: actions/download-artifact@v4
        with:
          name: LocaNext-macOS-Setup
          path: artifacts/macos

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.check-build-trigger.outputs.version }}
          name: LocaNext v${{ needs.check-build-trigger.outputs.version }} (LIGHT)
          draft: false
          prerelease: false
          body: |
            ## LocaNext Desktop Application (LIGHT Build)

            **Version:** ${{ needs.check-build-trigger.outputs.version }}
            **Build Type:** LIGHT (deps + model installed on first launch)

            ### 📥 Downloads

            **Windows:**
            - `LocaNext_v${{ needs.check-build-trigger.outputs.version }}_Light_Setup.exe` (~150-200MB)

            **macOS:**
            - `LocaNext_v${{ needs.check-build-trigger.outputs.version }}_macOS.dmg` (~150-200MB)

            ### ✅ Requirements

            - **Internet connection** - For first launch setup
            - **~3GB disk space** - For app + deps + model
            - **NO Python required!** - Everything is bundled

            ### 🚀 What's Included

            - ✅ **XLSTransfer** - AI-powered Excel translation
            - ✅ **QuickSearch** - Multi-game dictionary (BDO, BDM, BDC, CD)
            - ✅ **KR Similar** - Korean semantic similarity search
            - ✅ **First-Run Setup** - Automatic deps + model install with progress UI

            ### 💻 Installation

            **Windows:**
            1. Download the installer (~150MB)
            2. Run the installer (~1 min)
            3. Launch LocaNext
            4. **First-Time Setup wizard appears automatically:**
               - Installing Python dependencies (~15-20 min)
               - Downloading AI model (~5-10 min)
               - All with visible progress bars!
            5. Setup complete → App ready!

            **Subsequent launches:** Instant (no setup needed)

            ### 🔐 Default Credentials

            - Username: `admin`
            - Password: `admin123`

            **⚠️ Change these for production use!**

            ---

            🤖 Generated with [Claude Code](https://claude.com/claude-code)
          files: |
            artifacts/windows/*.exe
            artifacts/windows/latest.yml
            artifacts/windows/app.asar
            artifacts/windows/manifest.json
            artifacts/windows/*.blockmap
            artifacts/macos/*.dmg
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ============================================================
      # CLEANUP: Keep only last 10 releases to save space
      # ============================================================
      - name: Cleanup Old Releases
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "=============================================="
          echo "  CLEANING UP OLD RELEASES"
          echo "=============================================="

          MAX_RELEASES=10

          # Get all releases sorted by date (newest first)
          RELEASES=$(gh release list --limit 100 --json tagName,createdAt --jq 'sort_by(.createdAt) | reverse | .[].tagName')
          RELEASE_COUNT=$(echo "$RELEASES" | wc -l)

          echo "Found $RELEASE_COUNT releases (keeping last $MAX_RELEASES)"

          if [ "$RELEASE_COUNT" -le "$MAX_RELEASES" ]; then
            echo "[OK] No cleanup needed ($RELEASE_COUNT <= $MAX_RELEASES)"
            exit 0
          fi

          # Get releases to delete (skip first MAX_RELEASES)
          TO_DELETE=$(echo "$RELEASES" | tail -n +$((MAX_RELEASES + 1)))

          echo "Deleting $((RELEASE_COUNT - MAX_RELEASES)) old releases..."

          for TAG in $TO_DELETE; do
            echo "  Deleting: $TAG"
            # Delete release (this also deletes the tag)
            gh release delete "$TAG" --yes --cleanup-tag 2>/dev/null || true
          done

          echo ""
          echo "[OK] Cleanup complete. Kept last $MAX_RELEASES releases."
