# QA Compiler Suite - Build Workflow
# ============================================================================
# COMPREHENSIVE CI VALIDATION (Modeled after LocaNext's battle-tested CI)
#
# This workflow:
# 1. Runs on changes to QACompilerNEW folder OR manual trigger OR QACOMPILER_BUILD.txt
# 2. VALIDATES CODE THOROUGHLY:
#    - Python syntax validation (py_compile)
#    - Module import validation (catches missing imports like 'sys')
#    - Flake8 code quality (undefined names, unused imports, errors)
#    - Security audit (pip-audit for vulnerable dependencies)
#    - Unit/smoke tests (pytest)
# 3. Builds standalone Windows executable with PyInstaller
# 4. Creates Inno Setup installer with drive selection
# 5. Uploads to GitHub Releases
#
# FAIL FAST: Validation errors stop the build BEFORE PyInstaller runs
# ============================================================================

name: QA Compiler Build

on:
  push:
    branches: [main]
    paths:
      - 'QACOMPILER_BUILD.txt'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 2.0.1)'
        required: false
        default: ''

permissions:
  contents: write

env:
  QACOMPILER_PATH: RessourcesForCodingTheProject/NewScripts/QACompilerNEW

jobs:
  # ============================================================
  # JOB 1: VALIDATION (Runs on Ubuntu - faster, catches errors early)
  # ============================================================
  validation:
    name: Code Validation
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check build trigger
        id: check
        run: |
          should_build=false

          # Check if QACOMPILER_BUILD.txt was modified
          diff_output=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
          if echo "$diff_output" | grep -q "QACOMPILER_BUILD.txt"; then
            trigger=$(grep -E "^Build" QACOMPILER_BUILD.txt | tail -1 || echo "")
            if [ -n "$trigger" ]; then
              should_build=true
              echo "Trigger: $trigger"
            fi
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            should_build=true
            echo "Manual trigger via workflow_dispatch"
          elif echo "$diff_output" | grep -q "QACompilerNEW"; then
            should_build=true
            echo "QACompilerNEW files changed"
          fi

          if [ "$should_build" = "false" ]; then
            echo "No QACompiler changes detected - skipping build"
            echo "should_build=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "should_build=true" >> $GITHUB_OUTPUT

          # AUTO-GENERATE VERSION: YY.MMDD.HHMM format (Korean time)
          version=$(TZ='Asia/Seoul' date '+%y.%-m%d.%H%M')
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "[OK] Auto-generated version: $version (YY.MMDD.HHMM format)"

    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      version: ${{ steps.check.outputs.version }}

  # ============================================================
  # JOB 2: SAFETY CHECKS (Syntax, Imports, Code Quality, Security)
  # ============================================================
  safety-checks:
    name: Safety Checks (Syntax, Imports, Flake8, Security)
    runs-on: ubuntu-latest
    needs: validation
    if: needs.validation.outputs.should_build == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python 3.10
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install dependencies + validation tools
        run: |
          cd ${{ env.QACOMPILER_PATH }}
          python -m pip install --upgrade pip
          pip install -r requirements.txt

          # Install validation tools
          pip install flake8 pip-audit pytest

          echo "[OK] All dependencies installed"

      # ============================================================
      # CHECK 1: Python Syntax Validation
      # ============================================================
      - name: Check 1 - Python Syntax Validation
        run: |
          echo "╔════════════════════════════════════════════════════════════╗"
          echo "║  CHECK 1: PYTHON SYNTAX VALIDATION                         ║"
          echo "╚════════════════════════════════════════════════════════════╝"
          cd ${{ env.QACOMPILER_PATH }}

          python << 'EOF'
          import sys
          import py_compile
          from pathlib import Path

          errors = []
          checked = 0

          for py_file in Path('.').rglob('*.py'):
              # Skip test files, __pycache__, build/dist
              if '__pycache__' in str(py_file):
                  continue
              if 'build' in str(py_file) or 'dist' in str(py_file):
                  continue

              try:
                  py_compile.compile(str(py_file), doraise=True)
                  checked += 1
              except py_compile.PyCompileError as e:
                  errors.append((py_file, str(e)))
                  print(f"  [FAIL] {py_file}")
                  print(f"         {e}")

          if errors:
              print(f"\n[ERROR] {len(errors)} syntax errors found!")
              sys.exit(1)
          else:
              print(f"\n[OK] All {checked} Python files have valid syntax")
          EOF

      # ============================================================
      # CHECK 2: Module Import Validation
      # This catches bugs like missing 'import sys' that broke builds!
      # ============================================================
      - name: Check 2 - Module Import Validation
        run: |
          echo "╔════════════════════════════════════════════════════════════╗"
          echo "║  CHECK 2: MODULE IMPORT VALIDATION                         ║"
          echo "║  (Catches missing imports like 'import sys' bug)           ║"
          echo "╚════════════════════════════════════════════════════════════╝"
          cd ${{ env.QACOMPILER_PATH }}

          python << 'EOF'
          import sys
          import importlib
          sys.path.insert(0, '.')

          modules = [
              # Main entry
              'config',
              'main',

              # GUI
              'gui.app',

              # Generators (these had the missing 'sys' import bug)
              'generators',
              'generators.base',
              'generators.quest',
              'generators.item',
              'generators.skill',
              'generators.character',
              'generators.region',
              'generators.knowledge',
              'generators.help',
              'generators.gimmick',

              # Core
              'core.compiler',
              'core.discovery',
              'core.excel_ops',
              'core.matching',
              'core.populate_new',
              'core.processing',
              'core.transfer',
              'core.tracker_update',

              # Tracker
              'tracker.coverage',
              'tracker.daily',
              'tracker.total',
              'tracker.data',

              # Standalone tools
              'system_localizer',
              'drive_replacer',
              'eventname_to_stringid',
          ]

          errors = []
          for mod in modules:
              try:
                  importlib.import_module(mod)
                  print(f'  [PASS] {mod}')
              except Exception as e:
                  error_type = type(e).__name__
                  print(f'  [FAIL] {mod}')
                  print(f'         {error_type}: {e}')
                  errors.append((mod, e))

          if errors:
              print(f'\n[ERROR] {len(errors)} modules failed to import!')
              print('\nDetailed errors:')
              for mod, e in errors:
                  print(f'  - {mod}: {type(e).__name__}: {e}')
              print('\nFix these errors before building!')
              sys.exit(1)
          else:
              print(f'\n[OK] All {len(modules)} modules imported successfully!')
          EOF

      # ============================================================
      # CHECK 3: Flake8 Code Quality (Critical Errors Only)
      # Catches: undefined names, unused imports, syntax errors
      # ============================================================
      - name: Check 3 - Flake8 Code Quality
        run: |
          echo "╔════════════════════════════════════════════════════════════╗"
          echo "║  CHECK 3: FLAKE8 CODE QUALITY                              ║"
          echo "║  (Catches undefined names, unused imports, errors)         ║"
          echo "╚════════════════════════════════════════════════════════════╝"
          cd ${{ env.QACOMPILER_PATH }}

          # Run flake8 with focus on critical errors:
          # E9xx: Runtime errors (syntax, IO, etc)
          # F6xx: Statement errors
          # F7xx: Statement errors
          # F8xx: Name errors (undefined names - CRITICAL!)
          # F4xx: Import errors (unused imports - warning only)
          #
          # We FAIL on E9, F63, F7, F82 (undefined names)
          # We WARN on F401 (unused imports) but don't fail

          echo "=== Critical Errors (will fail build) ==="
          flake8 . --select=E9,F63,F7,F82 --show-source --statistics \
            --exclude=__pycache__,build,dist,.git \
            && echo "[OK] No critical flake8 errors" \
            || { echo "[FATAL] Critical flake8 errors found!"; exit 1; }

          echo ""
          echo "=== Warnings (logged but won't fail) ==="
          flake8 . --select=F401 --show-source --statistics \
            --exclude=__pycache__,build,dist,.git \
            || echo "[WARN] Unused imports found (non-blocking)"

          echo ""
          echo "[OK] Flake8 check complete"

      # ============================================================
      # CHECK 4: Security Audit (Vulnerable Dependencies)
      # ============================================================
      - name: Check 4 - Security Audit
        run: |
          echo "╔════════════════════════════════════════════════════════════╗"
          echo "║  CHECK 4: SECURITY AUDIT (pip-audit)                       ║"
          echo "╚════════════════════════════════════════════════════════════╝"
          cd ${{ env.QACOMPILER_PATH }}

          pip-audit --desc || echo "[WARN] Vulnerabilities found - logged for review"
          echo "[OK] Security audit complete"
        continue-on-error: true  # Don't fail build on vulnerabilities, just warn

      # ============================================================
      # CHECK 5: Run Tests (pytest)
      # ============================================================
      - name: Check 5 - Run Tests
        run: |
          echo "╔════════════════════════════════════════════════════════════╗"
          echo "║  CHECK 5: PYTEST TESTS                                     ║"
          echo "╚════════════════════════════════════════════════════════════╝"
          cd ${{ env.QACOMPILER_PATH }}

          # Run any test files that exist
          # Use --ignore for Windows-specific tests that won't run on Linux
          if ls test_*.py 1> /dev/null 2>&1; then
            # Some tests require Windows paths (F: drive) - run with continue-on-error
            python -m pytest test_*.py -v --tb=short -x 2>&1 || {
              echo "[WARN] Some tests failed (may require Windows environment)"
              echo "       Continuing with build..."
            }
          else
            echo "[INFO] No test files found - skipping pytest"
          fi

          echo "[OK] Test check complete"
        continue-on-error: true  # Some tests may require Windows

      - name: Safety Checks Summary
        run: |
          echo "============================================"
          echo "[PASS] ALL SAFETY CHECKS PASSED"
          echo "============================================"
          echo ""
          echo "Validated:"
          echo "  1. Python syntax - OK"
          echo "  2. Module imports - OK"
          echo "  3. Flake8 critical errors - OK"
          echo "  4. Security audit - Complete"
          echo "  5. Tests - Complete"
          echo ""
          echo "Ready for Windows build!"

  # ============================================================
  # JOB 3: BUILD WINDOWS (Only runs after validation passes)
  # ============================================================
  build-and-release:
    name: Build & Release QA Compiler
    runs-on: windows-latest
    needs: [validation, safety-checks]
    if: needs.validation.outputs.should_build == 'true'

    env:
      BUILD_VERSION: ${{ needs.validation.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need history for diff

      - name: Setup Python 3.10
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install dependencies
        shell: pwsh
        run: |
          cd ${{ env.QACOMPILER_PATH }}
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      # ============================================================
      # FINAL VALIDATION ON WINDOWS (ensures Windows-specific imports work)
      # ============================================================
      - name: Windows Import Validation
        shell: pwsh
        run: |
          cd ${{ env.QACOMPILER_PATH }}
          Write-Host "=== WINDOWS IMPORT VALIDATION ==="
          Write-Host "Final check before PyInstaller..."

          python -c @"
          import sys
          import importlib
          sys.path.insert(0, '.')

          modules = [
              'config',
              'main',
              'gui.app',
              'generators',
              'generators.base',
              'generators.quest',
              'generators.item',
              'generators.skill',
              'generators.character',
              'generators.region',
              'generators.knowledge',
              'generators.help',
              'generators.gimmick',
              'core.compiler',
              'core.discovery',
              'tracker.coverage',
              'system_localizer',
              'eventname_to_stringid',
          ]

          errors = []
          for mod in modules:
              try:
                  importlib.import_module(mod)
                  print(f'  [PASS] {mod}')
              except Exception as e:
                  print(f'  [FAIL] {mod}: {e}')
                  errors.append(mod)

          if errors:
              print(f'\n[ERROR] {len(errors)} modules failed to import!')
              print('Fix these errors before building.')
              sys.exit(1)
          else:
              print(f'\n[OK] All {len(modules)} modules imported successfully!')
          "@

          if ($LASTEXITCODE -ne 0) {
            Write-Host "[FATAL] Windows validation failed - aborting build"
            exit 1
          }
          Write-Host "[OK] Windows validation passed"

      - name: Inject Version
        shell: pwsh
        run: |
          $version = "${{ env.BUILD_VERSION }}"
          $qaPath = "${{ env.QACOMPILER_PATH }}"

          Write-Host "=== VERSION INJECTION ==="
          Write-Host "Version: $version"

          # Update installer script version
          $issPath = "$qaPath\installer\QACompiler.iss"
          if (Test-Path $issPath) {
            (Get-Content $issPath) -replace '#define MyAppVersion "[^"]*"', "#define MyAppVersion `"$version`"" | Set-Content $issPath
            Write-Host "[OK] Updated: $issPath"
          }

          # Update config.py with version
          $configPath = "$qaPath\config.py"
          if (Test-Path $configPath) {
            $content = Get-Content $configPath -Raw
            if ($content -match 'VERSION\s*=') {
              $content = $content -replace 'VERSION\s*=\s*"[^"]*"', "VERSION = `"$version`""
            } else {
              $content = "VERSION = `"$version`"`n" + $content
            }
            Set-Content $configPath $content
            Write-Host "[OK] Updated: $configPath"
          }

      - name: Build executable with PyInstaller
        shell: pwsh
        run: |
          cd ${{ env.QACOMPILER_PATH }}
          pyinstaller QACompiler.spec --clean --noconfirm

      - name: Verify build
        shell: pwsh
        run: |
          # Verify main QACompiler executable
          $exePath = "${{ env.QACOMPILER_PATH }}\dist\QACompiler\QACompiler.exe"
          if (!(Test-Path $exePath)) {
            Write-Error "Build failed - QACompiler.exe not found"
            exit 1
          }
          $size = (Get-Item $exePath).length / 1MB
          Write-Host "QACompiler.exe: $([math]::Round($size, 1)) MB"

          # Verify eventname_to_stringid executable
          $exePath2 = "${{ env.QACOMPILER_PATH }}\dist\eventname_to_stringid\eventname_to_stringid.exe"
          if (!(Test-Path $exePath2)) {
            Write-Error "Build failed - eventname_to_stringid.exe not found"
            exit 1
          }
          $size2 = (Get-Item $exePath2).length / 1MB
          Write-Host "eventname_to_stringid.exe: $([math]::Round($size2, 1)) MB"

          Write-Host "Both builds successful!"

      - name: Create working folders
        shell: pwsh
        run: |
          $distPath = "${{ env.QACOMPILER_PATH }}\dist\QACompiler"

          $folders = @(
            "QAfolder", "QAfolderOLD", "QAfolderNEW", "GeneratedDatasheets",
            "Masterfolder_EN", "Masterfolder_EN\Images",
            "Masterfolder_CN", "Masterfolder_CN\Images",
            "TrackerUpdateFolder",
            "TrackerUpdateFolder\QAfolder",
            "TrackerUpdateFolder\Masterfolder_EN",
            "TrackerUpdateFolder\Masterfolder_CN"
          )

          foreach ($folder in $folders) {
            $path = "$distPath\$folder"
            New-Item -ItemType Directory -Path $path -Force | Out-Null
            # Add .gitkeep for empty folder preservation
            New-Item -ItemType File -Path "$path\.gitkeep" -Force | Out-Null
          }

          # Copy config files
          Copy-Item "${{ env.QACOMPILER_PATH }}\languageTOtester_list.example.txt" "$distPath\" -ErrorAction SilentlyContinue
          Copy-Item "${{ env.QACOMPILER_PATH }}\TesterType.example.txt" "$distPath\" -ErrorAction SilentlyContinue

          Write-Host "Working folders created"

      - name: Install Inno Setup
        shell: pwsh
        run: choco install innosetup -y

      - name: Compile installer
        shell: pwsh
        run: |
          $issPath = "${{ env.QACOMPILER_PATH }}\installer\QACompiler.iss"
          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" $issPath

      - name: Create portable ZIP
        shell: pwsh
        run: |
          $version = "${{ env.BUILD_VERSION }}"
          $distPath = "${{ env.QACOMPILER_PATH }}\dist\QACompiler"
          $zipPath = "${{ env.QACOMPILER_PATH }}\installer_output\QACompiler_v${version}_Portable.zip"

          Compress-Archive -Path "$distPath\*" -DestinationPath $zipPath -Force
          $size = (Get-Item $zipPath).Length / 1MB
          Write-Host "Portable ZIP: $([math]::Round($size, 1)) MB"

      - name: Create source code ZIP
        shell: pwsh
        run: |
          $version = "${{ env.BUILD_VERSION }}"
          $sourcePath = "${{ env.QACOMPILER_PATH }}"
          $zipPath = "${{ env.QACOMPILER_PATH }}\installer_output\QACompiler_v${version}_Source.zip"

          $tempDir = New-Item -ItemType Directory -Path "$env:TEMP\QACompiler_Source" -Force
          $excludes = @("dist", "build", "__pycache__", "*.pyc", "installer_output", ".pytest_cache")

          Get-ChildItem -Path $sourcePath -Exclude $excludes | Copy-Item -Destination $tempDir -Recurse -Force
          Get-ChildItem -Path $tempDir -Recurse -Directory -Filter "__pycache__" | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue

          # Create working folders in source bundle (with .gitkeep)
          $sourceFolders = @(
            "QAfolder", "QAfolderOLD", "QAfolderNEW", "GeneratedDatasheets",
            "Masterfolder_EN", "Masterfolder_EN\Images",
            "Masterfolder_CN", "Masterfolder_CN\Images",
            "TrackerUpdateFolder",
            "TrackerUpdateFolder\QAfolder",
            "TrackerUpdateFolder\Masterfolder_EN",
            "TrackerUpdateFolder\Masterfolder_CN"
          )
          foreach ($folder in $sourceFolders) {
            $path = "$tempDir\$folder"
            New-Item -ItemType Directory -Path $path -Force | Out-Null
            New-Item -ItemType File -Path "$path\.gitkeep" -Force | Out-Null
          }

          Compress-Archive -Path "$tempDir\*" -DestinationPath $zipPath -Force
          Remove-Item -Path $tempDir -Recurse -Force

          $size = (Get-Item $zipPath).Length / 1MB
          Write-Host "Source ZIP: $([math]::Round($size, 1)) MB"

      - name: Upload Setup
        uses: actions/upload-artifact@v4
        with:
          name: QACompiler-Setup
          path: ${{ env.QACOMPILER_PATH }}/installer_output/*.exe
          retention-days: 30

      - name: Upload Portable
        uses: actions/upload-artifact@v4
        with:
          name: QACompiler-Portable
          path: ${{ env.QACOMPILER_PATH }}/installer_output/*_Portable.zip
          retention-days: 30

      - name: Upload Source
        uses: actions/upload-artifact@v4
        with:
          name: QACompiler-Source
          path: ${{ env.QACOMPILER_PATH }}/installer_output/*_Source.zip
          retention-days: 30

      - name: Create GitHub Release
        if: github.ref == 'refs/heads/main'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: qacompiler-v${{ env.BUILD_VERSION }}
          name: QA Compiler Suite v${{ env.BUILD_VERSION }}
          body: |
            # QA Compiler Suite v${{ env.BUILD_VERSION }}

            ## Download

            - **QACompiler_v${{ env.BUILD_VERSION }}_Setup.exe** - Installer (recommended)
            - **QACompiler_v${{ env.BUILD_VERSION }}_Portable.zip** - Portable ZIP (no install)
            - **QACompiler_v${{ env.BUILD_VERSION }}_Source.zip** - Source code

            ## CI Validation Passed

            This build was validated with:
            - Python syntax check
            - Module import validation (catches missing imports)
            - Flake8 code quality (undefined names, errors)
            - Security audit (pip-audit)

            ## Features

            - Generate datasheets for all categories
            - Transfer QA files with automatic merging
            - Build master files with issue tracking
            - Coverage analysis and word count reports
            - Portable installation (Desktop by default)
            - Drive selection for Perforce path

            ---
            *Portable installation - no admin rights required*
          draft: false
          prerelease: false
          files: |
            ${{ env.QACOMPILER_PATH }}/installer_output/*.exe
            ${{ env.QACOMPILER_PATH }}/installer_output/*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        run: |
          echo "=== QA Compiler Build Complete ==="
          echo "Version: ${{ env.BUILD_VERSION }}"
          echo "Release: qacompiler-v${{ env.BUILD_VERSION }}"
