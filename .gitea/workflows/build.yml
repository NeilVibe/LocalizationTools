# ============================================================================
# LocaNext Build Pipeline - Gitea Actions
# MIRRORS GITHUB WORKFLOW EXACTLY (832 lines → Gitea compatible)
# ============================================================================
# This workflow is 100% identical to .github/workflows/build-electron.yml
# with only these Gitea-specific adaptations:
#   - windows-latest → self-hosted (Windows runner required)
#   - softprops/action-gh-release → Gitea REST API
#   - gh release list → Gitea API
#   - GITHUB_TOKEN → RELEASE_TOKEN (GITEA_ prefix is reserved)
# ============================================================================

name: Build LocaNext LIGHT Installer

on:
  push:
    branches: [ main ]
    paths:
      - 'GITEA_TRIGGER.txt'
  workflow_dispatch:

env:
  GITEA_URL: http://localhost:3000
  GITEA_REPO: neilvibe/LocaNext

jobs:
  # ============================================================
  # GITEA SIMPLIFIED: Single Windows Build Job
  # Safety checks run on GitHub - Gitea is for quick local testing
  # ============================================================
  build-windows:
    name: Build Windows LIGHT Installer
    runs-on: [self-hosted, windows, x64]  # GITEA: Use self-hosted Windows runner
    # NOTE: Removed `needs:` to fix act_runner job status bug
    # Build trigger is checked directly in the first step

    steps:
      # Configure UTF-8 to handle Korean characters in output
      - name: Configure UTF-8 Console Encoding
        run: |
          chcp 65001
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
          [Console]::InputEncoding = [System.Text.Encoding]::UTF8
          $PSDefaultParameterValues['*:Encoding'] = 'utf8'
          Write-Host "[OK] Console encoding set to UTF-8"
        shell: powershell

      # Check build trigger and extract version from version.py
      - name: Get Version from Source
        id: check
        run: |
          Write-Host "=== Getting Version from Source ==="
          # Use curl to get version.py content
          # For Gitea builds, use Gitea version.py (not GitHub) to get correct version
          $versionUrl = "http://172.28.150.120:3000/neilvibe/LocaNext/raw/branch/main/version.py"
          $content = (Invoke-WebRequest -Uri $versionUrl -UseBasicParsing).Content

          # Extract VERSION using regex
          if ($content -match 'VERSION\s*=\s*"(\d+)"') {
            $version = $Matches[1]
            Write-Host "Detected version: $version"
            # Use deprecated but working syntax for act_runner
            Write-Output "::set-output name=version::$version"
          } else {
            Write-Host "[ERROR] Could not extract version from version.py"
            exit 1
          }
        shell: powershell

      # Standard checkout - ephemeral runner handles cleanup elegantly
      - name: Checkout code
        uses: actions/checkout@v4

      # NOTE: We don't use actions/setup-python@v5 because it fails when runner
      # runs as SYSTEM service (can't write to systemprofile cache).
      # Instead, we use the pre-installed Python on the Windows build machine.
      - name: Verify Python Installation
        run: |
          Write-Host "=== Verifying Python Installation ===" -ForegroundColor Cyan

          # Check common Python locations
          $pythonPaths = @(
            "C:\Python313\python.exe",
            "C:\Python311\python.exe",
            "C:\Python310\python.exe",
            "C:\Python39\python.exe"
          )

          $pythonExe = $null
          foreach ($path in $pythonPaths) {
            if (Test-Path $path) {
              $pythonExe = $path
              Write-Host "[OK] Found Python at: $path" -ForegroundColor Green
              break
            }
          }

          if (-not $pythonExe) {
            # Try PATH
            $pythonExe = (Get-Command python -ErrorAction SilentlyContinue).Source
            if ($pythonExe) {
              Write-Host "[OK] Found Python in PATH: $pythonExe" -ForegroundColor Green
            } else {
              Write-Error "[ERROR] Python not found! Install Python 3.9+ to C:\PythonXX"
              exit 1
            }
          }

          # Get Python directory and add to PATH
          $pythonDir = Split-Path $pythonExe -Parent
          $scriptsDir = Join-Path $pythonDir "Scripts"

          # Add to PATH for this session
          $env:PATH = "$pythonDir;$scriptsDir;$env:PATH"
          Write-Host "Added to PATH: $pythonDir, $scriptsDir"

          # Verify
          & $pythonExe --version

          # Create aliases for python and pip
          Set-Alias -Name python -Value $pythonExe -Scope Global
          Write-Host "[OK] Python ready for build" -ForegroundColor Green
        shell: powershell

      # NOTE: We don't use actions/setup-node@v4 because 7zr.exe extraction fails
      # when runner runs as SYSTEM service. Instead, use pre-installed Node.js.
      - name: Verify Node.js Installation
        run: |
          Write-Host "=== Verifying Node.js Installation ===" -ForegroundColor Cyan

          # Check common Node.js locations
          $nodePaths = @(
            "C:\Program Files\nodejs\node.exe",
            "C:\nodejs\node.exe"
          )

          $nodeExe = $null
          foreach ($path in $nodePaths) {
            if (Test-Path $path) {
              $nodeExe = $path
              Write-Host "[OK] Found Node.js at: $path" -ForegroundColor Green
              break
            }
          }

          if (-not $nodeExe) {
            # Try PATH
            $nodeExe = (Get-Command node -ErrorAction SilentlyContinue).Source
            if ($nodeExe) {
              Write-Host "[OK] Found Node.js in PATH: $nodeExe" -ForegroundColor Green
            } else {
              Write-Error "[ERROR] Node.js not found! Install Node.js 18+ to C:\Program Files\nodejs"
              exit 1
            }
          }

          # Get Node directory and add to PATH
          $nodeDir = Split-Path $nodeExe -Parent
          $env:PATH = "$nodeDir;$env:PATH"
          Write-Host "Added to PATH: $nodeDir"

          # Verify versions
          & node --version
          & npm --version

          Write-Host "[OK] Node.js ready for build" -ForegroundColor Green
        shell: powershell

      # ============================================================
      # CACHE CHECK: Verify cache availability
      # ============================================================
      - name: Check Build Cache
        id: cache
        run: |
          Write-Host "=== Checking Build Cache ===" -ForegroundColor Cyan
          $cacheRoot = "C:\BuildCache"
          $manifest = "$cacheRoot\CACHE_MANIFEST.json"

          # Initialize cache status
          $vcredistCached = $false
          $pythonCached = $false
          $npmCached = $false
          $nsisCached = $false

          if (Test-Path $manifest) {
            Write-Host "[OK] Cache manifest found" -ForegroundColor Green
            $cache = Get-Content $manifest | ConvertFrom-Json

            # Check VC++ Redistributable
            $vcredistPath = "$cacheRoot\vcredist\vc_redist.x64.exe"
            if (Test-Path $vcredistPath) {
              $vcredistCached = $true
              Write-Host "[CACHE HIT] VC++ Redistributable" -ForegroundColor Green
            }

            # Check Python Embedded
            $pythonPath = "$cacheRoot\python-embedded\python-3.11.9\python.exe"
            if (Test-Path $pythonPath) {
              $pythonCached = $true
              Write-Host "[CACHE HIT] Python Embedded" -ForegroundColor Green
            }

            # Check npm cache (hash-based)
            if (Test-Path "locaNext\package-lock.json") {
              $lockHash = (Get-FileHash "locaNext\package-lock.json" -Algorithm SHA256).Hash.Substring(0,12)
              $npmCachePath = "$cacheRoot\npm-cache\$lockHash"
              if (Test-Path $npmCachePath) {
                $npmCached = $true
                Write-Host "[CACHE HIT] npm packages (hash: $lockHash)" -ForegroundColor Green
              } else {
                Write-Host "[CACHE MISS] npm packages (hash: $lockHash)" -ForegroundColor Yellow
              }
              echo "npm_hash=$lockHash" >> $env:GITHUB_OUTPUT
            }

            # Check NSIS includes
            $nsisPath = "$cacheRoot\nsis-includes\StdUtils.nsh"
            if (Test-Path $nsisPath) {
              $nsisCached = $true
              Write-Host "[CACHE HIT] NSIS includes" -ForegroundColor Green
            }
          } else {
            Write-Host "[WARN] No cache manifest - run setup_build_cache.ps1 first!" -ForegroundColor Yellow
          }

          # Output cache status
          echo "vcredist_cached=$vcredistCached" >> $env:GITHUB_OUTPUT
          echo "python_cached=$pythonCached" >> $env:GITHUB_OUTPUT
          echo "npm_cached=$npmCached" >> $env:GITHUB_OUTPUT
          echo "nsis_cached=$nsisCached" >> $env:GITHUB_OUTPUT

          Write-Host ""
          Write-Host "Cache Summary:" -ForegroundColor Cyan
          Write-Host "  VC++ Redistributable: $(if($vcredistCached){'CACHED'}else{'MISS'})"
          Write-Host "  Python Embedded:      $(if($pythonCached){'CACHED'}else{'MISS'})"
          Write-Host "  npm packages:         $(if($npmCached){'CACHED'}else{'MISS'})"
          Write-Host "  NSIS includes:        $(if($nsisCached){'CACHED'}else{'MISS'})"
        shell: powershell

      # ============================================================
      # STEP 1: VC++ Redistributable (Cache-First)
      # ============================================================
      - name: Get VC++ Redistributable
        run: |
          $cacheRoot = "C:\BuildCache"
          $cachedPath = "$cacheRoot\vcredist\vc_redist.x64.exe"
          $targetDir = "installer\redist"
          $targetPath = "$targetDir\vc_redist.x64.exe"

          New-Item -ItemType Directory -Force -Path $targetDir | Out-Null

          if (Test-Path $cachedPath) {
            Write-Host "[CACHE] Copying VC++ Redistributable from cache..." -ForegroundColor Green
            Copy-Item $cachedPath -Destination $targetPath -Force
            $size = [math]::Round((Get-Item $targetPath).Length / 1MB, 1)
            Write-Host "[OK] VC++ Redistributable ready ($size MB) - FROM CACHE" -ForegroundColor Green
          } else {
            Write-Host "[DOWNLOAD] Downloading VC++ Redistributable..." -ForegroundColor Yellow
            Invoke-WebRequest -Uri "https://aka.ms/vs/17/release/vc_redist.x64.exe" -OutFile $targetPath
            $size = [math]::Round((Get-Item $targetPath).Length / 1MB, 1)
            Write-Host "[OK] Downloaded VC++ Redistributable ($size MB)" -ForegroundColor Green

            # Update cache
            New-Item -ItemType Directory -Force -Path "$cacheRoot\vcredist" | Out-Null
            Copy-Item $targetPath -Destination $cachedPath -Force
            Write-Host "[CACHE] Updated cache with VC++ Redistributable" -ForegroundColor Cyan
          }
        shell: powershell

      # ============================================================
      # STEP 2: Python Embedded (Cache-First)
      # ============================================================
      - name: Get Python Embedded
        run: |
          $cacheRoot = "C:\BuildCache"
          $cachedPythonDir = "$cacheRoot\python-embedded\python-3.11.9"
          $targetDir = "tools\python"

          if (Test-Path "$cachedPythonDir\python.exe") {
            Write-Host "[CACHE] Copying Python Embedded from cache..." -ForegroundColor Green
            New-Item -ItemType Directory -Force -Path $targetDir | Out-Null
            Copy-Item -Path "$cachedPythonDir\*" -Destination $targetDir -Recurse -Force
            $totalSize = [math]::Round((Get-ChildItem $targetDir -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB, 1)
            Write-Host "[OK] Python Embedded ready ($totalSize MB) - FROM CACHE" -ForegroundColor Green
          } else {
            Write-Host "[DOWNLOAD] Downloading Python Embedded (no cache)..." -ForegroundColor Yellow
            New-Item -ItemType Directory -Force -Path $targetDir | Out-Null

            $pythonUrl = "https://www.python.org/ftp/python/3.11.9/python-3.11.9-embed-amd64.zip"
            $zipPath = "tools\python-embedded.zip"

            Invoke-WebRequest -Uri $pythonUrl -OutFile $zipPath
            Expand-Archive -Path $zipPath -DestinationPath $targetDir -Force
            Remove-Item $zipPath

            # Enable pip in embedded Python
            $pthFile = Get-ChildItem "$targetDir\python*._pth" | Select-Object -First 1
            if ($pthFile) {
              $content = Get-Content $pthFile.FullName
              $content = $content -replace '#import site', 'import site'
              Set-Content -Path $pthFile.FullName -Value $content
            }

            # Install pip
            Write-Host "Installing pip in embedded Python..."
            Invoke-WebRequest -Uri "https://bootstrap.pypa.io/get-pip.py" -OutFile "$targetDir\get-pip.py"
            & "$targetDir\python.exe" "$targetDir\get-pip.py" --no-warn-script-location
            Remove-Item "$targetDir\get-pip.py"

            # Install dependencies
            Write-Host "Installing huggingface_hub..."
            & "$targetDir\python.exe" -m pip install --no-warn-script-location huggingface_hub

            Write-Host "Installing light backend dependencies..."
            & "$targetDir\python.exe" -m pip install --no-warn-script-location `
              fastapi uvicorn python-multipart python-socketio `
              sqlalchemy aiosqlite `
              PyJWT python-jose passlib python-dotenv bcrypt `
              pydantic pydantic-settings email-validator `
              pandas openpyxl xlrd `
              httpx requests loguru tqdm pyyaml

            $totalSize = [math]::Round((Get-ChildItem $targetDir -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB, 1)
            Write-Host "[OK] Python Embedded ready ($totalSize MB)" -ForegroundColor Green

            # Update cache for next time
            Write-Host "[CACHE] Updating cache with Python Embedded..." -ForegroundColor Cyan
            New-Item -ItemType Directory -Force -Path $cachedPythonDir | Out-Null
            Copy-Item -Path "$targetDir\*" -Destination $cachedPythonDir -Recurse -Force
            Write-Host "[CACHE] Cache updated" -ForegroundColor Cyan
          }
        shell: powershell

      - name: Verify Python Embedded + ALL Dependencies
        run: |
          Write-Host "Verifying embedded Python setup..."
          & "tools\python\python.exe" --version

          Write-Host "=== Checking ALL critical packages ==="
          & "tools\python\python.exe" -c "import fastapi; print(f'[OK] fastapi v{fastapi.__version__}')"
          & "tools\python\python.exe" -c "import uvicorn; print('[OK] uvicorn ready')"
          & "tools\python\python.exe" -c "import socketio; print('[OK] socketio ready')"
          & "tools\python\python.exe" -c "import sqlalchemy; print(f'[OK] sqlalchemy v{sqlalchemy.__version__}')"
          & "tools\python\python.exe" -c "import aiosqlite; print('[OK] aiosqlite ready')"
          & "tools\python\python.exe" -c "import jwt; print(f'[OK] jwt v{jwt.__version__}')"
          & "tools\python\python.exe" -c "from jose import jwt as jose_jwt; print('[OK] jose.jwt ready')"
          & "tools\python\python.exe" -c "import passlib; print('[OK] passlib ready')"
          & "tools\python\python.exe" -c "import bcrypt; print('[OK] bcrypt ready')"
          & "tools\python\python.exe" -c "import pydantic; print(f'[OK] pydantic v{pydantic.__version__}')"
          & "tools\python\python.exe" -c "import pandas; print(f'[OK] pandas v{pandas.__version__}')"
          & "tools\python\python.exe" -c "import openpyxl; print('[OK] openpyxl ready')"
          & "tools\python\python.exe" -c "import huggingface_hub; print(f'[OK] huggingface_hub v{huggingface_hub.__version__}')"

          # Check required files
          if (!(Test-Path "version.py")) { Write-Error "[ERROR] version.py not found"; exit 1 }
          if (!(Test-Path "server\main.py")) { Write-Error "[ERROR] server/main.py not found"; exit 1 }
          Write-Host "[PASS] All dependencies verified!"
        shell: powershell

      - name: Test Server Launch with Embedded Python
        run: |
          Write-Host "=== Testing server can START with embedded Python ==="
          $env:PYTHONPATH = Get-Location
          & "tools\python\python.exe" -c "import sys; sys.path.insert(0,'.'); from version import VERSION; print(f'version OK: v{VERSION}'); import server.main; print('server.main OK')"
          if ($LASTEXITCODE -ne 0) { Write-Error "Server import test FAILED!"; exit 1 }
          Write-Host "Server launch test passed!"
        shell: powershell

      # ============================================================
      # STEP 3: Build Electron app (npm Cache-First)
      # ============================================================
      - name: Install Node Dependencies
        run: |
          $cacheRoot = "C:\BuildCache"

          # Calculate package-lock.json hash for cache key
          $lockHash = (Get-FileHash "locaNext\package-lock.json" -Algorithm SHA256).Hash.Substring(0,12)
          $npmCacheDir = "$cacheRoot\npm-cache\$lockHash"

          if (Test-Path "$npmCacheDir\node_modules") {
            Write-Host "[CACHE] Copying node_modules from cache (hash: $lockHash)..." -ForegroundColor Green
            Copy-Item -Path "$npmCacheDir\node_modules" -Destination "locaNext\node_modules" -Recurse -Force
            $size = [math]::Round((Get-ChildItem "locaNext\node_modules" -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB, 1)
            Write-Host "[OK] node_modules ready ($size MB) - FROM CACHE" -ForegroundColor Green
          } else {
            Write-Host "[DOWNLOAD] Running npm ci (cache miss for hash: $lockHash)..." -ForegroundColor Yellow
            cd locaNext
            npm ci
            cd ..

            $size = [math]::Round((Get-ChildItem "locaNext\node_modules" -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB, 1)
            Write-Host "[OK] npm ci complete ($size MB)" -ForegroundColor Green

            # Update cache for next time
            Write-Host "[CACHE] Saving node_modules to cache..." -ForegroundColor Cyan
            New-Item -ItemType Directory -Force -Path $npmCacheDir | Out-Null
            Copy-Item -Path "locaNext\node_modules" -Destination "$npmCacheDir\node_modules" -Recurse -Force

            # Cleanup old npm cache entries (keep last 3)
            $npmCacheParent = "$cacheRoot\npm-cache"
            $cacheEntries = Get-ChildItem $npmCacheParent -Directory | Sort-Object LastWriteTime -Descending
            if ($cacheEntries.Count -gt 3) {
              $toDelete = $cacheEntries | Select-Object -Skip 3
              foreach ($dir in $toDelete) {
                Write-Host "[CACHE] Cleaning old cache: $($dir.Name)" -ForegroundColor Gray
                Remove-Item $dir.FullName -Recurse -Force -ErrorAction SilentlyContinue
              }
            }
            Write-Host "[CACHE] npm cache updated" -ForegroundColor Cyan
          }
        shell: powershell

      # Clear electron-builder cache to avoid symlink/NSIS corruption
      - name: Clear Electron Builder Cache
        run: |
          Write-Host "Clearing ALL electron-builder caches to avoid corruption issues..."

          # Clear LOCALAPPDATA cache
          $localCache = "$env:LOCALAPPDATA\electron-builder\Cache"
          if (Test-Path $localCache) {
            Remove-Item -Path $localCache -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "[OK] Cleared LOCALAPPDATA electron-builder cache"
          }

          # Clear TEMP cache (NSIS, nsis-resources)
          $tempCache = "$env:TEMP\electron-builder-cache"
          if (Test-Path $tempCache) {
            Remove-Item -Path $tempCache -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "[OK] Cleared TEMP electron-builder cache"
          }

          # Clear Windows TEMP cache (another location)
          $winTempCache = "C:\WINDOWS\TEMP\electron-builder-cache"
          if (Test-Path $winTempCache) {
            Remove-Item -Path $winTempCache -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "[OK] Cleared C:\WINDOWS\TEMP electron-builder cache"
          }

          # Clear systemprofile AppData caches (service account)
          $sysLocalAppData = "C:\Windows\System32\config\systemprofile\AppData\Local\electron-builder"
          if (Test-Path $sysLocalAppData) {
            Remove-Item -Path $sysLocalAppData -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "[OK] Cleared systemprofile Local electron-builder cache"
          }

          Write-Host "[OK] All electron-builder caches cleared"
        shell: powershell

      # Set cache directory for Windows SYSTEM account
      - name: Configure Electron Builder Environment
        run: |
          # Create dedicated cache directory
          $cacheDir = "C:\electron-builder-cache"
          New-Item -ItemType Directory -Force -Path $cacheDir | Out-Null

          # Set environment variables for this job
          echo "ELECTRON_BUILDER_CACHE=$cacheDir" >> $env:GITHUB_ENV

          Write-Host "[OK] ELECTRON_BUILDER_CACHE set to: $cacheDir"
        shell: powershell

      # NSIS include files (Cache-First)
      - name: Ensure NSIS Include Files
        run: |
          Write-Host "=== NSIS Include Files Setup (Cache-First) ===" -ForegroundColor Cyan

          $cacheRoot = "C:\BuildCache"
          $cachedNsisDir = "$cacheRoot\nsis-includes"
          $workDir = (Get-Location).Path
          $targetInclude = Join-Path $workDir "locaNext\node_modules\app-builder-lib\templates\nsis\include"

          # Create target directory
          New-Item -ItemType Directory -Force -Path $targetInclude | Out-Null

          # Check if cache exists
          if (Test-Path "$cachedNsisDir\StdUtils.nsh") {
            Write-Host "[CACHE] Copying NSIS includes from cache..." -ForegroundColor Green
            Copy-Item -Path "$cachedNsisDir\*" -Destination $targetInclude -Force
            $fileCount = (Get-ChildItem $targetInclude -Filter "*.nsh").Count
            Write-Host "[OK] NSIS includes ready ($fileCount files) - FROM CACHE" -ForegroundColor Green
          } else {
            Write-Host "[DOWNLOAD] Downloading NSIS includes (no cache)..." -ForegroundColor Yellow

            $includeFiles = @(
              "StdUtils.nsh",
              "WinVer.nsh",
              "allowOnlyOneInstallerInstance.nsh",
              "assistedInstaller.nsh",
              "boringInstaller.nsh",
              "checkAppRunning.nsh",
              "extractAppPackage.nsh",
              "fileAssociation.nsh",
              "installer.nsh",
              "installSection.nsh",
              "multiUser.nsh",
              "multiUserUi.nsh",
              "oneClick.nsh",
              "UAC.nsh",
              "uninstaller.nsh"
            )

            $baseUrl = "https://raw.githubusercontent.com/electron-userland/electron-builder/master/packages/app-builder-lib/templates/nsis/include"

            foreach ($file in $includeFiles) {
              $url = "$baseUrl/$file"
              $dest = Join-Path $targetInclude $file
              & curl.exe -L --retry 3 -s -o $dest $url
              if (Test-Path $dest) {
                Write-Host "  [OK] $file"
              }
            }

            Write-Host "[OK] NSIS includes downloaded" -ForegroundColor Green

            # Update cache for next time
            Write-Host "[CACHE] Saving NSIS includes to cache..." -ForegroundColor Cyan
            New-Item -ItemType Directory -Force -Path $cachedNsisDir | Out-Null
            Copy-Item -Path "$targetInclude\*" -Destination $cachedNsisDir -Force
            Write-Host "[CACHE] NSIS cache updated" -ForegroundColor Cyan
          }

          # Verify StdUtils.nsh specifically
          $stdUtils = Join-Path $targetInclude "StdUtils.nsh"
          if (Test-Path $stdUtils) {
            $content = Get-Content $stdUtils -Head 3
            Write-Host "=== StdUtils.nsh first 3 lines ==="
            Write-Host $content
            Write-Host "[OK] StdUtils.nsh verified"
          } else {
            Write-Host "[ERROR] StdUtils.nsh NOT FOUND at: $stdUtils"
            exit 1
          }
        shell: powershell

      - name: Build Electron App
        run: |
          cd locaNext

          # First build the frontend
          npm run build

          # CRITICAL: Verify/restore NSIS include files right before electron-builder
          Write-Host "=== Pre-build NSIS verification ==="
          Write-Host "Current dir: $(Get-Location)"

          $includeDir = "node_modules\app-builder-lib\templates\nsis\include"
          $stdUtils = "$includeDir\StdUtils.nsh"

          # Show absolute path
          $absIncludeDir = (Resolve-Path $includeDir -ErrorAction SilentlyContinue).Path
          Write-Host "Include dir absolute: $absIncludeDir"

          if (!(Test-Path $stdUtils)) {
            Write-Host "[WARN] StdUtils.nsh missing! Re-downloading..."
            New-Item -ItemType Directory -Force -Path $includeDir | Out-Null

            $baseUrl = "https://raw.githubusercontent.com/electron-userland/electron-builder/master/packages/app-builder-lib/templates/nsis/include"
            $files = @("StdUtils.nsh","WinVer.nsh","allowOnlyOneInstallerInstance.nsh","assistedInstaller.nsh","boringInstaller.nsh","checkAppRunning.nsh","extractAppPackage.nsh","fileAssociation.nsh","installer.nsh","installSection.nsh","multiUser.nsh","multiUserUi.nsh","oneClick.nsh","UAC.nsh","uninstaller.nsh")

            foreach ($f in $files) {
              & curl.exe -L --retry 3 -s -o "$includeDir\$f" "$baseUrl/$f"
            }
          }

          # Verify StdUtils.nsh exists and content is valid
          if (Test-Path $stdUtils) {
            $size = (Get-Item $stdUtils).Length
            Write-Host "[OK] StdUtils.nsh exists ($size bytes)"

            # Show first 3 lines to verify it's real NSIS code
            Write-Host "=== First 3 lines of StdUtils.nsh ==="
            Get-Content $stdUtils -Head 3

            # List all files in include dir
            Write-Host "=== All files in include dir ==="
            Get-ChildItem $includeDir | Select-Object Name,Length
          } else {
            Write-Host "[ERROR] StdUtils.nsh STILL missing!"
            exit 1
          }

          # Show templates/nsis directory structure
          Write-Host "=== templates/nsis directory structure ==="
          Get-ChildItem "node_modules\app-builder-lib\templates\nsis" -Recurse | Select-Object FullName

          # WORKAROUND: Copy includes to NSIS cache directory (permission issue)
          # electron-builder downloads NSIS to this location
          $nsisCache = "$env:TEMP\electron-builder-cache\nsis"
          Write-Host "=== Looking for NSIS cache at: $nsisCache ==="

          if (Test-Path $nsisCache) {
            $nsisDir = Get-ChildItem $nsisCache -Directory | Select-Object -First 1
            if ($nsisDir) {
              $nsisInclude = Join-Path $nsisDir.FullName "Include"
              Write-Host "Found NSIS dir: $($nsisDir.FullName)"
              Write-Host "NSIS Include dir: $nsisInclude"

              if (!(Test-Path $nsisInclude)) {
                New-Item -ItemType Directory -Force -Path $nsisInclude | Out-Null
              }

              # Copy all .nsh files from templates/nsis/include to NSIS Include
              $sourceInclude = "node_modules\app-builder-lib\templates\nsis\include"
              if (Test-Path $sourceInclude) {
                Copy-Item -Path "$sourceInclude\*.nsh" -Destination $nsisInclude -Force
                Write-Host "[OK] Copied include files to NSIS Include directory"
                Get-ChildItem $nsisInclude -Name
              }
            }
          }

          # Now run electron-builder
          npm run build:electron
        shell: powershell
        env:
          # Disable code signing completely for unsigned builds
          # CSC_IDENTITY_AUTO_DISCOVERY prevents auto-discovery of certificates
          # DO NOT set CSC_LINK="" - empty string is treated as current directory!
          CSC_IDENTITY_AUTO_DISCOVERY: "false"
          # Debug output
          DEBUG: electron-builder

      - name: Verify Electron Build
        run: |
          if (!(Test-Path "locaNext\dist-electron\win-unpacked\LocaNext.exe")) {
            Write-Error "[ERROR] Electron build failed - LocaNext.exe not found"
            exit 1
          }
          Write-Host "[OK] Electron build successful"
        shell: powershell

      # ============================================================
      # STEP 4: Compile Inno Setup installer
      # ============================================================
      - name: Setup Inno Setup Path
        run: |
          # Check common Inno Setup locations and add to PATH
          $innoLocations = @(
            "C:\Program Files (x86)\Inno Setup 6",
            "C:\Program Files\Inno Setup 6",
            "$env:LOCALAPPDATA\Programs\Inno Setup 6"
          )

          foreach ($loc in $innoLocations) {
            if (Test-Path "$loc\ISCC.exe") {
              Write-Host "[OK] Found Inno Setup at: $loc"
              $env:Path += ";$loc"
              [Environment]::SetEnvironmentVariable('Path', $env:Path, 'Process')
              break
            }
          }

          # Verify ISCC is accessible
          $iscc = Get-Command ISCC.exe -ErrorAction SilentlyContinue
          if ($iscc) {
            Write-Host "[OK] ISCC.exe found: $($iscc.Source)"
          } else {
            Write-Host "Inno Setup not found - installing via choco..."
            choco install innosetup -y
          }
        shell: powershell

      - name: Compile LIGHT Installer
        run: |
          Write-Host "Compiling LIGHT Windows installer..."

          # Debug: Show current directory structure
          Write-Host "=== DEBUG: Directory Structure ==="
          Write-Host "Working dir: $(Get-Location)"
          Write-Host "Listing root:"
          Get-ChildItem | Format-Table Name, Mode

          Write-Host "`nChecking locaNext/dist-electron:"
          if (Test-Path "locaNext\dist-electron") {
            Get-ChildItem "locaNext\dist-electron" | Format-Table Name, Mode
            if (Test-Path "locaNext\dist-electron\win-unpacked") {
              Write-Host "win-unpacked ALL contents:"
              Get-ChildItem "locaNext\dist-electron\win-unpacked" | Format-Table Name
              Write-Host "`nLooking for *.exe:"
              Get-ChildItem "locaNext\dist-electron\win-unpacked\*.exe" -ErrorAction SilentlyContinue | Format-Table Name, Length
              Write-Host "LocaNext.exe exists: $(Test-Path 'locaNext\dist-electron\win-unpacked\LocaNext.exe')"
            }
          } else {
            Write-Host "locaNext\dist-electron NOT FOUND!"
          }

          Write-Host "`nChecking installer directory:"
          Get-ChildItem "installer" | Format-Table Name

          # WORKAROUND: Skip Inno Setup (has path issues on Windows runner)
          # Instead, create a ZIP of the unpacked Electron app
          $version = "${{ steps.check.outputs.version }}"
          $srcDir = "locaNext\dist-electron\win-unpacked"
          $outDir = "installer_output"
          $zipName = "LocaNext_v${version}_Light_Portable.zip"

          if (!(Test-Path $outDir)) {
            New-Item -ItemType Directory -Path $outDir -Force
          }

          Write-Host "Creating portable ZIP: $zipName"
          Write-Host "Source: $srcDir"
          Write-Host "Output: $outDir\$zipName"

          # Copy additional files into win-unpacked before zipping
          Copy-Item "server" -Destination "$srcDir\server" -Recurse -Force
          Copy-Item "version.py" -Destination "$srcDir\version.py" -Force

          # Create tools directory and copy scripts
          $toolsDir = "$srcDir\tools"
          if (!(Test-Path $toolsDir)) { New-Item -ItemType Directory -Path $toolsDir -Force }
          Get-ChildItem "tools\*.bat" -ErrorAction SilentlyContinue | ForEach-Object { Copy-Item $_.FullName -Destination $toolsDir -Force }
          Get-ChildItem "tools\*.py" -ErrorAction SilentlyContinue | ForEach-Object { Copy-Item $_.FullName -Destination $toolsDir -Force }

          # Create ZIP
          Compress-Archive -Path "$srcDir\*" -DestinationPath "$outDir\$zipName" -Force

          if (Test-Path "$outDir\$zipName") {
            $size = (Get-Item "$outDir\$zipName").Length / 1MB
            Write-Host "[OK] Portable ZIP created: $zipName ($([math]::Round($size, 1)) MB)"
          } else {
            Write-Error "[ERROR] Failed to create ZIP"
            exit 1
          }
        shell: powershell

      - name: Verify Portable ZIP
        run: |
          $version = "${{ steps.check.outputs.version }}"
          $archive = Get-ChildItem "installer_output\*.zip" | Select-Object -First 1
          if (!$archive) { Write-Error "[ERROR] No ZIP found"; exit 1 }
          Write-Host "[OK] Portable ZIP created: $($archive.Name)"
          $size = $archive.length / 1MB
          Write-Host "  Size: $([math]::Round($size, 1)) MB"
        shell: powershell

      # ============================================================
      # STEP 5: Generate latest.yml for Auto-Update
      # ============================================================
      - name: Generate latest.yml for Auto-Update
        run: |
          Write-Host "=== Generating latest.yml for electron-updater ==="
          $version = "${{ steps.check.outputs.version }}"

          $archive = Get-ChildItem "installer_output\*.zip" | Select-Object -First 1
          if (!$archive) { Write-Error "[ERROR] No ZIP found"; exit 1 }

          $fileName = $archive.Name
          $fileSize = $archive.Length
          $hash = (Get-FileHash -Path $archive.FullName -Algorithm SHA512).Hash.ToLower()

          # Try to get semantic version from version.py (without embedded Python)
          $semanticVersion = "1.3.0"  # Default fallback

          $releaseDate = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ss.fffZ")

          $latestYml = "version: $semanticVersion`nfiles:`n  - url: $fileName`n    sha512: $hash`n    size: $fileSize`npath: $fileName`nsha512: $hash`nreleaseDate: '$releaseDate'"

          $latestYml | Out-File -FilePath "installer_output\latest.yml" -Encoding UTF8 -NoNewline
          Write-Host "[OK] latest.yml generated"
          Get-Content "installer_output\latest.yml"
        shell: powershell

      # NOTE: Artifact upload removed - actions/upload-artifact@v4 not supported on Gitea
      # The portable ZIP is saved in installer_output/ on the runner
      # To get the artifact: Check runner workspace at C:\WINDOWS\system32\config\systemprofile\.cache\act\...\hostexecutor\installer_output\

      # ============================================================
      # POST-BUILD TESTS
      # ============================================================
      - name: Test Portable ZIP
        run: |
          Write-Host "=== POST-BUILD TEST: Extracting portable ZIP ==="
          $archive = Get-ChildItem "installer_output\*.zip" | Select-Object -First 1
          $extractDir = "$env:TEMP\LocaNext_Test"
          if (Test-Path $extractDir) { Remove-Item $extractDir -Recurse -Force }
          Expand-Archive -Path $archive.FullName -DestinationPath $extractDir
          Write-Host "[OK] Extracted to: $extractDir"
          Get-ChildItem $extractDir | Select-Object -First 10 | Format-Table Name
        shell: powershell

      - name: Verify Installation Files
        run: |
          $installDir = "$env:TEMP\LocaNext_Test"
          if (!(Test-Path "$installDir\LocaNext.exe")) { Write-Error "[ERROR] LocaNext.exe not found"; exit 1 }
          if (!(Test-Path "$installDir\server\main.py")) { Write-Error "[ERROR] server/main.py not found"; exit 1 }
          if (!(Test-Path "$installDir\version.py")) { Write-Error "[ERROR] version.py not found"; exit 1 }
          # NOTE: LIGHT builds don't include embedded Python - backend tested on first app launch
          if (Test-Path "$installDir\tools\python\python.exe") {
            Write-Host "[OK] Embedded Python found (FULL build)"
          } else {
            Write-Host "[INFO] No embedded Python (LIGHT build - uses system Python on first launch)"
          }
          Write-Host "[PASS] All critical files present!"
        shell: powershell

      # NOTE: Backend health check skipped for LIGHT builds (no embedded Python)
      # LIGHT builds test backend on first app launch via first-run-setup.js

      - name: Cleanup Test Installation
        if: always()
        run: |
          $installDir = "$env:TEMP\LocaNext_Test"
          if (Test-Path $installDir) {
            Remove-Item -Recurse -Force $installDir -ErrorAction SilentlyContinue
            Write-Host "[OK] Test installation cleaned up"
          }
        shell: powershell

      - name: Build Complete
        run: |
          Write-Host "============================================"
          Write-Host "[SUCCESS] LocaNext LIGHT Build Complete!"
          Write-Host "============================================"
          Write-Host "Output: installer_output\LocaNext_v${{ steps.check.outputs.version }}_Light_Portable.zip"
        shell: powershell

      # NOTE: No cleanup workarounds needed!
      # Using ephemeral runner mode (Solution F from P13.11):
      # - Runner exits after each job
      # - All handles released automatically
      # - No more "Job failed" false positives

  # ============================================================
  # JOB 4: Create Gitea Release
  # REMOVED - The disabled job with needs: [build-windows] was causing
  # act_runner to report false "Job failed" status.
  # For releases, use the mirror script: scripts/mirror_release_to_gitea.sh
  # ============================================================
