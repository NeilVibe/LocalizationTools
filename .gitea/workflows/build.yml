# ============================================================================
# LocaNext Build Pipeline - Gitea Actions
# ============================================================================
# 3 MODES:
#   - Build LIGHT: Full official build (~200MB)
#   - Build FULL:  Same + bundled AI model (~2GB)
#   - TROUBLESHOOT: Smart checkpoint mode (resume from last failure)
#
# VERSION: Auto-generated YY.MMDD.HHMM format (Pipeline Executive Power)
# CHECKPOINT: Stored at /home/neil1988/.locanext_checkpoint (persistent)
# ============================================================================

name: Build LocaNext LIGHT Installer

on:
  push:
    branches: [ main ]
    paths:
      - 'GITEA_TRIGGER.txt'
  workflow_dispatch:

env:
  GITEA_URL: http://172.28.150.120:3000
  GITEA_REPO: neilvibe/LocaNext

jobs:
  # ============================================================
  # JOB 1: Check Build Trigger
  # ============================================================
  check-build-trigger:
    name: Check Build Trigger
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      version: ${{ steps.check.outputs.version }}
      mode: ${{ steps.check.outputs.mode }}
      skip_build: ${{ steps.check.outputs.skip_build }}
      build_type: ${{ steps.check.outputs.build_type }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check GITEA_TRIGGER.txt
        id: check
        run: |
          TRIGGER=$(cat GITEA_TRIGGER.txt | grep -E "^Build (LIGHT|FULL)|^TROUBLESHOOT" | tail -1)
          echo "Trigger line: $TRIGGER"

          if [ -n "$TRIGGER" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT

            # AUTO-GENERATE VERSION: YY.MMDD.HHMM format
            VERSION=$(TZ='Asia/Seoul' date '+%y.%m%d.%H%M')
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "[OK] Auto-generated version: $VERSION"

            # ============================================================
            # 3 MODES ONLY: Build LIGHT, Build FULL, TROUBLESHOOT
            # ============================================================

            if echo "$TRIGGER" | grep -q "^TROUBLESHOOT"; then
              echo "mode=troubleshoot" >> $GITHUB_OUTPUT
              echo "skip_build=yes" >> $GITHUB_OUTPUT
              echo "[TROUBLESHOOT] Smart checkpoint mode"
            else
              echo "mode=official" >> $GITHUB_OUTPUT
              echo "skip_build=false" >> $GITHUB_OUTPUT
              echo "[OFFICIAL] Full clean build"
            fi

            # Detect FULL vs LIGHT
            if echo "$TRIGGER" | grep -q "^Build FULL"; then
              echo "build_type=FULL" >> $GITHUB_OUTPUT
            else
              echo "build_type=LIGHT" >> $GITHUB_OUTPUT
            fi
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
            echo "No build trigger found"
          fi

  # ============================================================
  # JOB 2: Safety Checks (Tests, Security, Version)
  # ============================================================
  safety-checks:
    name: Safety Checks (Tests, Security, Version)
    runs-on: ubuntu-latest
    needs: check-build-trigger

    # Gitea runner is host mode - use PostgreSQL installed on host
    # Created with: sudo -u postgres psql -c "CREATE USER locanext_ci ..."
    env:
      CI: "true"
      BUILD_MODE: ${{ needs.check-build-trigger.outputs.mode }}
      POSTGRES_USER: locanext_ci
      POSTGRES_PASSWORD: locanext_ci_test
      POSTGRES_DB: locanext_ci_test
      POSTGRES_HOST: localhost
      POSTGRES_PORT: "5432"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # ============================================================
      # EXECUTIVE POWER: Inject auto-generated version
      # ============================================================
      - name: Inject Version (Pipeline Executive Power)
        run: |
          VERSION="${{ needs.check-build-trigger.outputs.version }}"
          echo "=== PIPELINE EXECUTIVE POWER ==="
          echo "Injecting version: $VERSION (YY.MMDD.HHMM format)"

          # Update version.py
          sed -i "s/VERSION = \"[^\"]*\"/VERSION = \"$VERSION\"/" version.py

          # Update package.json
          sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" locaNext/package.json

          # Update installer scripts
          sed -i "s/#define MyAppVersion \"[^\"]*\"/#define MyAppVersion \"$VERSION\"/" installer/locanext_light.iss
          sed -i "s/#define MyAppVersion \"[^\"]*\"/#define MyAppVersion \"$VERSION\"/" installer/locanext_electron.iss

          echo "[OK] All files updated to version: $VERSION"
          grep "VERSION" version.py | head -1

      # Host mode: Use system Python 3.11 and Node directly (no setup actions needed)
      - name: Verify Python 3.11
        run: |
          python3.11 --version
          python3.11 -m pip --version

      - name: Verify Node.js
        run: |
          node --version
          npm --version

      - name: Install Python Dependencies
        run: |
          python3.11 -m pip install --upgrade pip
          python3.11 -m pip install -r requirements.txt
          python3.11 -m pip install pytest pip-audit

      - name: Install Node Dependencies
        run: |
          cd locaNext && npm ci

      # ---- VERSION CHECK ----
      - name: Version Unification Check
        run: |
          echo "=== Checking version unification across all files ==="
          python3.11 scripts/check_version_unified.py
          echo "[OK] All versions unified"

      # ---- VERSION INCREMENT CHECK (GITEA API) ----
      - name: Check Version Increment
        run: |
          echo "=== Checking version is newer than latest release ==="

          # Get current version from version.py
          CURRENT_VERSION=$(python3.11 -c "from version import VERSION; print(VERSION)")
          echo "Current version: $CURRENT_VERSION"

          # Get latest release version from Gitea API
          LATEST_TAG=$(curl -s "${GITEA_URL}/api/v1/repos/${GITEA_REPO}/releases?limit=1" \
            -H "Authorization: token ${{ secrets.RELEASE_TOKEN }}" | \
            jq -r '.[0].tag_name // "v0"')
          LATEST_VERSION=$(echo "$LATEST_TAG" | sed 's/v//')
          echo "Latest release: $LATEST_VERSION"

          # Compare versions (both are YYMMDDHHMM format, simple numeric comparison)
          if [ "$CURRENT_VERSION" -le "$LATEST_VERSION" ] 2>/dev/null; then
            echo "[WARNING] Current version ($CURRENT_VERSION) is not greater than latest release ($LATEST_VERSION)"
            echo "Consider updating VERSION in version.py"
          else
            echo "[OK] Version $CURRENT_VERSION is newer than $LATEST_VERSION"
          fi

      # ---- START SERVER FOR TESTS ----
      - name: Start Server for Tests
        env:
          CI: "true"
          POSTGRES_USER: locanext_ci
          POSTGRES_PASSWORD: locanext_ci_test
          POSTGRES_DB: locanext_ci_test
          POSTGRES_HOST: localhost
          POSTGRES_PORT: "5432"
        run: |
          echo "=== Starting server for tests ==="
          python3.11 server/main.py &
          echo $! > /tmp/server.pid

          # Wait for server with retries
          for i in {1..15}; do
            sleep 2
            echo "Checking server... ($i/15)"
            if curl -s http://localhost:8888/health | grep -q "healthy"; then
              echo "[OK] Server started successfully (PID: $(cat /tmp/server.pid))"
              exit 0
            fi
          done

          echo "[ERROR] Server failed to start!"
          cat /tmp/server.pid | xargs kill 2>/dev/null || true
          exit 1

      # ---- CREATE ADMIN USER FOR TESTS ----
      - name: Create Admin User
        env:
          POSTGRES_USER: locanext_ci
          POSTGRES_PASSWORD: locanext_ci_test
          POSTGRES_DB: locanext_ci_test
          POSTGRES_HOST: localhost
          POSTGRES_PORT: "5432"
        run: |
          echo "=== Creating admin user for tests ==="
          python3.11 scripts/create_admin.py || echo "Admin may already exist"
          echo "[OK] Admin user ready"

      # ---- PYTHON TESTS ----
      # 2 MODES: OFFICIAL (full clean) or TROUBLESHOOT (smart checkpoint)
      - name: Run Python Tests
        env:
          CI: "true"
          POSTGRES_USER: locanext_ci
          POSTGRES_PASSWORD: locanext_ci_test
          POSTGRES_DB: locanext_ci_test
          POSTGRES_HOST: localhost
          POSTGRES_PORT: "5432"
          RUN_API_TESTS: "1"
        run: |
          echo "Server: $(curl -s http://localhost:8888/health)"
          echo "Mode: $BUILD_MODE"
          # Use BUILD_MODE from job-level env
          MODE="$BUILD_MODE"

          # PERSISTENT checkpoint (survives across CI runs - host mode)
          # Use absolute path to avoid $HOME override issues
          CHECKPOINT_FILE="/home/neil1988/.locanext_checkpoint"

          # Common test args (factored out)
          TEST_DIRS="tests/unit/ tests/integration/ tests/security/ tests/e2e/test_kr_similar_e2e.py tests/e2e/test_xlstransfer_e2e.py tests/e2e/test_quicksearch_e2e.py"
          DESELECTS="--deselect=tests/integration/test_tm_real_model.py --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferEmbeddings::test_05_model_loads --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferEmbeddings::test_06_process_excel_for_dictionary --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferEmbeddings::test_07_save_and_load_dictionary --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferTranslation::test_08_find_best_match --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferTranslation::test_09_translate_with_high_threshold"

          # ============================================================
          # TROUBLESHOOT MODE: True resume from checkpoint
          # - Checkpoint = list of remaining tests (one per line)
          # - Resume runs only remaining tests, not full suite
          # - On failure: update checkpoint with new remaining tests
          # ============================================================
          if [ "$MODE" = "troubleshoot" ]; then
            echo "=== TROUBLESHOOT MODE ==="

            if [ -f "$CHECKPOINT_FILE" ]; then
              REMAINING=$(wc -l < "$CHECKPOINT_FILE")
              FIRST_TEST=$(head -1 "$CHECKPOINT_FILE")
              echo "[CHECKPOINT FOUND] $REMAINING tests remaining"
              echo "Starting at: $FIRST_TEST"

              # Run only remaining tests from checkpoint
              set +e
              set -o pipefail
              python3.11 -m pytest $(cat "$CHECKPOINT_FILE" | tr '\n' ' ') -v --tb=short --no-cov -x 2>&1 | tee /tmp/pytest_output.txt
              RESULT=$?
              set +o pipefail
              set -e
            else
              echo "[NO CHECKPOINT] Collecting tests..."
              python3.11 -m pytest $TEST_DIRS $DESELECTS --collect-only -q --quiet 2>&1 | grep "::" | grep "test_" > /tmp/all_tests.txt
              TOTAL=$(wc -l < /tmp/all_tests.txt)
              echo "Collected $TOTAL tests. Running full suite..."

              set +e
              set -o pipefail
              python3.11 -m pytest $TEST_DIRS $DESELECTS -v --tb=short -x 2>&1 | tee /tmp/pytest_output.txt
              RESULT=$?
              set +o pipefail
              set -e
            fi

            # Handle failure - save remaining tests to checkpoint
            if [ $RESULT -ne 0 ]; then
              FAILED=$(grep -E "^FAILED " /tmp/pytest_output.txt | head -1 | sed 's/FAILED //' | cut -d' ' -f1)

              if [ -n "$FAILED" ]; then
                echo "============================================"
                echo "[FAILED] $FAILED"

                if [ -f "$CHECKPOINT_FILE" ]; then
                  # Update checkpoint: find failed test, keep it + remaining
                  POSITION=$(grep -n "^${FAILED}$" "$CHECKPOINT_FILE" | cut -d: -f1)
                  if [ -n "$POSITION" ]; then
                    tail -n +$POSITION "$CHECKPOINT_FILE" > /tmp/new_checkpoint.txt
                    mv /tmp/new_checkpoint.txt "$CHECKPOINT_FILE"
                  fi
                else
                  # First run: find position in collected list
                  POSITION=$(grep -n "^${FAILED}$" /tmp/all_tests.txt | cut -d: -f1)
                  if [ -n "$POSITION" ]; then
                    tail -n +$POSITION /tmp/all_tests.txt > "$CHECKPOINT_FILE"
                  else
                    echo "$FAILED" > "$CHECKPOINT_FILE"
                  fi
                fi

                REMAINING=$(wc -l < "$CHECKPOINT_FILE")
                echo "[CHECKPOINT SAVED] $REMAINING tests remaining"
                echo "Fix and trigger TROUBLESHOOT again"
                echo "============================================"
              fi
              exit 1
            fi

            echo "[OK] All tests passed! Checkpoint cleared."
            rm -f "$CHECKPOINT_FILE"

          # ============================================================
          # OFFICIAL MODE: Full clean run (clears any old checkpoint)
          # ============================================================
          else
            echo "=== OFFICIAL MODE: Full clean build ==="
            rm -f "$CHECKPOINT_FILE"  # Clear any stale checkpoint
            python3.11 -m pytest $TEST_DIRS $DESELECTS -v --tb=short --no-cov -x
            echo "[OK] All tests passed"
          fi

      - name: Stop Server
        if: always()
        run: |
          if [ -f /tmp/server.pid ]; then
            cat /tmp/server.pid | xargs kill 2>/dev/null || true
            echo "[OK] Server stopped"
          fi

      # ---- SECURITY AUDITS ----
      - name: Python Security Audit
        run: |
          echo "=== Checking Python dependencies for vulnerabilities ==="
          pip-audit --desc || echo "Vulnerabilities found - logged for review"
          echo "[OK] Python security audit complete"
        continue-on-error: true

      - name: NPM Security Audit
        run: |
          cd locaNext
          npm audit || echo "Vulnerabilities found - logged for review"
          echo "[OK] NPM security audit complete"
        continue-on-error: true

      - name: Safety Checks Summary
        run: |
          echo "============================================"
          echo "[PASS] SAFETY CHECKS PASSED"
          echo "============================================"

  # ============================================================
  # JOB 3: Build Windows Installer
  # Skips if TROUBLESHOOT mode (test-only, no build artifact)
  # ============================================================
  build-windows:
    name: Build Windows LIGHT Installer
    needs: [check-build-trigger, safety-checks]  # Wait for tests to pass
    # NOTE: Removed 'if' condition due to act_runner bug - check internally
    runs-on: [self-hosted, windows, x64]  # GITEA: Use self-hosted Windows runner

    env:
      SKIP_BUILD: ${{ needs.check-build-trigger.outputs.skip_build }}
      BUILD_VERSION: ${{ needs.check-build-trigger.outputs.version }}

    steps:
      # Check if we should skip the build (TROUBLESHOOT mode)
      - name: Check if should build
        run: |
          Write-Host "SKIP_BUILD='$env:SKIP_BUILD'"
          # Match 'yes' anywhere in the value (handles %!t(string=yes) bug)
          if ($env:SKIP_BUILD -match 'yes') {
            Write-Host "::notice::TROUBLESHOOT mode - skipping Windows build"
            exit 0
          }
          Write-Host "[OK] Proceeding with Windows build"
        shell: powershell

      # Configure UTF-8 to handle Korean characters in output
      - name: Configure UTF-8 Console Encoding
        run: |
          if ($env:SKIP_BUILD -match 'yes') { exit 0 }
          chcp 65001
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
          [Console]::InputEncoding = [System.Text.Encoding]::UTF8
          $PSDefaultParameterValues['*:Encoding'] = 'utf8'
          Write-Host "[OK] Console encoding set to UTF-8"
        shell: powershell

      # Check build trigger and extract version from version.py
      - name: Get Version from Source
        id: check
        env:
          GITEA_URL: ${{ env.GITEA_URL }}
          GITEA_REPO: ${{ env.GITEA_REPO }}
        run: |
          Write-Host "=== Getting Version from Source ==="
          # Use env vars for Gitea URL (defined at workflow level)
          $versionUrl = "$env:GITEA_URL/$env:GITEA_REPO/raw/branch/main/version.py"
          Write-Host "Fetching: $versionUrl"
          $content = (Invoke-WebRequest -Uri $versionUrl -UseBasicParsing).Content

          # Extract VERSION using regex (YY.MMDD.HHMM format)
          if ($content -match 'VERSION\s*=\s*"(\d{2}\.\d{4}\.\d{4})"') {
            $version = $Matches[1]
            Write-Host "Detected version: $version"
            "version=$version" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "[ERROR] Could not extract version from version.py"
            exit 1
          }

          # Detect FULL vs LIGHT build from trigger file
          $triggerUrl = "$env:GITEA_URL/$env:GITEA_REPO/raw/branch/main/GITEA_TRIGGER.txt"
          $triggerContent = (Invoke-WebRequest -Uri $triggerUrl -UseBasicParsing).Content
          $lastTrigger = ($triggerContent -split "`n" | Where-Object { $_ -match "Build (LIGHT|FULL)" } | Select-Object -Last 1)

          if ($lastTrigger -match "FULL") {
            Write-Host "[OK] Build type: FULL (with bundled model)"
            "build_type=FULL" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "[OK] Build type: LIGHT (model downloads on first run)"
            "build_type=LIGHT" >> $env:GITHUB_OUTPUT
          }
        shell: powershell

      # Standard checkout - workspace cleanup handled at end of job
      - name: Checkout code
        uses: actions/checkout@v4

      # ============================================================
      # EXECUTIVE POWER: Inject auto-generated version into ALL files
      # Pipeline controls ALL versions - single source of truth
      # Format: YY.MMDD.HHMM (valid semver + human-readable datetime)
      # ============================================================
      - name: Inject Version (Pipeline Executive Power)
        run: |
          $version = "${{ steps.check.outputs.version }}"
          Write-Host "=== PIPELINE EXECUTIVE POWER ===" -ForegroundColor Cyan
          Write-Host "Injecting auto-generated version: $version" -ForegroundColor Green
          Write-Host "Format: YY.MMDD.HHMM (semver + datetime unified)" -ForegroundColor Yellow

          # 1. version.py (source of truth)
          $content = Get-Content "version.py" -Raw
          $content = $content -replace 'VERSION = "[^"]+"', "VERSION = `"$version`""
          $content | Set-Content "version.py" -NoNewline
          Write-Host "[OK] version.py updated" -ForegroundColor Green

          # 2. package.json (Electron)
          $pkgPath = "locaNext/package.json"
          if (Test-Path $pkgPath) {
            $pkg = Get-Content $pkgPath -Raw
            $pkg = $pkg -replace '"version": "[^"]+"', "`"version`": `"$version`""
            $pkg | Set-Content $pkgPath -NoNewline
            Write-Host "[OK] package.json updated" -ForegroundColor Green
          }

          # 3. Installer scripts
          foreach ($issFile in @("installer/locanext_light.iss", "installer/locanext_electron.iss")) {
            if (Test-Path $issFile) {
              $iss = Get-Content $issFile -Raw
              $iss = $iss -replace '#define MyAppVersion "[^"]+"', "#define MyAppVersion `"$version`""
              $iss | Set-Content $issFile -NoNewline
              Write-Host "[OK] $issFile updated" -ForegroundColor Green
            }
          }

          Write-Host ""
          Write-Host "=== VERSION INJECTION COMPLETE ===" -ForegroundColor Cyan
          Write-Host "All files now use: $version" -ForegroundColor Green
        shell: powershell

      # NOTE: We don't use actions/setup-python@v5 because it fails when runner
      # runs as SYSTEM service (can't write to systemprofile cache).
      # Instead, we use the pre-installed Python on the Windows build machine.
      - name: Verify Python Installation
        run: |
          Write-Host "=== Verifying Python Installation ===" -ForegroundColor Cyan

          # Check common Python locations
          $pythonPaths = @(
            "C:\Python313\python.exe",
            "C:\Python311\python.exe",
            "C:\Python310\python.exe",
            "C:\Python39\python.exe"
          )

          $pythonExe = $null
          foreach ($path in $pythonPaths) {
            if (Test-Path $path) {
              $pythonExe = $path
              Write-Host "[OK] Found Python at: $path" -ForegroundColor Green
              break
            }
          }

          if (-not $pythonExe) {
            # Try PATH
            $pythonExe = (Get-Command python -ErrorAction SilentlyContinue).Source
            if ($pythonExe) {
              Write-Host "[OK] Found Python in PATH: $pythonExe" -ForegroundColor Green
            } else {
              Write-Error "[ERROR] Python not found! Install Python 3.9+ to C:\PythonXX"
              exit 1
            }
          }

          # Get Python directory and add to PATH
          $pythonDir = Split-Path $pythonExe -Parent
          $scriptsDir = Join-Path $pythonDir "Scripts"

          # Add to PATH for this session
          $env:PATH = "$pythonDir;$scriptsDir;$env:PATH"
          Write-Host "Added to PATH: $pythonDir, $scriptsDir"

          # Verify
          & $pythonExe --version

          # Create aliases for python and pip
          Set-Alias -Name python -Value $pythonExe -Scope Global
          Write-Host "[OK] Python ready for build" -ForegroundColor Green
        shell: powershell

      # NOTE: We don't use actions/setup-node@v4 because 7zr.exe extraction fails
      # when runner runs as SYSTEM service. Instead, use pre-installed Node.js.
      - name: Verify Node.js Installation
        run: |
          Write-Host "=== Verifying Node.js Installation ===" -ForegroundColor Cyan

          # Check common Node.js locations
          $nodePaths = @(
            "C:\Program Files\nodejs\node.exe",
            "C:\nodejs\node.exe"
          )

          $nodeExe = $null
          foreach ($path in $nodePaths) {
            if (Test-Path $path) {
              $nodeExe = $path
              Write-Host "[OK] Found Node.js at: $path" -ForegroundColor Green
              break
            }
          }

          if (-not $nodeExe) {
            # Try PATH
            $nodeExe = (Get-Command node -ErrorAction SilentlyContinue).Source
            if ($nodeExe) {
              Write-Host "[OK] Found Node.js in PATH: $nodeExe" -ForegroundColor Green
            } else {
              Write-Error "[ERROR] Node.js not found! Install Node.js 18+ to C:\Program Files\nodejs"
              exit 1
            }
          }

          # Get Node directory and add to PATH
          $nodeDir = Split-Path $nodeExe -Parent
          $env:PATH = "$nodeDir;$env:PATH"
          Write-Host "Added to PATH: $nodeDir"

          # Verify versions
          & node --version
          & npm --version

          Write-Host "[OK] Node.js ready for build" -ForegroundColor Green
        shell: powershell

      # ============================================================
      # SMART BUILD CACHE SYSTEM
      # Cache location: C:\BuildCache\
      # Auto-invalidates when versions/hashes change
      # ============================================================
      - name: Initialize Smart Cache
        id: cache_init
        run: |
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  SMART BUILD CACHE SYSTEM v2.0" -ForegroundColor Cyan
          Write-Host "  Hash-based invalidation enabled" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan

          $cacheRoot = "C:\BuildCache"
          $manifestPath = "$cacheRoot\CACHE_MANIFEST.json"

          # Expected versions (update these when upgrading)
          $expectedPythonVersion = "3.11.9"
          $expectedVCRedistVersion = "17.8"

          # ============================================================
          # SMART HASH COMPUTATION - Invalidate when dependencies change
          # ============================================================

          # Compute requirements.txt hash (for pip packages)
          $reqHash = ""
          if (Test-Path "requirements.txt") {
            $reqHash = (Get-FileHash "requirements.txt" -Algorithm SHA256).Hash.Substring(0, 12)
            Write-Host "[HASH] requirements.txt: $reqHash" -ForegroundColor Cyan
          } else {
            Write-Host "[WARN] requirements.txt not found - using package list hash" -ForegroundColor Yellow
            # Fallback: hash the pip install command packages
            $pipPackages = "fastapi uvicorn python-multipart python-socketio sqlalchemy aiosqlite psycopg2-binary PyJWT python-jose passlib python-dotenv bcrypt pydantic pydantic-settings email-validator pandas openpyxl xlrd httpx requests loguru tqdm pyyaml huggingface_hub"
            $reqHash = [System.BitConverter]::ToString([System.Security.Cryptography.SHA256]::Create().ComputeHash([System.Text.Encoding]::UTF8.GetBytes($pipPackages))).Replace("-","").Substring(0,12)
          }

          # Compute package-lock.json hash (for npm packages - future use)
          $npmHash = ""
          if (Test-Path "locaNext/package-lock.json") {
            $npmHash = (Get-FileHash "locaNext/package-lock.json" -Algorithm SHA256).Hash.Substring(0, 12)
            Write-Host "[HASH] package-lock.json: $npmHash" -ForegroundColor Cyan
          }

          # Create cache root if needed
          if (-not (Test-Path $cacheRoot)) {
            New-Item -ItemType Directory -Path $cacheRoot -Force | Out-Null
            Write-Host "[INIT] Created cache root: $cacheRoot"
          }

          # Load or create manifest
          if (Test-Path $manifestPath) {
            $manifest = Get-Content $manifestPath | ConvertFrom-Json
            Write-Host "[OK] Loaded cache manifest"
          } else {
            $manifest = @{
              version = "2.0"
              created = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ssZ")
              components = @{}
            }
            Write-Host "[INIT] Created new cache manifest"
          }

          # Output cache status
          Write-Host ""
          Write-Host "Cache Validation:" -ForegroundColor Yellow

          # Check VC++ cache validity (version-based)
          $vcCacheValid = $false
          $vcCachePath = "$cacheRoot\vcredist\vc_redist.x64.exe"
          if ((Test-Path $vcCachePath) -and $manifest.components.vcredist.version -eq $expectedVCRedistVersion) {
            $vcCacheValid = $true
            Write-Host "  [VALID] VC++ Redistributable v$expectedVCRedistVersion" -ForegroundColor Green
          } else {
            if (Test-Path $vcCachePath) {
              Write-Host "  [STALE] VC++ version mismatch (cached: $($manifest.components.vcredist.version), expected: $expectedVCRedistVersion)" -ForegroundColor Yellow
            } else {
              Write-Host "  [MISS] VC++ Redistributable not cached" -ForegroundColor Yellow
            }
          }

          # Check Python cache validity (version + hash-based)
          $pythonCacheValid = $false
          $pythonCachePath = "$cacheRoot\python-embedded\python-$expectedPythonVersion"
          $cachedReqHash = $manifest.components.python_embedded.requirements_hash

          if ((Test-Path "$pythonCachePath\python.exe") -and
              $manifest.components.python_embedded.version -eq $expectedPythonVersion -and
              $cachedReqHash -eq $reqHash) {
            $pythonCacheValid = $true
            Write-Host "  [VALID] Python $expectedPythonVersion + packages (hash: $reqHash)" -ForegroundColor Green
          } else {
            if (Test-Path "$pythonCachePath\python.exe") {
              if ($manifest.components.python_embedded.version -ne $expectedPythonVersion) {
                Write-Host "  [STALE] Python version changed ($($manifest.components.python_embedded.version) -> $expectedPythonVersion)" -ForegroundColor Yellow
              } elseif ($cachedReqHash -ne $reqHash) {
                Write-Host "  [STALE] requirements.txt changed (cached: $cachedReqHash, current: $reqHash)" -ForegroundColor Yellow
              }
            } else {
              Write-Host "  [MISS] Python not cached" -ForegroundColor Yellow
            }
          }

          # Check NSIS cache validity
          $nsisCacheValid = $false
          $nsisCachePath = "$cacheRoot\nsis-includes"
          if (Test-Path "$nsisCachePath\StdUtils.nsh") {
            $nsisCacheValid = $true
            Write-Host "  [VALID] NSIS include files" -ForegroundColor Green
          } else {
            Write-Host "  [MISS] NSIS includes not cached" -ForegroundColor Yellow
          }

          # Set outputs for subsequent steps
          "vc_cached=$vcCacheValid" >> $env:GITHUB_OUTPUT
          "python_cached=$pythonCacheValid" >> $env:GITHUB_OUTPUT
          "nsis_cached=$nsisCacheValid" >> $env:GITHUB_OUTPUT
          "cache_root=$cacheRoot" >> $env:GITHUB_OUTPUT
          "req_hash=$reqHash" >> $env:GITHUB_OUTPUT
          "npm_hash=$npmHash" >> $env:GITHUB_OUTPUT

          Write-Host ""
          Write-Host "Smart Cache Summary:" -ForegroundColor Cyan
          Write-Host "  VC++:   $(if ($vcCacheValid) {'CACHE HIT'} else {'WILL DOWNLOAD'})" -ForegroundColor $(if ($vcCacheValid) {'Green'} else {'Yellow'})
          Write-Host "  Python: $(if ($pythonCacheValid) {'CACHE HIT'} else {'WILL DOWNLOAD'})" -ForegroundColor $(if ($pythonCacheValid) {'Green'} else {'Yellow'})
          Write-Host "  NSIS:   $(if ($nsisCacheValid) {'CACHE HIT'} else {'WILL DOWNLOAD'})" -ForegroundColor $(if ($nsisCacheValid) {'Green'} else {'Yellow'})
          Write-Host ""
        shell: powershell

      # ============================================================
      # STEP 1: VC++ Redistributable (SMART CACHE)
      # ============================================================
      - name: Get VC++ Redistributable (Smart Cache)
        run: |
          $cacheRoot = "C:\BuildCache"
          $cachedPath = "$cacheRoot\vcredist\vc_redist.x64.exe"
          $targetPath = "installer\redist\vc_redist.x64.exe"
          $manifestPath = "$cacheRoot\CACHE_MANIFEST.json"
          $expectedVersion = "17.8"

          New-Item -ItemType Directory -Force -Path "installer\redist" | Out-Null

          # Check if cache is valid
          $useCache = $false
          if (Test-Path $cachedPath) {
            $cachedSize = (Get-Item $cachedPath).Length
            if ($cachedSize -gt 10MB) {
              $useCache = $true
            }
          }

          if ($useCache) {
            Write-Host "[CACHE HIT] Copying VC++ Redistributable from cache..." -ForegroundColor Green
            Copy-Item $cachedPath -Destination $targetPath -Force
            $size = [math]::Round((Get-Item $targetPath).Length / 1MB, 1)
            Write-Host "[OK] VC++ Redistributable: $size MB (from cache)" -ForegroundColor Green
          } else {
            Write-Host "[CACHE MISS] Downloading VC++ Redistributable..." -ForegroundColor Yellow
            Invoke-WebRequest -Uri "https://aka.ms/vs/17/release/vc_redist.x64.exe" -OutFile $targetPath
            $size = [math]::Round((Get-Item $targetPath).Length / 1MB, 1)
            Write-Host "[OK] Downloaded VC++ Redistributable: $size MB"

            # POPULATE CACHE for next build
            Write-Host "Populating cache for future builds..."
            New-Item -ItemType Directory -Force -Path "$cacheRoot\vcredist" | Out-Null
            Copy-Item $targetPath -Destination $cachedPath -Force

            # Update manifest
            if (Test-Path $manifestPath) {
              $manifest = Get-Content $manifestPath | ConvertFrom-Json
            } else {
              $manifest = @{ version = "1.0"; components = @{} }
            }
            $manifest.components | Add-Member -NotePropertyName "vcredist" -NotePropertyValue @{
              version = $expectedVersion
              path = $cachedPath
              size_mb = $size
              cached_at = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ssZ")
            } -Force
            $manifest | ConvertTo-Json -Depth 10 | Out-File $manifestPath -Encoding UTF8
            Write-Host "[CACHED] VC++ Redistributable saved to cache" -ForegroundColor Cyan
          }
        shell: powershell

      # ============================================================
      # STEP 2: Python Embedded + Packages (SMART CACHE v2.0)
      # Invalidates if: Python version changes OR requirements.txt hash changes
      # ============================================================
      - name: Get Python Embedded (Smart Cache)
        run: |
          $cacheRoot = "C:\BuildCache"
          $pythonVersion = "3.11.9"
          $cachedPythonDir = "$cacheRoot\python-embedded\python-$pythonVersion"
          $targetDir = "tools\python"
          $manifestPath = "$cacheRoot\CACHE_MANIFEST.json"

          # ============================================================
          # SMART HASH COMPUTATION - Same logic as Initialize step
          # ============================================================
          $reqHash = ""
          if (Test-Path "requirements.txt") {
            $reqHash = (Get-FileHash "requirements.txt" -Algorithm SHA256).Hash.Substring(0, 12)
          } else {
            $pipPackages = "fastapi uvicorn python-multipart python-socketio sqlalchemy aiosqlite psycopg2-binary PyJWT python-jose passlib python-dotenv bcrypt pydantic pydantic-settings email-validator pandas openpyxl xlrd httpx requests loguru tqdm pyyaml huggingface_hub"
            $reqHash = [System.BitConverter]::ToString([System.Security.Cryptography.SHA256]::Create().ComputeHash([System.Text.Encoding]::UTF8.GetBytes($pipPackages))).Replace("-","").Substring(0,12)
          }

          # List of required packages for existence validation (fallback check)
          $requiredPackages = @("fastapi", "uvicorn", "sqlalchemy", "pandas", "pydantic", "huggingface_hub")

          # Load manifest to check cached hash
          $cachedReqHash = ""
          if (Test-Path $manifestPath) {
            $manifest = Get-Content $manifestPath | ConvertFrom-Json
            $cachedReqHash = $manifest.components.python_embedded.requirements_hash
          }

          # ============================================================
          # SMART CACHE VALIDATION
          # 1. Python.exe exists
          # 2. Version matches
          # 3. Requirements hash matches (SMART!)
          # 4. All required packages exist (fallback safety check)
          # ============================================================
          $useCache = $false
          $cacheInvalidReason = ""

          if (Test-Path "$cachedPythonDir\python.exe") {
            # Check hash match
            if ($cachedReqHash -eq $reqHash) {
              # Verify packages exist (safety check)
              $allPackagesExist = $true
              foreach ($pkg in $requiredPackages) {
                $pkgPath = "$cachedPythonDir\Lib\site-packages\$pkg"
                if (-not (Test-Path $pkgPath)) {
                  $cacheInvalidReason = "Missing package: $pkg"
                  $allPackagesExist = $false
                  break
                }
              }
              if ($allPackagesExist) {
                $useCache = $true
              }
            } else {
              $cacheInvalidReason = "requirements.txt changed (cached: $cachedReqHash, current: $reqHash)"
            }
          } else {
            $cacheInvalidReason = "Python not cached"
          }

          if ($useCache) {
            Write-Host "[CACHE HIT] Copying Python $pythonVersion + packages from cache..." -ForegroundColor Green
            Write-Host "  Hash: $reqHash (matched)" -ForegroundColor Gray
            New-Item -ItemType Directory -Force -Path $targetDir | Out-Null
            Copy-Item -Path "$cachedPythonDir\*" -Destination $targetDir -Recurse -Force
            $size = [math]::Round((Get-ChildItem $targetDir -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB, 1)
            Write-Host "[OK] Python + packages: $size MB (from cache)" -ForegroundColor Green
          } else {
            Write-Host "[CACHE MISS] $cacheInvalidReason" -ForegroundColor Yellow
            Write-Host "Downloading Python $pythonVersion..." -ForegroundColor Cyan
            New-Item -ItemType Directory -Force -Path $targetDir | Out-Null

            # Download Python
            $pythonUrl = "https://www.python.org/ftp/python/$pythonVersion/python-$pythonVersion-embed-amd64.zip"
            $zipPath = "tools\python-embedded.zip"
            Invoke-WebRequest -Uri $pythonUrl -OutFile $zipPath
            Expand-Archive -Path $zipPath -DestinationPath $targetDir -Force
            Remove-Item $zipPath

            # Enable pip in embedded Python
            $pthFile = Get-ChildItem "$targetDir\python*._pth" | Select-Object -First 1
            if ($pthFile) {
              $content = Get-Content $pthFile.FullName
              $content = $content -replace '#import site', 'import site'
              Set-Content -Path $pthFile.FullName -Value $content
            }

            # Install pip
            Write-Host "Installing pip..."
            Invoke-WebRequest -Uri "https://bootstrap.pypa.io/get-pip.py" -OutFile "$targetDir\get-pip.py"
            & "$targetDir\python.exe" "$targetDir\get-pip.py" --no-warn-script-location
            Remove-Item "$targetDir\get-pip.py"

            # Install all packages
            Write-Host "Installing backend dependencies..."
            & "$targetDir\python.exe" -m pip install --no-warn-script-location `
              fastapi uvicorn python-multipart python-socketio `
              sqlalchemy aiosqlite psycopg2-binary `
              PyJWT python-jose passlib python-dotenv bcrypt `
              pydantic pydantic-settings email-validator `
              pandas openpyxl xlrd `
              httpx requests loguru tqdm pyyaml huggingface_hub

            $size = [math]::Round((Get-ChildItem $targetDir -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB, 1)
            Write-Host "[OK] Python + packages installed: $size MB"

            # POPULATE CACHE for next build
            Write-Host "Populating cache for future builds..."
            Write-Host "  Hash: $reqHash (will be stored)" -ForegroundColor Cyan
            New-Item -ItemType Directory -Force -Path "$cacheRoot\python-embedded" | Out-Null
            if (Test-Path $cachedPythonDir) { Remove-Item $cachedPythonDir -Recurse -Force }
            Copy-Item -Path $targetDir -Destination $cachedPythonDir -Recurse -Force

            # Update manifest with HASH for smart invalidation
            if (Test-Path $manifestPath) {
              $manifest = Get-Content $manifestPath | ConvertFrom-Json
            } else {
              $manifest = @{ version = "2.0"; components = @{} }
            }
            $manifest.components | Add-Member -NotePropertyName "python_embedded" -NotePropertyValue @{
              version = $pythonVersion
              path = $cachedPythonDir
              size_mb = $size
              packages = ($requiredPackages -join ",")
              requirements_hash = $reqHash
              cached_at = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ssZ")
            } -Force
            $manifest | ConvertTo-Json -Depth 10 | Out-File $manifestPath -Encoding UTF8
            Write-Host "[CACHED] Python + packages saved with hash: $reqHash" -ForegroundColor Cyan
          }
        shell: powershell

      - name: Verify Python Embedded + ALL Dependencies
        run: |
          Write-Host "Verifying embedded Python setup..."
          & "tools\python\python.exe" --version

          Write-Host "=== Checking ALL critical packages ==="
          & "tools\python\python.exe" -c "import fastapi; print(f'[OK] fastapi v{fastapi.__version__}')"
          & "tools\python\python.exe" -c "import uvicorn; print('[OK] uvicorn ready')"
          & "tools\python\python.exe" -c "import socketio; print('[OK] socketio ready')"
          & "tools\python\python.exe" -c "import sqlalchemy; print(f'[OK] sqlalchemy v{sqlalchemy.__version__}')"
          & "tools\python\python.exe" -c "import aiosqlite; print('[OK] aiosqlite ready')"
          & "tools\python\python.exe" -c "import jwt; print(f'[OK] jwt v{jwt.__version__}')"
          & "tools\python\python.exe" -c "from jose import jwt as jose_jwt; print('[OK] jose.jwt ready')"
          & "tools\python\python.exe" -c "import passlib; print('[OK] passlib ready')"
          & "tools\python\python.exe" -c "import bcrypt; print('[OK] bcrypt ready')"
          & "tools\python\python.exe" -c "import pydantic; print(f'[OK] pydantic v{pydantic.__version__}')"
          & "tools\python\python.exe" -c "import pandas; print(f'[OK] pandas v{pandas.__version__}')"
          & "tools\python\python.exe" -c "import openpyxl; print('[OK] openpyxl ready')"
          & "tools\python\python.exe" -c "import huggingface_hub; print(f'[OK] huggingface_hub v{huggingface_hub.__version__}')"

          # Check required files
          if (!(Test-Path "version.py")) { Write-Error "[ERROR] version.py not found"; exit 1 }
          if (!(Test-Path "server\main.py")) { Write-Error "[ERROR] server/main.py not found"; exit 1 }
          Write-Host "[PASS] All dependencies verified!"
        shell: powershell

      - name: Test Server Launch with Embedded Python
        run: |
          Write-Host "=== Testing server can START with embedded Python ==="
          $env:PYTHONPATH = Get-Location
          & "tools\python\python.exe" -c "import sys; sys.path.insert(0,'.'); from version import VERSION; print(f'version OK: v{VERSION}'); import server.main; print('server.main OK')"
          if ($LASTEXITCODE -ne 0) { Write-Error "Server import test FAILED!"; exit 1 }
          Write-Host "Server launch test passed!"
        shell: powershell

      # ============================================================
      # STEP 2.5: Download Qwen Model (FULL BUILD ONLY)
      # Downloads ~2.3GB model and bundles it in the installer
      # ============================================================
      - name: Download Qwen Embedding Model (FULL only)
        if: steps.check.outputs.build_type == 'FULL'
        run: |
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  DOWNLOADING QWEN EMBEDDING MODEL (FULL BUILD)" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan

          $modelsDir = "models\qwen-embedding"
          if (Test-Path $modelsDir) {
            Write-Host "[SKIP] Model already exists at: $modelsDir"
          } else {
            Write-Host "Downloading Qwen/Qwen3-Embedding-0.6B (~2.3GB)..."
            Write-Host "This may take 5-10 minutes..."

            # Use embedded Python to download via sentence-transformers
            & "tools\python\python.exe" -m pip install --quiet sentence-transformers

            & "tools\python\python.exe" -c "from sentence_transformers import SentenceTransformer; print('Downloading Qwen model...'); model = SentenceTransformer('Qwen/Qwen3-Embedding-0.6B'); model.save('./models/qwen-embedding'); print('Model saved!'); emb = model.encode(['test']); print(f'Dim: {emb.shape[1]}'); print('SUCCESS!')"

            if ($LASTEXITCODE -ne 0) {
              Write-Error "[ERROR] Model download failed!"
              exit 1
            }
          }

          # Verify model
          if (Test-Path "$modelsDir\model.safetensors") {
            $size = [math]::Round((Get-Item "$modelsDir\model.safetensors").Length / 1GB, 2)
            Write-Host "[OK] Qwen model downloaded: $size GB" -ForegroundColor Green
          } else {
            Write-Error "[ERROR] model.safetensors not found!"
            exit 1
          }
        shell: powershell

      # ============================================================
      # STEP 3: Build Electron app
      # ============================================================
      - name: Install Node Dependencies
        run: |
          cd locaNext
          npm ci
        shell: powershell

      # Clear electron-builder cache to avoid symlink/NSIS corruption
      - name: Clear Electron Builder Cache
        run: |
          Write-Host "Clearing ALL electron-builder caches to avoid corruption issues..."

          # Clear LOCALAPPDATA cache
          $localCache = "$env:LOCALAPPDATA\electron-builder\Cache"
          if (Test-Path $localCache) {
            Remove-Item -Path $localCache -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "[OK] Cleared LOCALAPPDATA electron-builder cache"
          }

          # Clear TEMP cache (NSIS, nsis-resources)
          $tempCache = "$env:TEMP\electron-builder-cache"
          if (Test-Path $tempCache) {
            Remove-Item -Path $tempCache -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "[OK] Cleared TEMP electron-builder cache"
          }

          # Clear Windows TEMP cache (another location)
          $winTempCache = "C:\WINDOWS\TEMP\electron-builder-cache"
          if (Test-Path $winTempCache) {
            Remove-Item -Path $winTempCache -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "[OK] Cleared C:\WINDOWS\TEMP electron-builder cache"
          }

          # Clear systemprofile AppData caches (service account)
          $sysLocalAppData = "C:\Windows\System32\config\systemprofile\AppData\Local\electron-builder"
          if (Test-Path $sysLocalAppData) {
            Remove-Item -Path $sysLocalAppData -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "[OK] Cleared systemprofile Local electron-builder cache"
          }

          Write-Host "[OK] All electron-builder caches cleared"
        shell: powershell

      # Set cache directory for Windows SYSTEM account
      - name: Configure Electron Builder Environment
        run: |
          # Create dedicated cache directory
          $cacheDir = "C:\electron-builder-cache"
          New-Item -ItemType Directory -Force -Path $cacheDir | Out-Null

          # Set environment variables for this job
          echo "ELECTRON_BUILDER_CACHE=$cacheDir" >> $env:GITHUB_ENV

          Write-Host "[OK] ELECTRON_BUILDER_CACHE set to: $cacheDir"
        shell: powershell

      # ============================================================
      # NSIS Include Files (SMART CACHE)
      # Static files - cache forever until manually cleared
      # ============================================================
      - name: Get NSIS Include Files (Smart Cache)
        run: |
          Write-Host "=== NSIS Include Files (Smart Cache) ==="

          $cacheRoot = "C:\BuildCache"
          $cachedNsisDir = "$cacheRoot\nsis-includes"
          $workDir = (Get-Location).Path
          $targetInclude = Join-Path $workDir "locaNext\node_modules\app-builder-lib\templates\nsis\include"

          $includeFiles = @(
            "StdUtils.nsh", "WinVer.nsh", "allowOnlyOneInstallerInstance.nsh",
            "assistedInstaller.nsh", "boringInstaller.nsh", "checkAppRunning.nsh",
            "extractAppPackage.nsh", "fileAssociation.nsh", "installer.nsh",
            "installSection.nsh", "multiUser.nsh", "multiUserUi.nsh",
            "oneClick.nsh", "UAC.nsh", "uninstaller.nsh"
          )

          # Create target directory
          New-Item -ItemType Directory -Force -Path $targetInclude | Out-Null

          # Check if cache is valid
          $useCache = $false
          if (Test-Path "$cachedNsisDir\StdUtils.nsh") {
            $cachedCount = (Get-ChildItem "$cachedNsisDir\*.nsh" -ErrorAction SilentlyContinue).Count
            if ($cachedCount -ge $includeFiles.Count) {
              $useCache = $true
            }
          }

          if ($useCache) {
            Write-Host "[CACHE HIT] Copying NSIS includes from cache..." -ForegroundColor Green
            Copy-Item -Path "$cachedNsisDir\*.nsh" -Destination $targetInclude -Force
            $count = (Get-ChildItem "$targetInclude\*.nsh").Count
            Write-Host "[OK] NSIS includes: $count files (from cache)" -ForegroundColor Green
          } else {
            Write-Host "[CACHE MISS] Downloading NSIS include files..." -ForegroundColor Yellow

            $baseUrl = "https://raw.githubusercontent.com/electron-userland/electron-builder/master/packages/app-builder-lib/templates/nsis/include"

            foreach ($file in $includeFiles) {
              $url = "$baseUrl/$file"
              $dest = Join-Path $targetInclude $file
              & curl.exe -L --retry 3 -s -o $dest $url
              if (Test-Path $dest) {
                Write-Host "  [OK] $file"
              } else {
                Write-Host "  [FAIL] $file" -ForegroundColor Red
              }
            }

            $count = (Get-ChildItem "$targetInclude\*.nsh").Count
            Write-Host "[OK] Downloaded $count NSIS include files"

            # POPULATE CACHE for next build
            Write-Host "Populating cache for future builds..."
            New-Item -ItemType Directory -Force -Path $cachedNsisDir | Out-Null
            Copy-Item -Path "$targetInclude\*.nsh" -Destination $cachedNsisDir -Force
            Write-Host "[CACHED] NSIS includes saved to cache" -ForegroundColor Cyan
          }

          # Verify StdUtils.nsh
          $stdUtils = Join-Path $targetInclude "StdUtils.nsh"
          if (Test-Path $stdUtils) {
            Write-Host "[OK] StdUtils.nsh verified" -ForegroundColor Green
          } else {
            Write-Host "[ERROR] StdUtils.nsh NOT FOUND!" -ForegroundColor Red
            exit 1
          }
        shell: powershell

      - name: Build Electron App
        run: |
          cd locaNext

          # First build the frontend
          npm run build

          # CRITICAL: Verify/restore NSIS include files right before electron-builder
          Write-Host "=== Pre-build NSIS verification ==="
          Write-Host "Current dir: $(Get-Location)"

          $includeDir = "node_modules\app-builder-lib\templates\nsis\include"
          $stdUtils = "$includeDir\StdUtils.nsh"

          # Show absolute path
          $absIncludeDir = (Resolve-Path $includeDir -ErrorAction SilentlyContinue).Path
          Write-Host "Include dir absolute: $absIncludeDir"

          if (!(Test-Path $stdUtils)) {
            Write-Host "[WARN] StdUtils.nsh missing! Re-downloading..."
            New-Item -ItemType Directory -Force -Path $includeDir | Out-Null

            $baseUrl = "https://raw.githubusercontent.com/electron-userland/electron-builder/master/packages/app-builder-lib/templates/nsis/include"
            $files = @("StdUtils.nsh","WinVer.nsh","allowOnlyOneInstallerInstance.nsh","assistedInstaller.nsh","boringInstaller.nsh","checkAppRunning.nsh","extractAppPackage.nsh","fileAssociation.nsh","installer.nsh","installSection.nsh","multiUser.nsh","multiUserUi.nsh","oneClick.nsh","UAC.nsh","uninstaller.nsh")

            foreach ($f in $files) {
              & curl.exe -L --retry 3 -s -o "$includeDir\$f" "$baseUrl/$f"
            }
          }

          # Verify StdUtils.nsh exists and content is valid
          if (Test-Path $stdUtils) {
            $size = (Get-Item $stdUtils).Length
            Write-Host "[OK] StdUtils.nsh exists ($size bytes)"

            # Show first 3 lines to verify it's real NSIS code
            Write-Host "=== First 3 lines of StdUtils.nsh ==="
            Get-Content $stdUtils -Head 3

            # List all files in include dir
            Write-Host "=== All files in include dir ==="
            Get-ChildItem $includeDir | Select-Object Name,Length
          } else {
            Write-Host "[ERROR] StdUtils.nsh STILL missing!"
            exit 1
          }

          # Show templates/nsis directory structure
          Write-Host "=== templates/nsis directory structure ==="
          Get-ChildItem "node_modules\app-builder-lib\templates\nsis" -Recurse | Select-Object FullName

          # WORKAROUND: Copy includes to NSIS cache directory (permission issue)
          # electron-builder downloads NSIS to this location
          $nsisCache = "$env:TEMP\electron-builder-cache\nsis"
          Write-Host "=== Looking for NSIS cache at: $nsisCache ==="

          if (Test-Path $nsisCache) {
            $nsisDir = Get-ChildItem $nsisCache -Directory | Select-Object -First 1
            if ($nsisDir) {
              $nsisInclude = Join-Path $nsisDir.FullName "Include"
              Write-Host "Found NSIS dir: $($nsisDir.FullName)"
              Write-Host "NSIS Include dir: $nsisInclude"

              if (!(Test-Path $nsisInclude)) {
                New-Item -ItemType Directory -Force -Path $nsisInclude | Out-Null
              }

              # Copy all .nsh files from templates/nsis/include to NSIS Include
              $sourceInclude = "node_modules\app-builder-lib\templates\nsis\include"
              if (Test-Path $sourceInclude) {
                Copy-Item -Path "$sourceInclude\*.nsh" -Destination $nsisInclude -Force
                Write-Host "[OK] Copied include files to NSIS Include directory"
                Get-ChildItem $nsisInclude -Name
              }
            }
          }

          # Now run electron-builder
          npm run build:electron
        shell: powershell
        env:
          # Disable code signing completely for unsigned builds
          # CSC_IDENTITY_AUTO_DISCOVERY prevents auto-discovery of certificates
          # DO NOT set CSC_LINK="" - empty string is treated as current directory!
          CSC_IDENTITY_AUTO_DISCOVERY: "false"
          # Debug output
          DEBUG: electron-builder

      - name: Verify Electron Build
        run: |
          if (!(Test-Path "locaNext\dist-electron\win-unpacked\LocaNext.exe")) {
            Write-Error "[ERROR] Electron build failed - LocaNext.exe not found"
            exit 1
          }
          Write-Host "[OK] Electron build successful"
        shell: powershell

      # ============================================================
      # STEP 4: Compile Inno Setup installer
      # ============================================================
      - name: Setup Inno Setup Path
        run: |
          # Check common Inno Setup locations and add to PATH
          $innoLocations = @(
            "C:\Program Files (x86)\Inno Setup 6",
            "C:\Program Files\Inno Setup 6",
            "$env:LOCALAPPDATA\Programs\Inno Setup 6"
          )

          foreach ($loc in $innoLocations) {
            if (Test-Path "$loc\ISCC.exe") {
              Write-Host "[OK] Found Inno Setup at: $loc"
              $env:Path += ";$loc"
              [Environment]::SetEnvironmentVariable('Path', $env:Path, 'Process')
              break
            }
          }

          # Verify ISCC is accessible
          $iscc = Get-Command ISCC.exe -ErrorAction SilentlyContinue
          if ($iscc) {
            Write-Host "[OK] ISCC.exe found: $($iscc.Source)"
          } else {
            Write-Host "Inno Setup not found - installing via choco..."
            choco install innosetup -y
          }
        shell: powershell

      - name: Compile Installer (LIGHT or FULL)
        run: |
          $buildType = "${{ steps.check.outputs.build_type }}"
          Write-Host "Compiling $buildType Windows installer..."

          # Debug: Show current directory structure
          Write-Host "=== DEBUG: Directory Structure ==="
          Write-Host "Working dir: $(Get-Location)"
          Write-Host "Listing root:"
          Get-ChildItem | Format-Table Name, Mode

          Write-Host "`nChecking locaNext/dist-electron:"
          if (Test-Path "locaNext\dist-electron") {
            Get-ChildItem "locaNext\dist-electron" | Format-Table Name, Mode
            if (Test-Path "locaNext\dist-electron\win-unpacked") {
              Write-Host "win-unpacked ALL contents:"
              Get-ChildItem "locaNext\dist-electron\win-unpacked" | Format-Table Name
              Write-Host "`nLooking for *.exe:"
              Get-ChildItem "locaNext\dist-electron\win-unpacked\*.exe" -ErrorAction SilentlyContinue | Format-Table Name, Length
              Write-Host "LocaNext.exe exists: $(Test-Path 'locaNext\dist-electron\win-unpacked\LocaNext.exe')"
            }
          } else {
            Write-Host "locaNext\dist-electron NOT FOUND!"
          }

          Write-Host "`nChecking installer directory:"
          Get-ChildItem "installer" | Format-Table Name

          # WORKAROUND: Skip Inno Setup (has path issues on Windows runner)
          # Instead, create a ZIP of the unpacked Electron app
          $version = "${{ steps.check.outputs.version }}"
          $srcDir = "locaNext\dist-electron\win-unpacked"
          $outDir = "installer_output"

          # ZIP name depends on build type
          if ($buildType -eq "FULL") {
            $zipName = "LocaNext_v${version}_Full_Portable.zip"
          } else {
            $zipName = "LocaNext_v${version}_Light_Portable.zip"
          }

          if (!(Test-Path $outDir)) {
            New-Item -ItemType Directory -Path $outDir -Force
          }

          Write-Host "Creating portable ZIP: $zipName"
          Write-Host "Source: $srcDir"
          Write-Host "Output: $outDir\$zipName"
          Write-Host "Build Type: $buildType"

          # Copy additional files into win-unpacked before zipping
          Copy-Item "server" -Destination "$srcDir\server" -Recurse -Force
          Copy-Item "version.py" -Destination "$srcDir\version.py" -Force

          # Create tools directory and copy scripts
          $toolsDir = "$srcDir\tools"
          if (!(Test-Path $toolsDir)) { New-Item -ItemType Directory -Path $toolsDir -Force }
          Get-ChildItem "tools\*.bat" -ErrorAction SilentlyContinue | ForEach-Object { Copy-Item $_.FullName -Destination $toolsDir -Force }
          Get-ChildItem "tools\*.py" -ErrorAction SilentlyContinue | ForEach-Object { Copy-Item $_.FullName -Destination $toolsDir -Force }

          # FULL BUILD: Include Qwen embedding model (~2.3GB)
          if ($buildType -eq "FULL") {
            Write-Host "=== FULL BUILD: Bundling Qwen Model ===" -ForegroundColor Cyan
            if (Test-Path "models\qwen-embedding") {
              $modelsDir = "$srcDir\models"
              if (!(Test-Path $modelsDir)) { New-Item -ItemType Directory -Path $modelsDir -Force }
              Copy-Item "models\qwen-embedding" -Destination "$modelsDir\qwen-embedding" -Recurse -Force
              $modelSize = [math]::Round((Get-ChildItem "$modelsDir\qwen-embedding" -Recurse | Measure-Object -Property Length -Sum).Sum / 1GB, 2)
              Write-Host "[OK] Qwen model bundled: $modelSize GB" -ForegroundColor Green
            } else {
              Write-Error "[ERROR] models/qwen-embedding not found for FULL build!"
              exit 1
            }
          }

          # Create ZIP
          Write-Host "Creating ZIP archive..."
          Compress-Archive -Path "$srcDir\*" -DestinationPath "$outDir\$zipName" -Force

          if (Test-Path "$outDir\$zipName") {
            $size = (Get-Item "$outDir\$zipName").Length / 1MB
            $sizeStr = if ($size -gt 1024) { "$([math]::Round($size/1024, 2)) GB" } else { "$([math]::Round($size, 1)) MB" }
            Write-Host "[OK] Portable ZIP created: $zipName ($sizeStr)" -ForegroundColor Green
          } else {
            Write-Error "[ERROR] Failed to create ZIP"
            exit 1
          }
        shell: powershell

      - name: Verify Portable ZIP
        run: |
          $version = "${{ steps.check.outputs.version }}"
          $archive = Get-ChildItem "installer_output\*.zip" | Select-Object -First 1
          if (!$archive) { Write-Error "[ERROR] No ZIP found"; exit 1 }
          Write-Host "[OK] Portable ZIP created: $($archive.Name)"
          $size = $archive.length / 1MB
          Write-Host "  Size: $([math]::Round($size, 1)) MB"
        shell: powershell

      # ============================================================
      # STEP 5: Generate latest.yml for Auto-Update
      # ============================================================
      - name: Generate latest.yml for Auto-Update
        run: |
          Write-Host "=== Generating latest.yml for electron-updater ==="
          $version = "${{ steps.check.outputs.version }}"

          $archive = Get-ChildItem "installer_output\*.zip" | Select-Object -First 1
          if (!$archive) { Write-Error "[ERROR] No ZIP found"; exit 1 }

          $fileName = $archive.Name
          $fileSize = $archive.Length
          $hash = (Get-FileHash -Path $archive.FullName -Algorithm SHA512).Hash.ToLower()

          # Extract VERSION (unified format: YY.MMDD.HHMM - valid semver + datetime)
          $versionContent = Get-Content "version.py" -Raw
          if ($versionContent -match 'VERSION\s*=\s*"(\d{2}\.\d{4}\.\d{4})"') {
            $semanticVersion = $Matches[1]
            Write-Host "[OK] Extracted unified VERSION: $semanticVersion (YY.MMDD.HHMM format)"
          } else {
            $semanticVersion = "25.0101.0000"  # Fallback with unified format
            Write-Host "[WARN] Could not extract VERSION, using fallback: $semanticVersion"
          }

          $releaseDate = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ss.fffZ")

          $latestYml = "version: $semanticVersion`nfiles:`n  - url: $fileName`n    sha512: $hash`n    size: $fileSize`npath: $fileName`nsha512: $hash`nreleaseDate: '$releaseDate'"

          $latestYml | Out-File -FilePath "installer_output\latest.yml" -Encoding UTF8 -NoNewline
          Write-Host "[OK] latest.yml generated"
          Get-Content "installer_output\latest.yml"
        shell: powershell

      # NOTE: Artifact upload removed - actions/upload-artifact@v4 not supported on Gitea
      # The portable ZIP is saved in installer_output/ on the runner
      # To get the artifact: Check runner workspace at C:\WINDOWS\system32\config\systemprofile\.cache\act\...\hostexecutor\installer_output\

      # ============================================================
      # POST-BUILD TESTS
      # ============================================================
      - name: Test Portable ZIP
        run: |
          Write-Host "=== POST-BUILD TEST: Extracting portable ZIP ==="
          $archive = Get-ChildItem "installer_output\*.zip" | Select-Object -First 1
          $extractDir = "$env:TEMP\LocaNext_Test"
          if (Test-Path $extractDir) { Remove-Item $extractDir -Recurse -Force }
          Expand-Archive -Path $archive.FullName -DestinationPath $extractDir
          Write-Host "[OK] Extracted to: $extractDir"
          Get-ChildItem $extractDir | Select-Object -First 10 | Format-Table Name
        shell: powershell

      - name: Verify Installation Files
        run: |
          $installDir = "$env:TEMP\LocaNext_Test"
          if (!(Test-Path "$installDir\LocaNext.exe")) { Write-Error "[ERROR] LocaNext.exe not found"; exit 1 }
          if (!(Test-Path "$installDir\server\main.py")) { Write-Error "[ERROR] server/main.py not found"; exit 1 }
          if (!(Test-Path "$installDir\version.py")) { Write-Error "[ERROR] version.py not found"; exit 1 }
          # NOTE: LIGHT builds don't include embedded Python - backend tested on first app launch
          if (Test-Path "$installDir\tools\python\python.exe") {
            Write-Host "[OK] Embedded Python found (FULL build)"
          } else {
            Write-Host "[INFO] No embedded Python (LIGHT build - uses system Python on first launch)"
          }
          Write-Host "[PASS] All critical files present!"
        shell: powershell

      # NOTE: Backend health check skipped for LIGHT builds (no embedded Python)
      # LIGHT builds test backend on first app launch via first-run-setup.js

      - name: Cleanup Test Installation
        if: always()
        run: |
          $installDir = "$env:TEMP\LocaNext_Test"
          if (Test-Path $installDir) {
            Remove-Item -Recurse -Force $installDir -ErrorAction SilentlyContinue
            Write-Host "[OK] Test installation cleaned up"
          }
        shell: powershell

      - name: Build Complete + Cache Summary
        run: |
          Write-Host ""
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  BUILD COMPLETE + CACHE SUMMARY" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host ""
          Write-Host "[SUCCESS] LocaNext LIGHT Build Complete!" -ForegroundColor Green
          Write-Host "Output: installer_output\LocaNext_v${{ steps.check.outputs.version }}_Light_Portable.zip"
          Write-Host ""

          # Show cache status
          $cacheRoot = "C:\BuildCache"
          if (Test-Path $cacheRoot) {
            Write-Host "=== CACHE STATUS ===" -ForegroundColor Yellow
            $totalSize = [math]::Round((Get-ChildItem $cacheRoot -Recurse -File | Measure-Object -Property Length -Sum).Sum / 1MB, 1)
            Write-Host "Cache location: $cacheRoot"
            Write-Host "Total cache size: $totalSize MB" -ForegroundColor Green
            Write-Host ""

            if (Test-Path "$cacheRoot\vcredist") {
              $size = [math]::Round((Get-ChildItem "$cacheRoot\vcredist" -Recurse -File | Measure-Object -Property Length -Sum).Sum / 1MB, 1)
              Write-Host "  [CACHED] VC++ Redistributable: $size MB" -ForegroundColor Green
            }
            if (Test-Path "$cacheRoot\python-embedded") {
              $size = [math]::Round((Get-ChildItem "$cacheRoot\python-embedded" -Recurse -File | Measure-Object -Property Length -Sum).Sum / 1MB, 1)
              Write-Host "  [CACHED] Python + packages: $size MB" -ForegroundColor Green
            }
            if (Test-Path "$cacheRoot\nsis-includes") {
              $count = (Get-ChildItem "$cacheRoot\nsis-includes\*.nsh" -ErrorAction SilentlyContinue).Count
              Write-Host "  [CACHED] NSIS includes: $count files" -ForegroundColor Green
            }

            Write-Host ""
            Write-Host "Next build will use cache (much faster!)" -ForegroundColor Cyan
          } else {
            Write-Host "[INFO] No cache directory found" -ForegroundColor Yellow
          }

          Write-Host ""
          Write-Host "============================================" -ForegroundColor Cyan
        shell: powershell

      # ============================================================
      # CREATE GITEA RELEASE + UPLOAD ARTIFACTS
      # ============================================================
      - name: Create Gitea Release
        env:
          GITEA_TOKEN: ${{ secrets.GITEA_TOKEN }}
        run: |
          Write-Host ""
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  CREATING GITEA RELEASE" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan

          $VERSION = "${{ steps.check.outputs.version }}"
          $SEMANTIC = "${{ steps.check.outputs.semantic_version }}"
          $TAG = "v$VERSION"
          $GITEA_URL = if ($env:GITEA_URL) { $env:GITEA_URL } else { "http://localhost:3000" }
          $GITEA_REPO = "neilvibe/LocaNext"

          Write-Host "Version: $VERSION"
          Write-Host "Tag: $TAG"
          Write-Host "Gitea: $GITEA_URL/$GITEA_REPO"

          # Check if token exists
          if (-not $env:GITEA_TOKEN) {
            Write-Host "[SKIP] No GITEA_TOKEN - skipping release creation" -ForegroundColor Yellow
            Write-Host "To enable: Add GITEA_TOKEN secret in Gitea repo settings"
            exit 0
          }

          # Check if release already exists
          try {
            $existingRelease = curl.exe -s "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/tags/$TAG" `
              -H "Authorization: token $env:GITEA_TOKEN" | ConvertFrom-Json
            if ($existingRelease.id) {
              Write-Host "[SKIP] Release $TAG already exists (ID: $($existingRelease.id))" -ForegroundColor Yellow
              exit 0
            }
          } catch {
            Write-Host "No existing release found, creating new..."
          }

          # Get build type
          $BUILD_TYPE = "${{ steps.check.outputs.build_type }}"

          # Create release body based on build type (simplified for YAML compatibility)
          if ($BUILD_TYPE -eq "FULL") {
            $BODY = "## LocaNext v$VERSION (FULL Build)\n\nIncludes Qwen embedding model. Ready to use!\n\n*Auto-released by Gitea Actions*"
          } else {
            $BODY = "## LocaNext v$VERSION (LIGHT Build)\n\nModel downloads on first launch (~2.3GB).\n\n*Auto-released by Gitea Actions*"
          }

          # Create release via API
          $releaseName = if ($BUILD_TYPE -eq "FULL") { "LocaNext v$VERSION (FULL)" } else { "LocaNext v$VERSION (LIGHT)" }
          $releaseData = @{
            tag_name = $TAG
            name = $releaseName
            body = $BODY
            draft = $false
            prerelease = $false
          } | ConvertTo-Json -Compress

          Write-Host "Creating release..."
          Write-Host "DEBUG: releaseData = $releaseData"

          # Use Invoke-RestMethod directly instead of curl.exe to avoid encoding issues
          $response = Invoke-RestMethod -Uri "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases" `
            -Method POST `
            -Headers @{ "Authorization" = "token $env:GITEA_TOKEN"; "Content-Type" = "application/json" } `
            -Body $releaseData `
            -ErrorAction SilentlyContinue

          if (-not $response.id) {
            Write-Host "[ERROR] Failed to create release" -ForegroundColor Red
            Write-Host ($response | ConvertTo-Json)
            exit 1
          }

          $RELEASE_ID = $response.id
          Write-Host "[OK] Created release ID: $RELEASE_ID" -ForegroundColor Green

          # Upload artifacts
          Write-Host ""
          Write-Host "Uploading artifacts..."

          # Upload ZIP
          $zipFile = Get-ChildItem "installer_output\*.zip" | Select-Object -First 1
          if ($zipFile) {
            Write-Host "  Uploading: $($zipFile.Name)"
            curl.exe -s -X POST "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$RELEASE_ID/assets?name=$($zipFile.Name)" `
              -H "Authorization: token $env:GITEA_TOKEN" `
              -H "Content-Type: application/octet-stream" `
              --data-binary "@$($zipFile.FullName)" | Out-Null
            Write-Host "  [OK] ZIP uploaded" -ForegroundColor Green
          }

          # Upload latest.yml
          $ymlFile = "installer_output\latest.yml"
          if (Test-Path $ymlFile) {
            Write-Host "  Uploading: latest.yml"
            curl.exe -s -X POST "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$RELEASE_ID/assets?name=latest.yml" `
              -H "Authorization: token $env:GITEA_TOKEN" `
              -H "Content-Type: application/octet-stream" `
              --data-binary "@$ymlFile" | Out-Null
            Write-Host "  [OK] latest.yml uploaded" -ForegroundColor Green
          }

          Write-Host ""
          Write-Host "[SUCCESS] Release created: $GITEA_URL/$GITEA_REPO/releases/tag/$TAG" -ForegroundColor Green
        shell: powershell

      # ============================================================
      # CLEANUP: Keep only last N releases to save disk space
      # LIGHT builds ~100MB each, 20 releases = ~2GB max
      # ============================================================
      - name: Cleanup Old Releases
        env:
          GITEA_TOKEN: ${{ secrets.GITEA_TOKEN }}
        run: |
          Write-Host ""
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  CLEANING UP OLD RELEASES" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan

          $MAX_RELEASES = 20  # Keep last 20 releases (~2GB max for LIGHT builds)
          $GITEA_URL = if ($env:GITEA_URL) { $env:GITEA_URL } else { "http://localhost:3000" }
          $GITEA_REPO = "neilvibe/LocaNext"

          if (-not $env:GITEA_TOKEN) {
            Write-Host "[SKIP] No GITEA_TOKEN - skipping cleanup" -ForegroundColor Yellow
            exit 0
          }

          # Get all releases sorted by date (newest first)
          $releases = curl.exe -s "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases" `
            -H "Authorization: token $env:GITEA_TOKEN" | ConvertFrom-Json

          $releaseCount = $releases.Count
          Write-Host "Found $releaseCount releases (keeping last $MAX_RELEASES)"

          if ($releaseCount -le $MAX_RELEASES) {
            Write-Host "[OK] No cleanup needed ($releaseCount <= $MAX_RELEASES)" -ForegroundColor Green
            exit 0
          }

          # Sort by created_at descending and get releases to delete
          $sortedReleases = $releases | Sort-Object { [DateTime]$_.created_at } -Descending
          $toDelete = $sortedReleases | Select-Object -Skip $MAX_RELEASES

          Write-Host "Deleting $($toDelete.Count) old releases..."

          foreach ($release in $toDelete) {
            $releaseId = $release.id
            $releaseName = $release.name
            $releaseTag = $release.tag_name

            Write-Host "  Deleting: $releaseName ($releaseTag)..."

            # Delete release
            curl.exe -s -X DELETE "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$releaseId" `
              -H "Authorization: token $env:GITEA_TOKEN" | Out-Null

            # Delete tag (optional, keeps repo clean)
            curl.exe -s -X DELETE "$GITEA_URL/api/v1/repos/$GITEA_REPO/tags/$releaseTag" `
              -H "Authorization: token $env:GITEA_TOKEN" | Out-Null

            Write-Host "    [DELETED] $releaseName" -ForegroundColor Yellow
          }

          Write-Host ""
          Write-Host "[OK] Cleanup complete. Kept last $MAX_RELEASES releases." -ForegroundColor Green
        shell: powershell

      # Clean up workspace to prevent disk bloat
      # Non-ephemeral mode doesn't auto-cleanup, so we do it manually
      - name: Cleanup workspace
        if: always()
        run: |
          Write-Host "[INFO] Cleaning up workspace..."
          $workDir = "$env:GITHUB_WORKSPACE"
          if (Test-Path $workDir) {
            # Keep cache but remove build artifacts
            Get-ChildItem -Path $workDir -Exclude "_cache" | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "[OK] Workspace cleaned"
          }
        shell: powershell

  # ============================================================
  # NOTE: Release creation is now handled directly in build-windows job
  # This ensures the release is created from the same runner where the
  # artifacts exist, avoiding the need for artifact transfer between jobs.
  # ============================================================
