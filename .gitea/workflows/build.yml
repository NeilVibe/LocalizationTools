# ============================================================================
# LocaNext Build Pipeline - Gitea Actions
# ============================================================================
# DEV MODE IS DEAD. Workers make all tests fast. QA is now the only mode.
#
# 3 MODES:
#   - Build / Build QA:  ALL tests (~1000+), light installer (~150MB) - DEFAULT
#   - Build QA FULL:     ALL tests (~1000+), offline installer (~2GB) - GITEA ONLY
#   - TROUBLESHOOT:      Smart checkpoint mode (resume from last failure)
#
# QA FULL bundles: Qwen model (2.3GB) + VC++ Redist + all deps
# GitHub CANNOT run QA FULL (LFS limits). Gitea only.
#
# VERSION: Auto-generated YY.MMDD.HHMM format (Pipeline Executive Power)
# CHECKPOINT: Stored at /home/neil1988/.locanext_checkpoint (persistent)
# ============================================================================

name: Build LocaNext LIGHT Installer

on:
  push:
    branches: [ main ]
    paths:
      - 'GITEA_TRIGGER.txt'
  workflow_dispatch:

env:
  GITEA_URL: http://172.28.150.120:3000
  GITEA_REPO: neilvibe/LocaNext

jobs:
  # ============================================================
  # JOB 1: Check Build Trigger
  # ============================================================
  check-build-trigger:
    name: Check Build Trigger
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      version: ${{ steps.check.outputs.version }}
      mode: ${{ steps.check.outputs.mode }}
      skip_build: ${{ steps.check.outputs.skip_build }}
      skip_linux: ${{ steps.check.outputs.skip_linux }}
      build_type: ${{ steps.check.outputs.build_type }}
      qa_mode: ${{ steps.check.outputs.qa_mode }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check GITEA_TRIGGER.txt
        id: check
        run: |
          # ============================================================
          # DEV MODE IS DEAD. QA is now the only mode.
          # - "Build" or "Build QA" = QA mode (all tests, light installer)
          # - "Build QA FULL" = QA FULL mode (all tests, offline installer)
          # - "TROUBLESHOOT" = checkpoint mode
          # ============================================================
          TRIGGER=$(cat GITEA_TRIGGER.txt | grep -E "^Build( QA)?( FULL)?$|^TROUBLESHOOT" | tail -1)
          echo "Trigger line: $TRIGGER"

          if [ -n "$TRIGGER" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT

            # AUTO-GENERATE VERSION: YY.MDD.HHMM format (semver-compatible, no leading zeros)
            # electron-updater requires valid semver: MAJOR.MINOR.PATCH (no leading zeros)
            VERSION=$(TZ='Asia/Seoul' date '+%y.%-m%d.%H%M')
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "[OK] Auto-generated version: $VERSION (semver-compatible)"

            # ============================================================
            # 3 MODES: Build (QA), Build QA FULL, TROUBLESHOOT
            # ============================================================

            if echo "$TRIGGER" | grep -q "^TROUBLESHOOT"; then
              echo "mode=troubleshoot" >> $GITHUB_OUTPUT
              echo "skip_build=yes" >> $GITHUB_OUTPUT
              echo "skip_linux=no" >> $GITHUB_OUTPUT
              echo "[TROUBLESHOOT] Smart checkpoint mode"
            else
              echo "mode=official" >> $GITHUB_OUTPUT
              echo "skip_build=false" >> $GITHUB_OUTPUT
              echo "skip_linux=no" >> $GITHUB_OUTPUT
              echo "[OFFICIAL] Full clean build"
            fi

            # QA MODE IS ALWAYS ON (DEV mode is dead)
            echo "qa_mode=true" >> $GITHUB_OUTPUT
            echo "[QA MODE] Running ALL tests (~1000+) - this is now the default"

            # Detect QA FULL (offline installer with bundled model)
            if echo "$TRIGGER" | grep -q "QA FULL"; then
              echo "build_type=FULL" >> $GITHUB_OUTPUT
              echo "[QA FULL] Building offline installer (~2GB) with bundled Qwen model"
            else
              echo "build_type=LIGHT" >> $GITHUB_OUTPUT
              echo "[QA] Building light installer (~150MB)"
            fi
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
            echo "No build trigger found"
          fi

  # ============================================================
  # JOB 2: Safety Checks (Tests, Security, Version)
  # ============================================================
  safety-checks:
    name: Safety Checks (Tests, Security, Version)
    runs-on: ubuntu-latest
    needs: check-build-trigger
    if: needs.check-build-trigger.outputs.should_build == 'true' && needs.check-build-trigger.outputs.skip_linux != 'yes'

    # Gitea runner is host mode - use PostgreSQL installed on host
    # Created with: sudo -u postgres psql -c "CREATE USER locanext_ci ..."
    env:
      CI: "true"
      BUILD_MODE: ${{ needs.check-build-trigger.outputs.mode }}
      QA_MODE: ${{ needs.check-build-trigger.outputs.qa_mode }}
      POSTGRES_USER: locanext_ci
      POSTGRES_PASSWORD: locanext_ci_test
      POSTGRES_DB: locanext_ci_test
      POSTGRES_HOST: localhost
      POSTGRES_PORT: "5432"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # ============================================================
      # EXECUTIVE POWER: Inject auto-generated version
      # ============================================================
      - name: Inject Version (Pipeline Executive Power)
        run: |
          VERSION="${{ needs.check-build-trigger.outputs.version }}"
          echo "=== PIPELINE EXECUTIVE POWER ==="
          echo "Injecting version: $VERSION (YY.MMDD.HHMM format)"

          # Update version.py
          sed -i "s/VERSION = \"[^\"]*\"/VERSION = \"$VERSION\"/" version.py

          # Update package.json
          sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" locaNext/package.json

          # NOTE: Inno Setup .iss files deprecated (P28) - using electron-builder NSIS now

          echo "[OK] All files updated to version: $VERSION"
          grep "VERSION" version.py | head -1

      # Host mode: Use system Python 3.11 and Node directly (no setup actions needed)
      - name: Verify Python 3.11
        run: |
          python3.11 --version
          python3.11 -m pip --version

      - name: Verify Node.js
        run: |
          node --version
          npm --version

      - name: Install Python Dependencies
        run: |
          python3.11 -m pip install --upgrade pip
          python3.11 -m pip install -r requirements.txt
          python3.11 -m pip install pytest pip-audit

      # ---- ENABLE PG_TRGM EXTENSION (required for TM similarity search) ----
      - name: Enable PostgreSQL Extensions
        run: |
          echo "=== Enabling pg_trgm extension for TM search ==="
          sudo -u postgres psql -d locanext_ci_test -c "CREATE EXTENSION IF NOT EXISTS pg_trgm;"
          echo "[OK] pg_trgm extension enabled"

      # ---- P36: PACKAGE VERIFICATION (prevents asyncpg-style crashes) ----
      - name: Verify Critical Packages Installed
        run: |
          echo "=== Verifying all critical packages from requirements.txt ==="
          python3.11 scripts/verify_requirements.py --critical-only
          echo "[OK] All critical packages verified"

      - name: Install Node Dependencies
        run: |
          cd locaNext && npm ci

      # ---- P35: SVELTE 5 BUILD HEALTH CHECK ----
      - name: Svelte 5 Build Health Check
        run: |
          echo "=== P35: Checking for Svelte 5 reactivity issues ==="
          chmod +x scripts/check_svelte_build.sh
          ./scripts/check_svelte_build.sh
          echo "[OK] Svelte 5 build health check passed"

      # ---- VERSION CHECK ----
      - name: Version Unification Check
        run: |
          echo "=== Checking version unification across all files ==="
          python3.11 scripts/check_version_unified.py
          echo "[OK] All versions unified"

      # ---- VERSION INCREMENT CHECK (GITEA API) ----
      - name: Check Version Increment
        run: |
          echo "=== Checking version is newer than latest release ==="

          # Get current version from version.py
          CURRENT_VERSION=$(python3.11 -c "from version import VERSION; print(VERSION)")
          echo "Current version: $CURRENT_VERSION"

          # Get latest release version from Gitea API
          LATEST_TAG=$(curl -s "${GITEA_URL}/api/v1/repos/${GITEA_REPO}/releases?limit=1" \
            -H "Authorization: token ${{ secrets.RELEASE_TOKEN }}" | \
            jq -r '.[0].tag_name // "v0"')
          LATEST_VERSION=$(echo "$LATEST_TAG" | sed 's/v//')
          echo "Latest release: $LATEST_VERSION"

          # Compare versions (both are YYMMDDHHMM format, simple numeric comparison)
          if [ "$CURRENT_VERSION" -le "$LATEST_VERSION" ] 2>/dev/null; then
            echo "[WARNING] Current version ($CURRENT_VERSION) is not greater than latest release ($LATEST_VERSION)"
            echo "Consider updating VERSION in version.py"
          else
            echo "[OK] Version $CURRENT_VERSION is newer than $LATEST_VERSION"
          fi

      # ---- START SERVER FOR TESTS ----
      - name: Start Server for Tests
        env:
          CI: "true"
          POSTGRES_USER: locanext_ci
          POSTGRES_PASSWORD: locanext_ci_test
          POSTGRES_DB: locanext_ci_test
          POSTGRES_HOST: localhost
          POSTGRES_PORT: "5432"
        run: |
          echo "=== Starting server for tests (with retry) ==="

          start_server() {
            # Robust cleanup: Kill any process on port 8888 AND by PID file
            echo "Cleaning up old server processes..."

            # Kill by PID file
            if [ -f /tmp/server.pid ]; then
              OLD_PID=$(cat /tmp/server.pid)
              echo "Killing old server by PID file (PID: $OLD_PID)..."
              kill -9 $OLD_PID 2>/dev/null || true
              rm -f /tmp/server.pid
            fi

            # Kill any process on port 8888 (including D state processes)
            for pid in $(lsof -t -i:8888 2>/dev/null || true); do
              echo "Killing process on port 8888 (PID: $pid)..."
              kill -9 $pid 2>/dev/null || true
            done

            # Also kill any python server processes that might be stuck
            pkill -9 -f "python.*server/main.py" 2>/dev/null || true

            # Wait for port to be free
            sleep 3

            # Verify port is free
            if lsof -i:8888 > /dev/null 2>&1; then
              echo "[WARNING] Port 8888 still in use, waiting more..."
              sleep 5
              pkill -9 -f "python.*server/main.py" 2>/dev/null || true
              sleep 2
            fi
            echo "[OK] Port 8888 is free"

            # Clear Python cache to ensure fresh code is used
            find . -type d -name __pycache__ -exec rm -rf {} + 2>/dev/null || true

            # Start server with nohup to survive shell exit (critical for CI steps)
            # DEV_MODE=true skips rate limiting for tests, CI=true signals we're in CI environment
            rm -f /tmp/server.log
            nohup env PYTHONDONTWRITEBYTECODE=1 CI=true DEV_MODE=true python3.11 server/main.py > /tmp/server.log 2>&1 &
            SERVER_PID=$!
            echo $SERVER_PID > /tmp/server.pid
            disown $SERVER_PID

            echo "Server started with PID: $SERVER_PID (nohup + disown)"

            # Wait for server (30 seconds per attempt)
            for i in {1..15}; do
              sleep 2
              if [ $((i % 5)) -eq 0 ]; then
                echo "Waiting for server... ($i/15) - Last log:"
                tail -1 /tmp/server.log 2>/dev/null || echo "(no log yet)"
              fi
              if curl -s http://localhost:8888/health | grep -q "healthy"; then
                echo "[OK] Server is healthy (PID: $SERVER_PID)"
                if ps -p $SERVER_PID > /dev/null 2>&1; then
                  echo "[OK] Server process confirmed running"
                  return 0
                fi
              fi
            done

            echo "[WARNING] Server didn't start in 30s"
            return 1
          }

          # Try starting server (with 1 retry)
          for attempt in 1 2; do
            echo "=== Server startup attempt $attempt/2 ==="
            if start_server; then
              echo "[OK] Server started successfully on attempt $attempt"
              exit 0
            fi
            echo "[WARNING] Attempt $attempt failed, cleaning up..."
            pkill -9 -f "python.*server/main.py" 2>/dev/null || true
            sleep 3
          done

          echo "[ERROR] Server failed to start after 2 attempts!"
          echo "=== Server logs (last 100 lines) ==="
          cat /tmp/server.log | tail -100
          echo "=== Process status ==="
          ps -p $SERVER_PID -o pid,state,cmd 2>/dev/null || echo "Process not found"
          kill -9 $SERVER_PID 2>/dev/null || true
          exit 1

      # ---- VERIFY POSTGRESQL CONNECTION (P35 SMOKE TEST) ----
      - name: Verify PostgreSQL Connection
        run: |
          echo "=== P35: Verifying Central Server Connection ==="

          # Get health endpoint data
          HEALTH_JSON=$(curl -s http://localhost:8888/health)
          echo "Health response: $HEALTH_JSON"

          # Extract database_type
          DB_TYPE=$(echo "$HEALTH_JSON" | jq -r '.database_type // "unknown"')
          echo "Database type: $DB_TYPE"

          # FAIL if not PostgreSQL (means fallback to SQLite happened)
          if [ "$DB_TYPE" != "postgresql" ]; then
            echo ""
            echo "=========================================="
            echo "[FAIL] CENTRAL SERVER CONNECTION FAILED!"
            echo "=========================================="
            echo "Expected: postgresql"
            echo "Got: $DB_TYPE"
            echo ""
            echo "This means PostgreSQL was not reachable and server fell back to SQLite."
            echo "Check PostgreSQL service is running on localhost:5432"
            echo ""
            echo "=== Server logs (database section) ==="
            grep -i "database\|postgresql\|sqlite" /tmp/server.log | tail -20
            exit 1
          fi

          echo ""
          echo "=========================================="
          echo "[OK] SUCCESS! Connected to Central Server (PostgreSQL)"
          echo "=========================================="

          # Double-check by grepping server log for the success message
          if grep -q "DATABASE SETUP COMPLETE (POSTGRESQL)" /tmp/server.log; then
            echo "[OK] Server log confirms PostgreSQL connection"
          else
            echo "[WARNING] Could not find PostgreSQL confirmation in server log"
            grep -i "database setup" /tmp/server.log || echo "(no database setup log found)"
          fi

      # ---- CREATE ADMIN USER FOR TESTS ----
      - name: Create Admin User
        env:
          POSTGRES_USER: locanext_ci
          POSTGRES_PASSWORD: locanext_ci_test
          POSTGRES_DB: locanext_ci_test
          POSTGRES_HOST: localhost
          POSTGRES_PORT: "5432"
        run: |
          echo "=== Creating admin user for tests ==="
          python3.11 scripts/create_admin.py
          echo "[OK] Admin user ready"

      # ---- PYTHON TESTS ----
      # 2 MODES: OFFICIAL (full clean) or TROUBLESHOOT (smart checkpoint)
      - name: Run Python Tests
        env:
          CI: "true"
          DEV_MODE: "true"  # Skip auth tests since server uses DEV_MODE
          POSTGRES_USER: locanext_ci
          POSTGRES_PASSWORD: locanext_ci_test
          POSTGRES_DB: locanext_ci_test
          POSTGRES_HOST: localhost
          POSTGRES_PORT: "5432"
          RUN_API_TESTS: "1"
        run: |
          echo "=== Pre-test server check ==="
          # Verify server is running before starting tests
          if [ -f /tmp/server.pid ]; then
            SERVER_PID=$(cat /tmp/server.pid)
            if ps -p $SERVER_PID > /dev/null 2>&1; then
              echo "[OK] Server process running (PID: $SERVER_PID)"
            else
              echo "[ERROR] Server process (PID: $SERVER_PID) is NOT running!"
              echo "=== Server logs ==="
              cat /tmp/server.log | tail -50
              exit 1
            fi
          else
            echo "[ERROR] No server PID file found!"
            exit 1
          fi

          # Verify server is responding
          HEALTH=$(curl -s http://localhost:8888/health 2>&1)
          if echo "$HEALTH" | grep -q "healthy"; then
            echo "[OK] Server health check passed"
            echo "Health: $HEALTH"
          else
            echo "[ERROR] Server health check failed!"
            echo "Response: $HEALTH"
            echo "=== Server logs ==="
            cat /tmp/server.log | tail -50
            exit 1
          fi

          echo "Mode: $BUILD_MODE"
          # Use BUILD_MODE from job-level env
          MODE="$BUILD_MODE"

          # PERSISTENT checkpoint (survives across CI runs - host mode)
          # Use absolute path to avoid $HOME override issues
          CHECKPOINT_FILE="/home/neil1988/.locanext_checkpoint"

          # ============================================================
          # P33 CI OVERHAUL: Focus on REAL tests that catch REAL bugs
          # ============================================================
          # ~100 essential tests (no bloat, fast CI):
          # - API validation: test_api_true_simulation.py
          # - Server startup: test_server_startup.py
          # - Auth: test_auth_integration.py, test_async_auth.py
          # - Security: All security tests
          # - Tools e2e: KR Similar, XLSTransfer, QuickSearch
          # - Core: DB utils, TM search
          #
          # REMOVED: Mock-heavy tests, redundant tests, slow model tests
          # ============================================================
          # ESSENTIAL TESTS ONLY (~285 tests, ~5 min runtime)
          # Specific files, not entire directories - avoids test bloat
          TEST_DIRS="tests/integration/test_api_true_simulation.py tests/integration/server_tests/test_server_startup.py tests/integration/server_tests/test_auth_integration.py tests/integration/server_tests/test_async_auth.py tests/integration/test_database_connectivity.py tests/security/ tests/e2e/test_full_simulation.py tests/e2e/test_kr_similar_e2e.py tests/e2e/test_quicksearch_e2e.py tests/e2e/test_xlstransfer_e2e.py tests/unit/test_db_utils.py tests/unit/test_kr_similar_core.py"

          # Deselect model-dependent tests (require 2GB Korean BERT model not in CI)
          DESELECTS="--deselect=tests/integration/test_tm_real_model.py --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferEmbeddings::test_05_model_loads --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferEmbeddings::test_06_process_excel_for_dictionary --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferEmbeddings::test_07_save_and_load_dictionary --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferTranslation::test_08_find_best_match --deselect=tests/e2e/test_xlstransfer_e2e.py::TestXLSTransferTranslation::test_09_translate_with_high_threshold"

          # ============================================================
          # TROUBLESHOOT MODE: True resume from checkpoint
          # - Checkpoint = list of remaining tests (one per line)
          # - Checkpoint = "WINDOWS_BUILD" means skip to Windows build
          # - Resume runs only remaining tests, not full suite
          # - On failure: update checkpoint with new remaining tests
          # ============================================================
          if [ "$MODE" = "troubleshoot" ]; then
            echo "=== TROUBLESHOOT MODE ==="

            # Check if checkpoint says to skip to Windows build
            if [ -f "$CHECKPOINT_FILE" ] && grep -q "^WINDOWS_BUILD$" "$CHECKPOINT_FILE"; then
              echo "[CHECKPOINT] WINDOWS_BUILD - Skipping Linux tests"
              echo "Linux tests already passed. Proceeding to Windows build."
              exit 0
            fi

            if [ -f "$CHECKPOINT_FILE" ]; then
              REMAINING=$(wc -l < "$CHECKPOINT_FILE")
              FIRST_TEST=$(head -1 "$CHECKPOINT_FILE")
              echo "[CHECKPOINT FOUND] $REMAINING tests remaining"
              echo "Starting at: $FIRST_TEST"

              # Run only remaining tests from checkpoint
              set +e
              set -o pipefail
              python3.11 -m pytest $(cat "$CHECKPOINT_FILE" | tr '\n' ' ') -v --tb=short --no-cov -x 2>&1 | tee /tmp/pytest_output.txt
              RESULT=$?
              set +o pipefail
              set -e
            else
              echo "[NO CHECKPOINT] Collecting tests..."
              python3.11 -m pytest $TEST_DIRS $DESELECTS --collect-only -q --quiet 2>/dev/null | grep "::" | grep "test_" > /tmp/all_tests.txt
              TOTAL=$(wc -l < /tmp/all_tests.txt)
              echo "Collected $TOTAL tests. Running full suite..."

              set +e
              set -o pipefail
              python3.11 -m pytest $TEST_DIRS $DESELECTS -v --tb=short -x 2>&1 | tee /tmp/pytest_output.txt
              RESULT=$?
              set +o pipefail
              set -e
            fi

            # Handle failure - save remaining tests to checkpoint
            if [ $RESULT -ne 0 ]; then
              FAILED=$(grep -E "^FAILED " /tmp/pytest_output.txt | head -1 | sed 's/FAILED //' | cut -d' ' -f1)

              if [ -n "$FAILED" ]; then
                echo "============================================"
                echo "[FAILED] $FAILED"

                if [ -f "$CHECKPOINT_FILE" ]; then
                  # Update checkpoint: find failed test, keep it + remaining
                  POSITION=$(grep -n "^${FAILED}$" "$CHECKPOINT_FILE" | cut -d: -f1)
                  if [ -n "$POSITION" ]; then
                    tail -n +$POSITION "$CHECKPOINT_FILE" > /tmp/new_checkpoint.txt
                    mv /tmp/new_checkpoint.txt "$CHECKPOINT_FILE"
                  fi
                else
                  # First run: find position in collected list
                  POSITION=$(grep -n "^${FAILED}$" /tmp/all_tests.txt | cut -d: -f1)
                  if [ -n "$POSITION" ]; then
                    tail -n +$POSITION /tmp/all_tests.txt > "$CHECKPOINT_FILE"
                  else
                    echo "$FAILED" > "$CHECKPOINT_FILE"
                  fi
                fi

                REMAINING=$(wc -l < "$CHECKPOINT_FILE")
                echo "[CHECKPOINT SAVED] $REMAINING tests remaining"
                echo "Fix and trigger TROUBLESHOOT again"
                echo "============================================"
              fi
              exit 1
            fi

            echo "[OK] All tests passed! Checkpoint cleared."
            rm -f "$CHECKPOINT_FILE"

          # ============================================================
          # OFFICIAL MODE: Full clean run (clears any old checkpoint)
          # ============================================================
          else
            echo "=== OFFICIAL MODE: Full clean build ==="
            rm -f "$CHECKPOINT_FILE"  # Clear any stale checkpoint

            # ============================================================
            # QA MODE: OPTIMAL STAGED TESTING (~1000+ functions)
            # Features: Parallel execution, Coverage, Performance tests
            # ============================================================
            if [ "$QA_MODE" = "true" ]; then
              echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
              echo "â•‘         QA MODE: OPTIMAL STAGED TESTING                    â•‘"
              echo "â•‘  âš¡ Parallel unit tests | ðŸ“Š Coverage | ðŸš€ Performance     â•‘"
              echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo ""

              # Install pytest-xdist for parallel execution (if not present)
              pip install pytest-xdist -q 2>/dev/null || true

              # Collect test counts for each stage
              echo "=== Collecting test inventory ==="
              UNIT_COUNT=$(python3.11 -m pytest tests/unit/ $DESELECTS --collect-only -q 2>/dev/null | grep "::" | wc -l || echo "0")
              INTEG_COUNT=$(python3.11 -m pytest tests/integration/ $DESELECTS --collect-only -q 2>/dev/null | grep "::" | wc -l || echo "0")
              E2E_COUNT=$(python3.11 -m pytest tests/e2e/ $DESELECTS --collect-only -q 2>/dev/null | grep "::" | wc -l || echo "0")
              API_COUNT=$(python3.11 -m pytest tests/api/ $DESELECTS --collect-only -q 2>/dev/null | grep "::" | wc -l || echo "0")
              SEC_COUNT=$(python3.11 -m pytest tests/security/ $DESELECTS --collect-only -q 2>/dev/null | grep "::" | wc -l || echo "0")
              FIX_COUNT=$(python3.11 -m pytest tests/fixtures/ $DESELECTS --collect-only -q 2>/dev/null | grep "::" | wc -l || echo "0")
              PERF_COUNT=$(python3.11 -m pytest tests/performance/ --collect-only -q 2>/dev/null | grep "::" | wc -l || echo "0")

              echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
              echo "â”‚              TEST INVENTORY                               â”‚"
              echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
              echo "â”‚  Stage 1 - Unit:        $UNIT_COUNT tests  âš¡ PARALLEL    â”‚"
              echo "â”‚  Stage 2 - Integration: $INTEG_COUNT tests               â”‚"
              echo "â”‚  Stage 3 - E2E:         $E2E_COUNT tests                 â”‚"
              echo "â”‚  Stage 4 - API:         $API_COUNT tests                 â”‚"
              echo "â”‚  Stage 5 - Security:    $SEC_COUNT tests                 â”‚"
              echo "â”‚  Stage 6 - Fixtures:    $FIX_COUNT tests                 â”‚"
              echo "â”‚  Stage 7 - Performance: $PERF_COUNT tests  ðŸš€            â”‚"
              echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
              echo ""

              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              # STAGE 1: UNIT TESTS âš¡ PARALLEL (4 workers)
              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
              echo "â•‘  STAGE 1/7: UNIT TESTS âš¡ PARALLEL                         â•‘"
              echo "â•‘  Fast isolated tests with 4 parallel workers               â•‘"
              echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              # Try parallel first, fallback to sequential if xdist not available
              if ! python3.11 -m pytest tests/unit/ $DESELECTS -n 4 -v --tb=short --no-cov 2>&1; then
                echo "Parallel failed, trying sequential..."
                python3.11 -m pytest tests/unit/ $DESELECTS -v --tb=short --no-cov || { echo "âŒ STAGE 1 FAILED"; exit 1; }
              fi
              echo "âœ… STAGE 1 PASSED: Unit tests (parallel)"
              echo ""

              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              # STAGE 2: INTEGRATION TESTS (sequential - DB conflicts)
              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
              echo "â•‘  STAGE 2/7: INTEGRATION TESTS                              â•‘"
              echo "â•‘  Component interactions - DB, server, auth                 â•‘"
              echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              python3.11 -m pytest tests/integration/ $DESELECTS -v --tb=short --no-cov || { echo "âŒ STAGE 2 FAILED"; exit 1; }
              echo "âœ… STAGE 2 PASSED: Integration tests"
              echo ""

              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              # STAGE 3: E2E TESTS (~10 min)
              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
              echo "â•‘  STAGE 3/7: E2E TESTS                                      â•‘"
              echo "â•‘  Full workflow simulations                                 â•‘"
              echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              python3.11 -m pytest tests/e2e/ $DESELECTS -v --tb=short --no-cov || { echo "âŒ STAGE 3 FAILED"; exit 1; }
              echo "âœ… STAGE 3 PASSED: E2E tests"
              echo ""

              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              # STAGE 4: API TESTS (~5 min)
              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
              echo "â•‘  STAGE 4/7: API TESTS                                      â•‘"
              echo "â•‘  Endpoint validation, error handling                       â•‘"
              echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              python3.11 -m pytest tests/api/ $DESELECTS -v --tb=short --no-cov || { echo "âŒ STAGE 4 FAILED"; exit 1; }
              echo "âœ… STAGE 4 PASSED: API tests"
              echo ""

              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              # STAGE 5: SECURITY TESTS (~2 min)
              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
              echo "â•‘  STAGE 5/7: SECURITY TESTS                                 â•‘"
              echo "â•‘  JWT, CORS, audit logging, IP filtering                    â•‘"
              echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              python3.11 -m pytest tests/security/ $DESELECTS -v --tb=short --no-cov || { echo "âŒ STAGE 5 FAILED"; exit 1; }
              echo "âœ… STAGE 5 PASSED: Security tests"
              echo ""

              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              # STAGE 6: FIXTURES & SPECIAL TESTS (~5 min)
              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
              echo "â•‘  STAGE 6/7: FIXTURES & SPECIAL TESTS                       â•‘"
              echo "â•‘  Pretranslation, StringID, edge cases                      â•‘"
              echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              python3.11 -m pytest tests/fixtures/ $DESELECTS -v --tb=short --no-cov || { echo "âŒ STAGE 6 FAILED"; exit 1; }
              echo "âœ… STAGE 6 PASSED: Fixtures tests"
              echo ""

              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              # STAGE 7: PERFORMANCE TESTS ðŸš€
              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
              echo "â•‘  STAGE 7/7: PERFORMANCE TESTS ðŸš€                           â•‘"
              echo "â•‘  API latency, embedding throughput, memory usage           â•‘"
              echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              if [ -d "tests/performance" ]; then
                python3.11 -m pytest tests/performance/ -v --tb=short --no-cov || { echo "âŒ STAGE 7 FAILED"; exit 1; }
                echo "âœ… STAGE 7 PASSED: Performance tests"
              else
                echo "âš ï¸  STAGE 7 SKIPPED: No performance tests directory"
              fi
              echo ""

              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              # CODE COVERAGE - SKIPPED (tests already passed in stages 1-7)
              # Coverage re-running all tests was taking 2+ hours - not worth it
              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
              echo "â•‘  ðŸ“Š COVERAGE SKIPPED (tests passed, no need to re-run)     â•‘"
              echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo ""

              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              # ALL STAGES COMPLETE
              # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              echo ""
              echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
              echo "â•‘                                                            â•‘"
              echo "â•‘   âœ… âœ… âœ…  ALL QA STAGES PASSED  âœ… âœ… âœ…                  â•‘"
              echo "â•‘                                                            â•‘"
              echo "â•‘   Stage 1: Unit Tests     âš¡ âœ…  (parallel)                â•‘"
              echo "â•‘   Stage 2: Integration       âœ…                            â•‘"
              echo "â•‘   Stage 3: E2E               âœ…                            â•‘"
              echo "â•‘   Stage 4: API               âœ…                            â•‘"
              echo "â•‘   Stage 5: Security          âœ…                            â•‘"
              echo "â•‘   Stage 6: Fixtures          âœ…                            â•‘"
              echo "â•‘   Stage 7: Performance    ðŸš€ âœ…                            â•‘"
              echo "â•‘                                                            â•‘"
              echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo "[OK] ALL QA tests passed!"
            else
              # Standard mode: Essential tests only (~285)
              python3.11 -m pytest $TEST_DIRS $DESELECTS -v --tb=short --no-cov -x
              echo "[OK] All tests passed"
            fi
          fi

      - name: Stop Server
        if: always()
        run: |
          if [ -f /tmp/server.pid ]; then
            cat /tmp/server.pid | xargs kill 2>/dev/null || true
            echo "[OK] Server stopped"
          fi

      # ---- SECURITY AUDITS ----
      - name: Python Security Audit
        run: |
          echo "=== Checking Python dependencies for vulnerabilities ==="
          pip-audit --desc || echo "Vulnerabilities found - logged for review"
          echo "[OK] Python security audit complete"
        continue-on-error: true

      - name: NPM Security Audit
        run: |
          cd locaNext
          npm audit || echo "Vulnerabilities found - logged for review"
          echo "[OK] NPM security audit complete"
        continue-on-error: true

      - name: Safety Checks Summary
        run: |
          echo "============================================"
          echo "[PASS] SAFETY CHECKS PASSED"
          echo "============================================"

  # ============================================================
  # JOB 3: Build Windows Installer
  # Skips if TROUBLESHOOT mode (test-only, no build artifact)
  # ============================================================
  build-windows:
    name: Build Windows LIGHT Installer
    needs: [check-build-trigger, safety-checks]
    # Depends on safety-checks for official builds
    # TROUBLESHOOT_WINDOWS skips safety-checks via the if condition on safety-checks job
    if: always() && needs.check-build-trigger.outputs.should_build == 'true' && (needs.safety-checks.result == 'success' || needs.check-build-trigger.outputs.skip_linux == 'yes')
    runs-on: [self-hosted, windows, x64]  # GITEA: Use self-hosted Windows runner

    env:
      SKIP_BUILD: ${{ needs.check-build-trigger.outputs.skip_build }}
      BUILD_VERSION: ${{ needs.check-build-trigger.outputs.version }}
      BUILD_TYPE: ${{ needs.check-build-trigger.outputs.build_type }}
      BUILD_MODE: ${{ needs.check-build-trigger.outputs.mode }}

    steps:
      # Check if we should skip the build (TROUBLESHOOT mode)
      # BUT: If checkpoint is WINDOWS_BUILD, we must run (Linux already passed)
      - name: Check if should build
        run: |
          Write-Host "BUILD_MODE='$env:BUILD_MODE'"

          # TROUBLESHOOT (not TROUBLESHOOT_WINDOWS) = skip Windows build
          # TROUBLESHOOT_WINDOWS or official = run Windows build
          if ($env:BUILD_MODE -eq 'troubleshoot') {
            Write-Host "::notice::TROUBLESHOOT mode - skipping Windows build"
            Write-Host "Use TROUBLESHOOT_WINDOWS trigger for Windows-only builds"
            exit 0
          }

          Write-Host "[OK] Proceeding with Windows build (mode: $env:BUILD_MODE)"
        shell: powershell

      # Configure UTF-8 to handle Korean characters in output
      - name: Configure UTF-8 Console Encoding
        run: |
          if ($env:SKIP_BUILD -match 'yes') { exit 0 }
          chcp 65001
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
          [Console]::InputEncoding = [System.Text.Encoding]::UTF8
          $PSDefaultParameterValues['*:Encoding'] = 'utf8'
          Write-Host "[OK] Console encoding set to UTF-8"
        shell: powershell

      # ============================================================
      # ROBUST VERSION: Use BUILD_VERSION env var from pipeline
      # NO fragile network calls or regex parsing - single source of truth
      # ============================================================
      - name: Get Version and Build Type
        id: check
        run: |
          Write-Host "=== Getting Version from Pipeline (Robust) ===" -ForegroundColor Cyan

          # VERSION: Use BUILD_VERSION from pipeline env (set by check-build-trigger job)
          # This is the SINGLE SOURCE OF TRUTH - no network calls, no regex
          $version = $env:BUILD_VERSION

          if ([string]::IsNullOrEmpty($version)) {
            Write-Host "[ERROR] BUILD_VERSION env var not set!" -ForegroundColor Red
            exit 1
          }

          Write-Host "[OK] Version from pipeline: $version" -ForegroundColor Green
          "version=$version" >> $env:GITHUB_OUTPUT

          # BUILD TYPE: Use BUILD_TYPE from pipeline env (set by check-build-trigger job)
          $buildType = $env:BUILD_TYPE
          if ([string]::IsNullOrEmpty($buildType)) {
            $buildType = "LIGHT"  # Default to LIGHT if not set
          }

          Write-Host "[OK] Build type: $buildType" -ForegroundColor Green
          "build_type=$buildType" >> $env:GITHUB_OUTPUT
        shell: powershell

      # Standard checkout - workspace cleanup handled at end of job
      - name: Checkout code
        uses: actions/checkout@v4

      # ============================================================
      # EXECUTIVE POWER: Inject auto-generated version into ALL files
      # Pipeline controls ALL versions - single source of truth
      # Format: YY.MMDD.HHMM (valid semver + human-readable datetime)
      # ============================================================
      - name: Inject Version (Pipeline Executive Power)
        run: |
          $version = "$env:BUILD_VERSION"
          Write-Host "=== PIPELINE EXECUTIVE POWER ===" -ForegroundColor Cyan
          Write-Host "Injecting auto-generated version: $version" -ForegroundColor Green
          Write-Host "Format: YY.MMDD.HHMM (semver + datetime unified)" -ForegroundColor Yellow

          # 1. version.py (source of truth)
          $content = Get-Content "version.py" -Raw
          $content = $content -replace 'VERSION = "[^"]+"', "VERSION = `"$version`""
          $content | Set-Content "version.py" -NoNewline
          Write-Host "[OK] version.py updated" -ForegroundColor Green

          # 2. package.json (Electron)
          $pkgPath = "locaNext/package.json"
          if (Test-Path $pkgPath) {
            $pkg = Get-Content $pkgPath -Raw
            $pkg = $pkg -replace '"version": "[^"]+"', "`"version`": `"$version`""
            $pkg | Set-Content $pkgPath -NoNewline
            Write-Host "[OK] package.json updated" -ForegroundColor Green
          }

          # NOTE: Inno Setup .iss files deprecated (P28) - using electron-builder NSIS now

          Write-Host ""
          Write-Host "=== VERSION INJECTION COMPLETE ===" -ForegroundColor Cyan
          Write-Host "All files now use: $version" -ForegroundColor Green
        shell: powershell

      # NOTE: We don't use actions/setup-python@v5 because it fails when runner
      # runs as SYSTEM service (can't write to systemprofile cache).
      # Instead, we use the pre-installed Python on the Windows build machine.
      - name: Verify Python Installation
        run: |
          Write-Host "=== Verifying Python Installation ===" -ForegroundColor Cyan

          # Check common Python locations
          $pythonPaths = @(
            "C:\Python313\python.exe",
            "C:\Python311\python.exe",
            "C:\Python310\python.exe",
            "C:\Python39\python.exe"
          )

          $pythonExe = $null
          foreach ($path in $pythonPaths) {
            if (Test-Path $path) {
              $pythonExe = $path
              Write-Host "[OK] Found Python at: $path" -ForegroundColor Green
              break
            }
          }

          if (-not $pythonExe) {
            # Try PATH
            $pythonExe = (Get-Command python -ErrorAction SilentlyContinue).Source
            if ($pythonExe) {
              Write-Host "[OK] Found Python in PATH: $pythonExe" -ForegroundColor Green
            } else {
              Write-Error "[ERROR] Python not found! Install Python 3.9+ to C:\PythonXX"
              exit 1
            }
          }

          # Get Python directory and add to PATH
          $pythonDir = Split-Path $pythonExe -Parent
          $scriptsDir = Join-Path $pythonDir "Scripts"

          # Add to PATH for this session
          $env:PATH = "$pythonDir;$scriptsDir;$env:PATH"
          Write-Host "Added to PATH: $pythonDir, $scriptsDir"

          # Verify
          & $pythonExe --version

          # Create aliases for python and pip
          Set-Alias -Name python -Value $pythonExe -Scope Global
          Write-Host "[OK] Python ready for build" -ForegroundColor Green
        shell: powershell

      # NOTE: We don't use actions/setup-node@v4 because 7zr.exe extraction fails
      # when runner runs as SYSTEM service. Instead, use pre-installed Node.js.
      - name: Verify Node.js Installation
        run: |
          Write-Host "=== Verifying Node.js Installation ===" -ForegroundColor Cyan

          # Check common Node.js locations
          $nodePaths = @(
            "C:\Program Files\nodejs\node.exe",
            "C:\nodejs\node.exe"
          )

          $nodeExe = $null
          foreach ($path in $nodePaths) {
            if (Test-Path $path) {
              $nodeExe = $path
              Write-Host "[OK] Found Node.js at: $path" -ForegroundColor Green
              break
            }
          }

          if (-not $nodeExe) {
            # Try PATH
            $nodeExe = (Get-Command node -ErrorAction SilentlyContinue).Source
            if ($nodeExe) {
              Write-Host "[OK] Found Node.js in PATH: $nodeExe" -ForegroundColor Green
            } else {
              Write-Error "[ERROR] Node.js not found! Install Node.js 18+ to C:\Program Files\nodejs"
              exit 1
            }
          }

          # Get Node directory and add to PATH
          $nodeDir = Split-Path $nodeExe -Parent
          $env:PATH = "$nodeDir;$env:PATH"
          Write-Host "Added to PATH: $nodeDir"

          # Verify versions
          & node --version
          & npm --version

          Write-Host "[OK] Node.js ready for build" -ForegroundColor Green
        shell: powershell

      # ============================================================
      # WINDOWS PATH TESTS - Critical path validation before build
      # Tests: AppData, Downloads, Models, Indexes, Unicode paths
      # ============================================================
      - name: Run Windows PATH Tests
        run: |
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host "  WINDOWS PATH TESTS - Critical Check   " -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Cyan

          # Find Python
          $pythonExe = $null
          foreach ($path in @("C:\Python313\python.exe", "C:\Python311\python.exe", "C:\Python310\python.exe")) {
            if (Test-Path $path) { $pythonExe = $path; break }
          }
          if (-not $pythonExe) { $pythonExe = (Get-Command python -ErrorAction SilentlyContinue).Source }

          if (-not $pythonExe) {
            Write-Host "[SKIP] Python not found - skipping PATH tests" -ForegroundColor Yellow
            exit 0
          }

          Write-Host "[INFO] Using Python: $pythonExe" -ForegroundColor Cyan

          # Install pytest (ignore stderr from pip)
          $ErrorActionPreference = 'SilentlyContinue'
          & $pythonExe -m pip install pytest 2>&1 | Out-Null
          $ErrorActionPreference = 'Stop'

          # Run Windows tests from windows_tests\ (outside tests\ to avoid conftest.py loading)
          Write-Host ""
          Write-Host "Running Windows PATH tests..." -ForegroundColor Yellow

          # First verify the test directory exists
          $testDir = Join-Path $PWD "windows_tests"
          if (-not (Test-Path $testDir)) {
            Write-Host "[ERROR] Test directory not found: $testDir" -ForegroundColor Red
            exit 1
          }
          Write-Host "[INFO] Test directory: $testDir" -ForegroundColor Cyan

          # Run pytest with explicit path (override addopts to skip coverage from pytest.ini)
          $ErrorActionPreference = 'SilentlyContinue'
          & $pythonExe -m pytest $testDir -v --tb=short -o "addopts="
          $testExitCode = $LASTEXITCODE
          $ErrorActionPreference = 'Stop'

          if ($testExitCode -eq 0) {
            Write-Host ""
            Write-Host "[OK] WINDOWS PATH TESTS PASSED" -ForegroundColor Green
          } else {
            Write-Host ""
            Write-Host "[FAIL] WINDOWS PATH TESTS FAILED (exit code: $testExitCode)" -ForegroundColor Red
            exit 1
          }
        shell: powershell

      # ============================================================
      # SMART BUILD CACHE SYSTEM
      # Cache location: C:\BuildCache\
      # Auto-invalidates when versions/hashes change
      # ============================================================
      - name: Initialize Smart Cache
        id: cache_init
        run: |
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  SMART BUILD CACHE SYSTEM v2.0" -ForegroundColor Cyan
          Write-Host "  Hash-based invalidation enabled" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan

          $cacheRoot = "C:\BuildCache"
          $manifestPath = "$cacheRoot\CACHE_MANIFEST.json"

          # Expected versions (update these when upgrading)
          $expectedPythonVersion = "3.11.9"
          $expectedVCRedistVersion = "17.8"

          # ============================================================
          # SMART HASH COMPUTATION - Invalidate when dependencies change
          # ============================================================

          # Compute requirements.txt hash (for pip packages)
          $reqHash = ""
          if (Test-Path "requirements.txt") {
            $reqHash = (Get-FileHash "requirements.txt" -Algorithm SHA256).Hash.Substring(0, 12)
            Write-Host "[HASH] requirements.txt: $reqHash" -ForegroundColor Cyan
          } else {
            Write-Host "[WARN] requirements.txt not found - using package list hash" -ForegroundColor Yellow
            # Fallback: hash the pip install command packages
            # P36: Updated to include ALL critical packages (faiss-cpu, lxml, asyncpg)
            $pipPackages = "fastapi uvicorn python-multipart python-socketio sqlalchemy aiosqlite psycopg2-binary asyncpg PyJWT python-jose passlib python-dotenv bcrypt pydantic pydantic-settings email-validator pandas openpyxl xlrd httpx requests loguru tqdm pyyaml huggingface_hub faiss-cpu lxml"
            $reqHash = [System.BitConverter]::ToString([System.Security.Cryptography.SHA256]::Create().ComputeHash([System.Text.Encoding]::UTF8.GetBytes($pipPackages))).Replace("-","").Substring(0,12)
          }

          # Compute package-lock.json hash (for npm packages - future use)
          $npmHash = ""
          if (Test-Path "locaNext/package-lock.json") {
            $npmHash = (Get-FileHash "locaNext/package-lock.json" -Algorithm SHA256).Hash.Substring(0, 12)
            Write-Host "[HASH] package-lock.json: $npmHash" -ForegroundColor Cyan
          }

          # Create cache root if needed
          if (-not (Test-Path $cacheRoot)) {
            New-Item -ItemType Directory -Path $cacheRoot -Force | Out-Null
            Write-Host "[INIT] Created cache root: $cacheRoot"
          }

          # Load or create manifest
          if (Test-Path $manifestPath) {
            $manifest = Get-Content $manifestPath | ConvertFrom-Json
            Write-Host "[OK] Loaded cache manifest"
          } else {
            $manifest = @{
              version = "2.0"
              created = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ssZ")
              components = @{}
            }
            Write-Host "[INIT] Created new cache manifest"
          }

          # Output cache status
          Write-Host ""
          Write-Host "Cache Validation:" -ForegroundColor Yellow

          # Check VC++ cache validity (version-based)
          $vcCacheValid = $false
          $vcCachePath = "$cacheRoot\vcredist\vc_redist.x64.exe"
          if ((Test-Path $vcCachePath) -and $manifest.components.vcredist.version -eq $expectedVCRedistVersion) {
            $vcCacheValid = $true
            Write-Host "  [VALID] VC++ Redistributable v$expectedVCRedistVersion" -ForegroundColor Green
          } else {
            if (Test-Path $vcCachePath) {
              Write-Host "  [STALE] VC++ version mismatch (cached: $($manifest.components.vcredist.version), expected: $expectedVCRedistVersion)" -ForegroundColor Yellow
            } else {
              Write-Host "  [MISS] VC++ Redistributable not cached" -ForegroundColor Yellow
            }
          }

          # Check Python cache validity (version + hash-based)
          $pythonCacheValid = $false
          $pythonCachePath = "$cacheRoot\python-embedded\python-$expectedPythonVersion"
          $cachedReqHash = $manifest.components.python_embedded.requirements_hash

          if ((Test-Path "$pythonCachePath\python.exe") -and
              $manifest.components.python_embedded.version -eq $expectedPythonVersion -and
              $cachedReqHash -eq $reqHash) {
            $pythonCacheValid = $true
            Write-Host "  [VALID] Python $expectedPythonVersion + packages (hash: $reqHash)" -ForegroundColor Green
          } else {
            if (Test-Path "$pythonCachePath\python.exe") {
              if ($manifest.components.python_embedded.version -ne $expectedPythonVersion) {
                Write-Host "  [STALE] Python version changed ($($manifest.components.python_embedded.version) -> $expectedPythonVersion)" -ForegroundColor Yellow
              } elseif ($cachedReqHash -ne $reqHash) {
                Write-Host "  [STALE] requirements.txt changed (cached: $cachedReqHash, current: $reqHash)" -ForegroundColor Yellow
              }
            } else {
              Write-Host "  [MISS] Python not cached" -ForegroundColor Yellow
            }
          }

          # Check NSIS cache validity
          $nsisCacheValid = $false
          $nsisCachePath = "$cacheRoot\nsis-includes"
          if (Test-Path "$nsisCachePath\StdUtils.nsh") {
            $nsisCacheValid = $true
            Write-Host "  [VALID] NSIS include files" -ForegroundColor Green
          } else {
            Write-Host "  [MISS] NSIS includes not cached" -ForegroundColor Yellow
          }

          # Set outputs for subsequent steps
          "vc_cached=$vcCacheValid" >> $env:GITHUB_OUTPUT
          "python_cached=$pythonCacheValid" >> $env:GITHUB_OUTPUT
          "nsis_cached=$nsisCacheValid" >> $env:GITHUB_OUTPUT
          "cache_root=$cacheRoot" >> $env:GITHUB_OUTPUT
          "req_hash=$reqHash" >> $env:GITHUB_OUTPUT
          "npm_hash=$npmHash" >> $env:GITHUB_OUTPUT

          Write-Host ""
          Write-Host "Smart Cache Summary:" -ForegroundColor Cyan
          Write-Host "  VC++:   $(if ($vcCacheValid) {'CACHE HIT'} else {'WILL DOWNLOAD'})" -ForegroundColor $(if ($vcCacheValid) {'Green'} else {'Yellow'})
          Write-Host "  Python: $(if ($pythonCacheValid) {'CACHE HIT'} else {'WILL DOWNLOAD'})" -ForegroundColor $(if ($pythonCacheValid) {'Green'} else {'Yellow'})
          Write-Host "  NSIS:   $(if ($nsisCacheValid) {'CACHE HIT'} else {'WILL DOWNLOAD'})" -ForegroundColor $(if ($nsisCacheValid) {'Green'} else {'Yellow'})
          Write-Host ""
        shell: powershell

      # ============================================================
      # STEP 1: VC++ Redistributable (SMART CACHE)
      # ============================================================
      - name: Get VC++ Redistributable (Smart Cache)
        run: |
          $cacheRoot = "C:\BuildCache"
          $cachedPath = "$cacheRoot\vcredist\vc_redist.x64.exe"
          $targetPath = "installer\redist\vc_redist.x64.exe"
          $manifestPath = "$cacheRoot\CACHE_MANIFEST.json"
          $expectedVersion = "17.8"

          New-Item -ItemType Directory -Force -Path "installer\redist" | Out-Null

          # Check if cache is valid
          $useCache = $false
          if (Test-Path $cachedPath) {
            $cachedSize = (Get-Item $cachedPath).Length
            if ($cachedSize -gt 10MB) {
              $useCache = $true
            }
          }

          if ($useCache) {
            Write-Host "[CACHE HIT] Copying VC++ Redistributable from cache..." -ForegroundColor Green
            Copy-Item $cachedPath -Destination $targetPath -Force
            $size = [math]::Round((Get-Item $targetPath).Length / 1MB, 1)
            Write-Host "[OK] VC++ Redistributable: $size MB (from cache)" -ForegroundColor Green
          } else {
            Write-Host "[CACHE MISS] Downloading VC++ Redistributable..." -ForegroundColor Yellow
            Invoke-WebRequest -Uri "https://aka.ms/vs/17/release/vc_redist.x64.exe" -OutFile $targetPath
            $size = [math]::Round((Get-Item $targetPath).Length / 1MB, 1)
            Write-Host "[OK] Downloaded VC++ Redistributable: $size MB"

            # POPULATE CACHE for next build
            Write-Host "Populating cache for future builds..."
            New-Item -ItemType Directory -Force -Path "$cacheRoot\vcredist" | Out-Null
            Copy-Item $targetPath -Destination $cachedPath -Force

            # Update manifest
            if (Test-Path $manifestPath) {
              $manifest = Get-Content $manifestPath | ConvertFrom-Json
            } else {
              $manifest = @{ version = "1.0"; components = @{} }
            }
            $manifest.components | Add-Member -NotePropertyName "vcredist" -NotePropertyValue @{
              version = $expectedVersion
              path = $cachedPath
              size_mb = $size
              cached_at = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ssZ")
            } -Force
            $manifest | ConvertTo-Json -Depth 10 | Out-File $manifestPath -Encoding UTF8
            Write-Host "[CACHED] VC++ Redistributable saved to cache" -ForegroundColor Cyan
          }
        shell: powershell

      # ============================================================
      # STEP 2: Python Embedded + Packages (SMART CACHE v2.0)
      # Invalidates if: Python version changes OR requirements.txt hash changes
      # ============================================================
      - name: Get Python Embedded (Smart Cache)
        run: |
          $cacheRoot = "C:\BuildCache"
          $pythonVersion = "3.11.9"
          $cachedPythonDir = "$cacheRoot\python-embedded\python-$pythonVersion"
          $targetDir = "tools\python"
          $manifestPath = "$cacheRoot\CACHE_MANIFEST.json"

          # ============================================================
          # SMART HASH COMPUTATION - Same logic as Initialize step
          # ============================================================
          $reqHash = ""
          if (Test-Path "requirements.txt") {
            $reqHash = (Get-FileHash "requirements.txt" -Algorithm SHA256).Hash.Substring(0, 12)
          } else {
            # P36: Added asyncpg, faiss-cpu, lxml - CRITICAL packages
            $pipPackages = "fastapi uvicorn python-multipart python-socketio sqlalchemy aiosqlite psycopg2-binary asyncpg PyJWT python-jose passlib python-dotenv bcrypt pydantic pydantic-settings email-validator pandas openpyxl xlrd httpx requests loguru tqdm pyyaml huggingface_hub faiss-cpu lxml"
            $reqHash = [System.BitConverter]::ToString([System.Security.Cryptography.SHA256]::Create().ComputeHash([System.Text.Encoding]::UTF8.GetBytes($pipPackages))).Replace("-","").Substring(0,12)
          }

          # List of required packages for existence validation (fallback check)
          # P36: Added faiss, lxml, asyncpg - CORE packages that must be installed
          $requiredPackages = @("fastapi", "uvicorn", "sqlalchemy", "pandas", "pydantic", "huggingface_hub", "faiss", "lxml", "asyncpg")

          # Load manifest to check cached hash
          $cachedReqHash = ""
          if (Test-Path $manifestPath) {
            $manifest = Get-Content $manifestPath | ConvertFrom-Json
            $cachedReqHash = $manifest.components.python_embedded.requirements_hash
          }

          # ============================================================
          # SMART CACHE VALIDATION
          # 1. Python.exe exists
          # 2. Version matches
          # 3. Requirements hash matches (SMART!)
          # 4. All required packages exist (fallback safety check)
          # ============================================================
          $useCache = $false
          $cacheInvalidReason = ""

          if (Test-Path "$cachedPythonDir\python.exe") {
            # Check hash match
            if ($cachedReqHash -eq $reqHash) {
              # Verify packages exist (safety check)
              $allPackagesExist = $true
              foreach ($pkg in $requiredPackages) {
                $pkgPath = "$cachedPythonDir\Lib\site-packages\$pkg"
                if (-not (Test-Path $pkgPath)) {
                  $cacheInvalidReason = "Missing package: $pkg"
                  $allPackagesExist = $false
                  break
                }
              }
              if ($allPackagesExist) {
                $useCache = $true
              }
            } else {
              $cacheInvalidReason = "requirements.txt changed (cached: $cachedReqHash, current: $reqHash)"
            }
          } else {
            $cacheInvalidReason = "Python not cached"
          }

          if ($useCache) {
            Write-Host "[CACHE HIT] Copying Python $pythonVersion + packages from cache..." -ForegroundColor Green
            Write-Host "  Hash: $reqHash (matched)" -ForegroundColor Gray
            New-Item -ItemType Directory -Force -Path $targetDir | Out-Null
            Copy-Item -Path "$cachedPythonDir\*" -Destination $targetDir -Recurse -Force
            $size = [math]::Round((Get-ChildItem $targetDir -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB, 1)
            Write-Host "[OK] Python + packages: $size MB (from cache)" -ForegroundColor Green
          } else {
            Write-Host "[CACHE MISS] $cacheInvalidReason" -ForegroundColor Yellow
            Write-Host "Downloading Python $pythonVersion..." -ForegroundColor Cyan
            New-Item -ItemType Directory -Force -Path $targetDir | Out-Null

            # Download Python
            $pythonUrl = "https://www.python.org/ftp/python/$pythonVersion/python-$pythonVersion-embed-amd64.zip"
            $zipPath = "tools\python-embedded.zip"
            Invoke-WebRequest -Uri $pythonUrl -OutFile $zipPath
            Expand-Archive -Path $zipPath -DestinationPath $targetDir -Force
            Remove-Item $zipPath

            # Enable pip in embedded Python
            $pthFile = Get-ChildItem "$targetDir\python*._pth" | Select-Object -First 1
            if ($pthFile) {
              $content = Get-Content $pthFile.FullName
              $content = $content -replace '#import site', 'import site'
              Set-Content -Path $pthFile.FullName -Value $content
            }

            # Install pip
            Write-Host "Installing pip..."
            Invoke-WebRequest -Uri "https://bootstrap.pypa.io/get-pip.py" -OutFile "$targetDir\get-pip.py"
            & "$targetDir\python.exe" "$targetDir\get-pip.py" --no-warn-script-location
            Remove-Item "$targetDir\get-pip.py"

            # Install all packages from requirements.txt (SINGLE SOURCE OF TRUTH)
            # This ensures build always matches requirements.txt - no more missing packages!
            Write-Host "Installing backend dependencies from requirements.txt..."
            & "$targetDir\python.exe" -m pip install --no-warn-script-location -r requirements.txt

            # P36: Verify CRITICAL packages are installed (prevents asyncpg-style crashes)
            # NOTE: faiss and lxml are REQUIRED for TM indexing and XML QA - NOT optional!
            Write-Host "Verifying critical packages..."
            $criticalPackages = @("fastapi", "uvicorn", "sqlalchemy", "asyncpg", "psycopg2", "pydantic", "jose", "passlib", "loguru", "faiss", "lxml")
            $failed = @()
            foreach ($pkg in $criticalPackages) {
              $result = & "$targetDir\python.exe" -c "import $pkg" 2>&1
              if ($LASTEXITCODE -ne 0) {
                $failed += $pkg
                Write-Host "  MISSING: $pkg" -ForegroundColor Red
              } else {
                Write-Host "  OK: $pkg" -ForegroundColor Green
              }
            }
            if ($failed.Count -gt 0) {
              Write-Host "FATAL: Missing critical packages: $($failed -join ', ')" -ForegroundColor Red
              exit 1
            }
            Write-Host "[OK] All critical packages verified"

            $size = [math]::Round((Get-ChildItem $targetDir -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB, 1)
            Write-Host "[OK] Python + packages installed: $size MB"

            # POPULATE CACHE for next build
            Write-Host "Populating cache for future builds..."
            Write-Host "  Hash: $reqHash (will be stored)" -ForegroundColor Cyan
            New-Item -ItemType Directory -Force -Path "$cacheRoot\python-embedded" | Out-Null
            if (Test-Path $cachedPythonDir) { Remove-Item $cachedPythonDir -Recurse -Force }
            Copy-Item -Path $targetDir -Destination $cachedPythonDir -Recurse -Force

            # Update manifest with HASH for smart invalidation
            if (Test-Path $manifestPath) {
              $manifest = Get-Content $manifestPath | ConvertFrom-Json
            } else {
              $manifest = @{ version = "2.0"; components = @{} }
            }
            $manifest.components | Add-Member -NotePropertyName "python_embedded" -NotePropertyValue @{
              version = $pythonVersion
              path = $cachedPythonDir
              size_mb = $size
              packages = ($requiredPackages -join ",")
              requirements_hash = $reqHash
              cached_at = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ssZ")
            } -Force
            $manifest | ConvertTo-Json -Depth 10 | Out-File $manifestPath -Encoding UTF8
            Write-Host "[CACHED] Python + packages saved with hash: $reqHash" -ForegroundColor Cyan
          }
        shell: powershell

      - name: Verify Python Embedded + ALL Dependencies
        run: |
          Write-Host "Verifying embedded Python setup..."
          & "tools\python\python.exe" --version

          Write-Host "=== Checking ALL critical packages ==="
          & "tools\python\python.exe" -c "import fastapi; print(f'[OK] fastapi v{fastapi.__version__}')"
          & "tools\python\python.exe" -c "import uvicorn; print('[OK] uvicorn ready')"
          & "tools\python\python.exe" -c "import socketio; print('[OK] socketio ready')"
          & "tools\python\python.exe" -c "import sqlalchemy; print(f'[OK] sqlalchemy v{sqlalchemy.__version__}')"
          & "tools\python\python.exe" -c "import aiosqlite; print('[OK] aiosqlite ready')"
          & "tools\python\python.exe" -c "import jwt; print(f'[OK] jwt v{jwt.__version__}')"
          & "tools\python\python.exe" -c "from jose import jwt as jose_jwt; print('[OK] jose.jwt ready')"
          & "tools\python\python.exe" -c "import passlib; print('[OK] passlib ready')"
          & "tools\python\python.exe" -c "import bcrypt; print('[OK] bcrypt ready')"
          & "tools\python\python.exe" -c "import pydantic; print(f'[OK] pydantic v{pydantic.__version__}')"
          & "tools\python\python.exe" -c "import pandas; print(f'[OK] pandas v{pandas.__version__}')"
          & "tools\python\python.exe" -c "import openpyxl; print('[OK] openpyxl ready')"
          & "tools\python\python.exe" -c "import huggingface_hub; print(f'[OK] huggingface_hub v{huggingface_hub.__version__}')"

          # Check required files
          if (!(Test-Path "version.py")) { Write-Error "[ERROR] version.py not found"; exit 1 }
          if (!(Test-Path "server\main.py")) { Write-Error "[ERROR] server/main.py not found"; exit 1 }
          Write-Host "[PASS] All dependencies verified!"
        shell: powershell

      - name: Test Server Launch with Embedded Python
        run: |
          Write-Host "=== Testing server can START with embedded Python ==="
          $env:PYTHONPATH = Get-Location
          & "tools\python\python.exe" -c "import sys; sys.path.insert(0,'.'); from version import VERSION; print(f'version OK: v{VERSION}'); import server.main; print('server.main OK')"
          if ($LASTEXITCODE -ne 0) { Write-Error "Server import test FAILED!"; exit 1 }
          Write-Host "Server launch test passed!"
        shell: powershell

      # ============================================================
      # STEP 2.5: Download Qwen Model (FULL BUILD ONLY)
      # Downloads ~2.3GB model and bundles it in the installer
      # ============================================================
      - name: Download Qwen Embedding Model (FULL only)
        if: needs.check-build-trigger.outputs.build_type == 'FULL'
        run: |
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  DOWNLOADING QWEN EMBEDDING MODEL (FULL BUILD)" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan

          $modelsDir = "models\qwen-embedding"
          if (Test-Path $modelsDir) {
            Write-Host "[SKIP] Model already exists at: $modelsDir"
          } else {
            Write-Host "Downloading Qwen/Qwen3-Embedding-0.6B (~2.3GB)..."
            Write-Host "This may take 5-10 minutes..."

            # Use embedded Python to download via sentence-transformers
            & "tools\python\python.exe" -m pip install --quiet sentence-transformers

            & "tools\python\python.exe" -c "from sentence_transformers import SentenceTransformer; print('Downloading Qwen model...'); model = SentenceTransformer('Qwen/Qwen3-Embedding-0.6B'); model.save('./models/qwen-embedding'); print('Model saved!'); emb = model.encode(['test']); print(f'Dim: {emb.shape[1]}'); print('SUCCESS!')"

            if ($LASTEXITCODE -ne 0) {
              Write-Error "[ERROR] Model download failed!"
              exit 1
            }
          }

          # Verify model
          if (Test-Path "$modelsDir\model.safetensors") {
            $size = [math]::Round((Get-Item "$modelsDir\model.safetensors").Length / 1GB, 2)
            Write-Host "[OK] Qwen model downloaded: $size GB" -ForegroundColor Green
          } else {
            Write-Error "[ERROR] model.safetensors not found!"
            exit 1
          }
        shell: powershell

      # ============================================================
      # STEP 2.6: Add Models to extraResources (FULL BUILD ONLY)
      # Modifies package.json to include bundled model in installer
      # ============================================================
      - name: Add Models to extraResources (FULL only)
        if: needs.check-build-trigger.outputs.build_type == 'FULL'
        run: |
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  ADDING MODELS TO INSTALLER (FULL BUILD)" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan

          $pkgPath = "locaNext/package.json"
          $pkg = Get-Content $pkgPath -Raw | ConvertFrom-Json

          # Add models to extraResources
          $modelsResource = @{
            from = "../models"
            to = "models"
            filter = @("**/*")
          }

          # Check if models already in extraResources
          $hasModels = $pkg.build.extraResources | Where-Object { $_.to -eq "models" }
          if (!$hasModels) {
            $pkg.build.extraResources += $modelsResource
            # Write without BOM (Set-Content adds BOM in PowerShell 5.x which breaks electron-builder)
            $json = $pkg | ConvertTo-Json -Depth 10
            [System.IO.File]::WriteAllText($pkgPath, $json)
            Write-Host "[OK] Added models to extraResources" -ForegroundColor Green
          } else {
            Write-Host "[SKIP] Models already in extraResources" -ForegroundColor Yellow
          }

          # Verify model size
          $modelSize = [math]::Round((Get-ChildItem "models" -Recurse | Measure-Object -Property Length -Sum).Sum / 1GB, 2)
          Write-Host "[INFO] Model bundle size: $modelSize GB" -ForegroundColor Cyan
        shell: powershell

      # ============================================================
      # STEP 3: Build Electron app
      # ============================================================
      - name: Install Node Dependencies
        run: |
          cd locaNext
          npm ci
        shell: powershell

      # Clear electron-builder cache to avoid symlink/NSIS corruption
      - name: Clear Electron Builder Cache
        run: |
          Write-Host "Clearing ALL electron-builder caches to avoid corruption issues..."

          # Clear LOCALAPPDATA cache
          $localCache = "$env:LOCALAPPDATA\electron-builder\Cache"
          if (Test-Path $localCache) {
            Remove-Item -Path $localCache -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "[OK] Cleared LOCALAPPDATA electron-builder cache"
          }

          # Clear TEMP cache (NSIS, nsis-resources)
          $tempCache = "$env:TEMP\electron-builder-cache"
          if (Test-Path $tempCache) {
            Remove-Item -Path $tempCache -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "[OK] Cleared TEMP electron-builder cache"
          }

          # Clear Windows TEMP cache (another location)
          $winTempCache = "C:\WINDOWS\TEMP\electron-builder-cache"
          if (Test-Path $winTempCache) {
            Remove-Item -Path $winTempCache -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "[OK] Cleared C:\WINDOWS\TEMP electron-builder cache"
          }

          # Clear systemprofile AppData caches (service account)
          $sysLocalAppData = "C:\Windows\System32\config\systemprofile\AppData\Local\electron-builder"
          if (Test-Path $sysLocalAppData) {
            Remove-Item -Path $sysLocalAppData -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "[OK] Cleared systemprofile Local electron-builder cache"
          }

          Write-Host "[OK] All electron-builder caches cleared"
        shell: powershell

      # Set cache directory for Windows SYSTEM account
      - name: Configure Electron Builder Environment
        run: |
          # Create dedicated cache directory
          $cacheDir = "C:\electron-builder-cache"
          New-Item -ItemType Directory -Force -Path $cacheDir | Out-Null

          # Set environment variables for this job
          echo "ELECTRON_BUILDER_CACHE=$cacheDir" >> $env:GITHUB_ENV

          Write-Host "[OK] ELECTRON_BUILDER_CACHE set to: $cacheDir"
        shell: powershell

      # ============================================================
      # NSIS Include Files (FROM REPO - Always Reliable)
      # Files bundled in installer/nsis-includes/ - no downloads needed
      # ============================================================
      - name: Copy NSIS Include Files from Repo
        run: |
          Write-Host "=== NSIS Include Files (from repo) ===" -ForegroundColor Cyan

          $sourceDir = "installer\nsis-includes"
          $targetDir = "locaNext\node_modules\app-builder-lib\templates\nsis\include"

          # Create target directory
          New-Item -ItemType Directory -Force -Path $targetDir | Out-Null

          # Copy from repo (always available, no downloads)
          Copy-Item -Path "$sourceDir\*.nsh" -Destination $targetDir -Force

          # Verify
          $files = Get-ChildItem "$targetDir\*.nsh"
          Write-Host "[OK] Copied $($files.Count) NSIS include files from repo" -ForegroundColor Green
          $files | ForEach-Object { Write-Host "  - $($_.Name) ($($_.Length) bytes)" }

          # Verify StdUtils.nsh (required by electron-builder)
          if (Test-Path "$targetDir\StdUtils.nsh") {
            Write-Host "[OK] StdUtils.nsh verified" -ForegroundColor Green
          } else {
            Write-Host "[ERROR] StdUtils.nsh missing!" -ForegroundColor Red
            exit 1
          }
        shell: powershell

      - name: Build Electron App
        run: |
          cd locaNext

          # Build frontend
          npm run build

          # Verify NSIS files are in place (copied from repo in previous step)
          $stdUtils = "node_modules\app-builder-lib\templates\nsis\include\StdUtils.nsh"
          if (Test-Path $stdUtils) {
            Write-Host "[OK] NSIS includes ready" -ForegroundColor Green
          } else {
            Write-Host "[ERROR] NSIS includes missing - check previous step" -ForegroundColor Red
            exit 1
          }

          # Build electron app with NSIS installer
          npm run build:electron
        shell: powershell
        env:
          # Disable code signing completely for unsigned builds
          # CSC_IDENTITY_AUTO_DISCOVERY prevents auto-discovery of certificates
          # DO NOT set CSC_LINK="" - empty string is treated as current directory!
          CSC_IDENTITY_AUTO_DISCOVERY: "false"
          # Debug output
          DEBUG: electron-builder

      - name: Verify Electron Build
        run: |
          if (!(Test-Path "locaNext\dist-electron\win-unpacked\LocaNext.exe")) {
            Write-Error "[ERROR] Electron build failed - LocaNext.exe not found"
            exit 1
          }
          Write-Host "[OK] Electron build successful"
        shell: powershell

      # ============================================================
      # STEP 4: Collect NSIS Installer
      # electron-builder with target: "nsis" produces installer in dist-electron/
      # ============================================================
      - name: Collect NSIS Installer
        run: |
          $buildType = "${{ needs.check-build-trigger.outputs.build_type }}"
          $version = "${{ needs.check-build-trigger.outputs.version }}"
          $outDir = "installer_output"

          Write-Host "=== Collecting NSIS Installer ==="
          Write-Host "Build Type: $buildType"
          Write-Host "Version: $version"

          # Create output directory
          if (!(Test-Path $outDir)) {
            New-Item -ItemType Directory -Path $outDir -Force
          }

          # Find the NSIS installer produced by electron-builder
          Write-Host "`nLooking for NSIS installer in locaNext/dist-electron:"
          Get-ChildItem "locaNext\dist-electron" | Format-Table Name, Length

          $installer = Get-ChildItem "locaNext\dist-electron\*.exe" -ErrorAction SilentlyContinue |
                       Where-Object { $_.Name -like "*Setup*" } |
                       Select-Object -First 1

          if (!$installer) {
            Write-Error "[ERROR] NSIS installer not found in dist-electron!"
            Write-Host "Available files:"
            Get-ChildItem "locaNext\dist-electron" -Recurse | Select-Object FullName
            exit 1
          }

          Write-Host "[OK] Found installer: $($installer.Name)"

          # Rename to include version and build type
          if ($buildType -eq "FULL") {
            $newName = "LocaNext_v${version}_Full_Setup.exe"
          } else {
            $newName = "LocaNext_v${version}_Light_Setup.exe"
          }

          Copy-Item $installer.FullName -Destination "$outDir\$newName"

          $size = (Get-Item "$outDir\$newName").Length / 1MB
          $sizeStr = if ($size -gt 1024) { "$([math]::Round($size/1024, 2)) GB" } else { "$([math]::Round($size, 1)) MB" }
          Write-Host "[OK] Installer ready: $newName ($sizeStr)" -ForegroundColor Green

          # Copy blockmap for differential updates (SMART UPDATE)
          $blockmap = Get-ChildItem "locaNext\dist-electron\*.blockmap" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($blockmap) {
            $blockmapNewName = $newName -replace '\.exe$', '.exe.blockmap'
            Copy-Item $blockmap.FullName -Destination "$outDir\$blockmapNewName"
            Write-Host "[OK] Blockmap ready: $blockmapNewName (enables smart/differential updates)" -ForegroundColor Green
          } else {
            Write-Host "[WARN] No blockmap found - differential updates won't work" -ForegroundColor Yellow
          }
        shell: powershell

      - name: Verify NSIS Installer
        run: |
          $installer = Get-ChildItem "installer_output\*Setup*.exe" | Select-Object -First 1
          if (!$installer) { Write-Error "[ERROR] No installer found"; exit 1 }
          Write-Host "[OK] NSIS installer verified: $($installer.Name)"
          $size = $installer.Length / 1MB
          Write-Host "  Size: $([math]::Round($size, 1)) MB"
        shell: powershell

      # ============================================================
      # STEP 5: Generate latest.yml for Auto-Update
      # ============================================================
      - name: Generate latest.yml for Auto-Update
        env:
          VERSION: ${{ needs.check-build-trigger.outputs.version }}
        run: |
          Write-Host "=== Generating latest.yml for electron-updater ==="

          $installer = Get-ChildItem "installer_output\*Setup*.exe" | Select-Object -First 1
          if (!$installer) { Write-Error "[ERROR] No installer found"; exit 1 }

          $fileName = $installer.Name
          $fileSize = $installer.Length
          $hash = (Get-FileHash -Path $installer.FullName -Algorithm SHA512).Hash.ToLower()
          $releaseDate = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ss.fffZ")

          # Use version directly from CI (no regex parsing needed)
          $version = $env:VERSION
          Write-Host "[OK] Version from CI: $version"

          $latestYml = "version: $version`nfiles:`n  - url: $fileName`n    sha512: $hash`n    size: $fileSize`npath: $fileName`nsha512: $hash`nreleaseDate: '$releaseDate'"

          # Write WITHOUT BOM
          [System.IO.File]::WriteAllText("installer_output\latest.yml", $latestYml)
          Write-Host "[OK] latest.yml generated"
          Get-Content "installer_output\latest.yml"
        shell: powershell

      # ============================================================
      # STEP 5b: Generate Patch Update Manifest (LAUNCHER-style)
      # ============================================================
      - name: Generate Patch Update Manifest
        env:
          VERSION: ${{ needs.check-build-trigger.outputs.version }}
        run: |
          Write-Host "=== Generating manifest.json for PATCH updates ==="

          $resourcesDir = "locaNext\dist-electron\win-unpacked\resources"
          $version = $env:VERSION

          # Copy app.asar to installer_output for upload
          $asarPath = "$resourcesDir\app.asar"
          if (Test-Path $asarPath) {
            Copy-Item $asarPath "installer_output\app.asar"
            Write-Host "[OK] Copied app.asar to installer_output"

            $asarSize = (Get-Item "installer_output\app.asar").Length
            $asarHash = (Get-FileHash "installer_output\app.asar" -Algorithm SHA256).Hash.ToLower()

            Write-Host "  Size: $([math]::Round($asarSize/1MB, 2)) MB"
            Write-Host "  SHA256: $($asarHash.Substring(0,16))..."
          } else {
            Write-Host "[WARN] app.asar not found - patch updates will use fallback" -ForegroundColor Yellow
            $asarSize = 0
            $asarHash = ""
          }

          # Generate manifest.json
          $manifest = @{
            version = $version
            buildDate = (Get-Date).ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
            components = @{
              "app.asar" = @{
                version = $version
                sha256 = $asarHash
                size = $asarSize
                url = "app.asar"
                required = $true
                restartRequired = $true
                description = "Frontend application bundle"
              }
            }
            releaseNotes = "LocaNext v$version"
          }

          $manifestJson = $manifest | ConvertTo-Json -Depth 5
          [System.IO.File]::WriteAllText("installer_output\manifest.json", $manifestJson)
          Write-Host "[OK] manifest.json generated"
          Write-Host ""
          Write-Host "=== PATCH UPDATE SAVINGS ==="
          Write-Host "  app.asar: $([math]::Round($asarSize/1MB, 2)) MB"
          Write-Host "  Full installer: ~624 MB"
          Write-Host "  Savings: ~$([math]::Round((1 - $asarSize/624000000) * 100))%"
          Write-Host "==========================="
        shell: powershell

      # ============================================================
      # POST-BUILD TESTS
      # Test using win-unpacked directory (same files as installer bundles)
      # ============================================================
      - name: Verify Build Contents
        run: |
          Write-Host "=== POST-BUILD TEST: Verifying bundled files ==="

          # electron-builder extraResources go to: win-unpacked/resources/
          $resourcesDir = "locaNext\dist-electron\win-unpacked\resources"

          Write-Host "Checking resources directory:"
          Get-ChildItem $resourcesDir -ErrorAction SilentlyContinue | Format-Table Name

          # Check for critical files in extraResources
          $checks = @(
            @{Path="$resourcesDir\server\main.py"; Desc="Backend server"},
            @{Path="$resourcesDir\version.py"; Desc="Version file"},
            @{Path="$resourcesDir\tools\python\python.exe"; Desc="Embedded Python"},
            @{Path="$resourcesDir\tools\install_deps.py"; Desc="Deps installer script"}
          )

          $allOk = $true
          foreach ($check in $checks) {
            if (Test-Path $check.Path) {
              Write-Host "[OK] $($check.Desc): $($check.Path)"
            } else {
              Write-Host "[WARN] $($check.Desc) not found: $($check.Path)" -ForegroundColor Yellow
              # Only fail for critical files
              if ($check.Path -like "*main.py*") {
                $allOk = $false
              }
            }
          }

          # Verify LocaNext.exe exists
          if (Test-Path "locaNext\dist-electron\win-unpacked\LocaNext.exe") {
            Write-Host "[OK] LocaNext.exe present"
          } else {
            Write-Error "[ERROR] LocaNext.exe not found"
            $allOk = $false
          }

          if ($allOk) {
            Write-Host "[PASS] All critical files present!" -ForegroundColor Green
          } else {
            Write-Error "[FAIL] Some critical files missing!"
            exit 1
          }
        shell: powershell

      - name: Test Embedded Python
        run: |
          $pythonExe = "locaNext\dist-electron\win-unpacked\resources\tools\python\python.exe"

          if (Test-Path $pythonExe) {
            Write-Host "=== Testing Embedded Python ==="
            & $pythonExe --version
            & $pythonExe -c "import fastapi; print('[OK] fastapi')"
            & $pythonExe -c "import uvicorn; print('[OK] uvicorn')"
            Write-Host "[PASS] Embedded Python works!" -ForegroundColor Green
          } else {
            Write-Host "[INFO] No embedded Python - LIGHT build (first-run setup will install)" -ForegroundColor Yellow
          }
        shell: powershell

      # NOTE: Backend health check skipped for LIGHT builds (no embedded Python)
      # LIGHT builds test backend on first app launch via first-run-setup.js

      - name: Cleanup Test Installation
        if: always()
        run: |
          $installDir = "$env:TEMP\LocaNext_Test"
          if (Test-Path $installDir) {
            Remove-Item -Recurse -Force $installDir -ErrorAction SilentlyContinue
            Write-Host "[OK] Test installation cleaned up"
          }
        shell: powershell

      - name: Build Complete + Cache Summary
        run: |
          # Clear WINDOWS_BUILD checkpoint on success
          $checkpointFile = "\\wsl.localhost\Ubuntu-22.04\home\neil1988\.locanext_checkpoint"
          if (Test-Path $checkpointFile) {
            Remove-Item $checkpointFile -Force -ErrorAction SilentlyContinue
            Write-Host "[CHECKPOINT] Cleared (build succeeded)" -ForegroundColor Green
          }

          Write-Host ""
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  BUILD COMPLETE + CACHE SUMMARY" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host ""
          Write-Host "[SUCCESS] LocaNext LIGHT Build Complete!" -ForegroundColor Green
          Write-Host "Output: installer_output\LocaNext_v${{ needs.check-build-trigger.outputs.version }}_Light_Setup.exe"
          Write-Host ""

          # Show cache status
          $cacheRoot = "C:\BuildCache"
          if (Test-Path $cacheRoot) {
            Write-Host "=== CACHE STATUS ===" -ForegroundColor Yellow
            $totalSize = [math]::Round((Get-ChildItem $cacheRoot -Recurse -File | Measure-Object -Property Length -Sum).Sum / 1MB, 1)
            Write-Host "Cache location: $cacheRoot"
            Write-Host "Total cache size: $totalSize MB" -ForegroundColor Green
            Write-Host ""

            if (Test-Path "$cacheRoot\vcredist") {
              $size = [math]::Round((Get-ChildItem "$cacheRoot\vcredist" -Recurse -File | Measure-Object -Property Length -Sum).Sum / 1MB, 1)
              Write-Host "  [CACHED] VC++ Redistributable: $size MB" -ForegroundColor Green
            }
            if (Test-Path "$cacheRoot\python-embedded") {
              $size = [math]::Round((Get-ChildItem "$cacheRoot\python-embedded" -Recurse -File | Measure-Object -Property Length -Sum).Sum / 1MB, 1)
              Write-Host "  [CACHED] Python + packages: $size MB" -ForegroundColor Green
            }
            if (Test-Path "$cacheRoot\nsis-includes") {
              $count = (Get-ChildItem "$cacheRoot\nsis-includes\*.nsh" -ErrorAction SilentlyContinue).Count
              Write-Host "  [CACHED] NSIS includes: $count files" -ForegroundColor Green
            }

            Write-Host ""
            Write-Host "Next build will use cache (much faster!)" -ForegroundColor Cyan
          } else {
            Write-Host "[INFO] No cache directory found" -ForegroundColor Yellow
          }

          Write-Host ""
          Write-Host "============================================" -ForegroundColor Cyan
        shell: powershell

      # ============================================================
      # P30: SMOKE TEST - Verify installer works end-to-end
      # Phases 1-3 (Install, Files) = REQUIRED
      # Phase 4+ (Backend) = OPTIONAL (CI has no PostgreSQL)
      # NOTE: Full backend testing requires manual validation with DB
      # ============================================================

      # Install 7-Zip for NSIS extraction (NSIS /S flag broken in Session 0)
      - name: Install 7-Zip
        shell: powershell
        run: |
          if (!(Test-Path "C:\Program Files\7-Zip\7z.exe")) {
            Write-Host "Installing 7-Zip via Chocolatey..."
            choco install 7zip -y --no-progress
            Write-Host "7-Zip installed successfully"
          } else {
            Write-Host "7-Zip already installed"
          }

      - name: Smoke Test - Installer Verification
        shell: powershell
        run: |
          $ErrorActionPreference = "Stop"
          $LogFile = "smoke_test.log"

          function Log($msg) {
            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            "$timestamp | $msg" | Tee-Object -FilePath $LogFile -Append
          }

          try {
            Log "========================================"
            Log "P30 SMOKE TEST - Installer Verification"
            Log "========================================"

            # === PHASE 1: Find Installer ===
            Log "=== PHASE 1: FIND INSTALLER ==="
            $installer = Get-ChildItem "installer_output\*Setup*.exe" | Select-Object -First 1
            if (!$installer) { throw "No installer found in installer_output!" }
            Log "OK: Found installer: $($installer.Name)"
            Log "OK: Size: $([math]::Round($installer.Length / 1MB, 1)) MB"

            # === PHASE 2: Silent Install ===
            Log "=== PHASE 2: SILENT INSTALL ==="
            $installDir = "C:\LocaNextSmokeTest"

            # CRITICAL: Kill any processes from previous smoke tests that might lock files
            Log "Killing any leftover processes..."
            Get-Process -Name "LocaNext*" -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
            Get-Process -Name "python*" -ErrorAction SilentlyContinue | Where-Object { $_.Path -like "*LocaNextSmokeTest*" } | Stop-Process -Force -ErrorAction SilentlyContinue
            Start-Sleep -Seconds 2  # Wait for processes to fully terminate
            Log "OK: Process cleanup done"

            # Clean up any previous test install
            if (Test-Path $installDir) {
              Log "Removing previous test install..."
              try {
                Remove-Item $installDir -Recurse -Force -ErrorAction Stop
                Log "OK: Previous install removed"
              } catch {
                Log "WARN: Could not remove previous install: $($_.Exception.Message)"
                # Try harder - maybe files are still locked
                Start-Sleep -Seconds 3
                Remove-Item $installDir -Recurse -Force -ErrorAction SilentlyContinue
              }
            }

            # Verify directory is gone
            if (Test-Path $installDir) {
              throw "Cannot clean up previous installation at $installDir - files may be locked"
            }

            Log "Installing to: $installDir"

            # Use 7-Zip extraction instead of NSIS /S flag (broken in Session 0)
            # Electron-builder NSIS has nested structure: installer.exe â†’ $PLUGINSDIR/app-64.7z â†’ app files
            $7zPath = "C:\Program Files\7-Zip\7z.exe"
            if (!(Test-Path $7zPath)) {
              $7zPath = "C:\ProgramData\chocolatey\bin\7z.exe"
            }
            if (!(Test-Path $7zPath)) {
              throw "7-Zip not found - required for installer extraction"
            }
            Log "OK: Using 7-Zip at $7zPath"

            # Step 1: Extract NSIS outer layer to temp dir
            $tempDir = "$installDir\__temp__"
            New-Item -ItemType Directory -Path $tempDir -Force | Out-Null
            $extractArgs = "x `"$($installer.FullName)`" -o`"$tempDir`" -y"
            Log "Step 1: Extracting NSIS wrapper..."
            $proc = Start-Process -FilePath $7zPath -ArgumentList $extractArgs -Wait -PassThru -NoNewWindow
            if ($proc.ExitCode -ne 0) { throw "NSIS extraction failed with exit code $($proc.ExitCode)" }

            # Step 2: Extract app-64.7z (contains actual app files)
            $app7z = Get-ChildItem -Path "$tempDir\`$PLUGINSDIR" -Filter "app-64.7z" -ErrorAction SilentlyContinue
            if (!$app7z) {
              throw "Could not find app-64.7z in extracted NSIS installer"
            }
            Log "Step 2: Extracting app-64.7z..."
            $extractArgs = "x `"$($app7z.FullName)`" -o`"$installDir`" -y"
            $proc = Start-Process -FilePath $7zPath -ArgumentList $extractArgs -Wait -PassThru -NoNewWindow
            if ($proc.ExitCode -ne 0) { throw "App extraction failed with exit code $($proc.ExitCode)" }

            # Cleanup temp dir
            Remove-Item $tempDir -Recurse -Force -ErrorAction SilentlyContinue
            Log "OK: Installation completed"

            # === PHASE 3: File Verification ===
            Log "=== PHASE 3: FILE VERIFICATION ==="
            $requiredFiles = @(
              "$installDir\LocaNext.exe",
              "$installDir\resources\server\main.py",
              "$installDir\resources\tools\python\python.exe",
              "$installDir\resources\tools\download_model.py",
              "$installDir\resources\tools\install_deps.py"
            )
            foreach ($file in $requiredFiles) {
              if (!(Test-Path $file)) { throw "MISSING FILE: $file" }
              Log "OK: $file"
            }

            # === REQUIRED PHASES COMPLETE ===
            Log "========================================"
            Log "INSTALLER VERIFIED - Phases 1-3 PASSED"
            Log "========================================"

            # === PHASE 4: Backend Test (FORCED SQLite Mode) ===
            # CI has no PostgreSQL - force SQLite mode for reliable testing
            Log "=== PHASE 4: BACKEND TEST (SQLITE MODE) ==="
            Log "DATABASE_MODE=sqlite - forced for CI (no PostgreSQL available)"

            $backendUp = $false
            $dbType = "unknown"
            try {
              # Create first_run_complete.flag to skip model download
              $flagFile = "$installDir\first_run_complete.flag"
              '{"completedAt":"smoke-test","version":"smoke"}' | Out-File -FilePath $flagFile -Encoding UTF8
              Log "OK: Created first_run_complete.flag"

              # Start the app with DATABASE_MODE=sqlite in its environment
              # NOTE: Start-Process doesn't inherit $env vars, so we use .NET Process class
              Log "Starting app with DATABASE_MODE=sqlite..."
              $processInfo = New-Object System.Diagnostics.ProcessStartInfo
              $processInfo.FileName = "$installDir\LocaNext.exe"
              $processInfo.UseShellExecute = $false
              $processInfo.EnvironmentVariables["DATABASE_MODE"] = "sqlite"
              $process = New-Object System.Diagnostics.Process
              $process.StartInfo = $processInfo
              $process.Start() | Out-Null
              $appProc = $process
              Log "OK: App started with PID: $($appProc.Id) (DATABASE_MODE=sqlite)"

              # Backend needs time to initialize (imports, SQLite setup, etc.)
              # 120 seconds timeout - first startup can be slow
              Log "Waiting for backend (SQLite mode, 120s timeout)..."
              $timeout = 120
              $startTime = Get-Date

              while (((Get-Date) - $startTime).TotalSeconds -lt $timeout) {
                Start-Sleep -Seconds 3
                $elapsed = [math]::Round(((Get-Date) - $startTime).TotalSeconds)

                # Debug: Check if processes are running
                $locanextProcs = Get-Process -Name "LocaNext*" -ErrorAction SilentlyContinue
                $pythonProcs = Get-Process -Name "python*" -ErrorAction SilentlyContinue | Where-Object { $_.Path -like "*LocaNextSmokeTest*" }

                try {
                  # IMPORTANT: Use 127.0.0.1 NOT localhost!
                  # Backend binds to 127.0.0.1 (IPv4), but localhost can resolve to ::1 (IPv6) on Windows
                  $health = Invoke-WebRequest -Uri "http://127.0.0.1:8888/health" -TimeoutSec 5 -UseBasicParsing -ErrorAction Stop
                  if ($health.StatusCode -eq 200) {
                    $healthData = $health.Content | ConvertFrom-Json
                    $dbType = $healthData.database_type
                    Log "OK: Backend healthy! Database: $dbType"
                    $backendUp = $true
                    break
                  }
                } catch {
                  # Log every attempt for debugging
                  Log "... waiting ($elapsed s) [LocaNext: $($locanextProcs.Count), Python: $($pythonProcs.Count)] Error: $($_.Exception.Message)"
                }
              }

              if ($backendUp) {
                Log "PASS: Backend running with $dbType"
                if ($dbType -ne "sqlite") {
                  Log "WARN: Expected sqlite but got $dbType"
                }
              } else {
                # Debug info before failing
                Log "DEBUG: Checking final process state..."
                $finalLocanext = Get-Process -Name "LocaNext*" -ErrorAction SilentlyContinue
                $finalPython = Get-Process -Name "python*" -ErrorAction SilentlyContinue
                Log "DEBUG: LocaNext processes: $($finalLocanext.Count)"
                Log "DEBUG: Python processes: $($finalPython.Count)"
                if ($finalPython) {
                  $finalPython | ForEach-Object { Log "DEBUG: Python PID=$($_.Id) Path=$($_.Path)" }
                }

                # Check if there's a locanext.log file (in logs/ subdirectory)
                $logFile = "$installDir\logs\locanext.log"
                if (Test-Path $logFile) {
                  Log "DEBUG: Found locanext.log, last 30 lines:"
                  Get-Content $logFile -Tail 30 | ForEach-Object { Log "  $_" }
                } else {
                  Log "DEBUG: No locanext.log found at $logFile"
                  # Check if logs directory exists
                  if (Test-Path "$installDir\logs") {
                    Log "DEBUG: logs directory exists, contents:"
                    Get-ChildItem "$installDir\logs" | ForEach-Object { Log "  $($_.Name) - $($_.Length) bytes" }
                  }
                }

                # Check if port 8888 is listening
                Log "DEBUG: Checking port 8888..."
                $listening = Get-NetTCPConnection -LocalPort 8888 -ErrorAction SilentlyContinue
                if ($listening) {
                  Log "DEBUG: Port 8888 is listening! PID: $($listening.OwningProcess)"
                } else {
                  Log "DEBUG: Port 8888 is NOT listening"
                }

                # Backend MUST respond - this is a FAILURE
                throw "Backend failed to respond within ${timeout}s - SQLite mode not working!"
              }
            } catch {
              Log "ERROR: Backend test failed - $($_.Exception.Message)"
              throw  # Re-throw to fail the smoke test
            } finally {
              # Cleanup app
              if ($appProc -and !$appProc.HasExited) {
                Stop-Process -Id $appProc.Id -Force -ErrorAction SilentlyContinue
              }
              # Kill any orphan processes
              Get-Process -Name "LocaNext*" -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
              Get-Process -Name "python*" -ErrorAction SilentlyContinue | Where-Object { $_.Path -like "*LocaNextSmokeTest*" } | Stop-Process -Force -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 2
              Log "OK: Cleanup complete"
            }

            # === PHASE 5: Cleanup Installation ===
            Log "=== PHASE 5: CLEANUP ==="
            if (Test-Path $installDir) {
              Remove-Item $installDir -Recurse -Force -ErrorAction SilentlyContinue
              Log "OK: Test installation removed"
            }

            # === SUCCESS (only reached if backend test passed) ===
            Log "========================================"
            Log "SMOKE TEST PASSED"
            Log "- Installer: VERIFIED"
            Log "- Installation: VERIFIED"
            Log "- Files: VERIFIED"
            Log "- Backend: PASS ($dbType mode)"
            Log "========================================"

            Write-Host ""
            Write-Host "============================================" -ForegroundColor Green
            Write-Host "  SMOKE TEST PASSED" -ForegroundColor Green
            Write-Host "============================================" -ForegroundColor Green
            Write-Host ""
            Get-Content $LogFile | Select-Object -Last 25 | Write-Host

          } catch {
            Log "========================================"
            Log "SMOKE TEST FAILED"
            Log "Error: $($_.Exception.Message)"
            Log "========================================"

            # Kill any processes
            Get-Process -Name "LocaNext*" -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue

            Write-Host ""
            Write-Host "============================================" -ForegroundColor Red
            Write-Host "  SMOKE TEST FAILED" -ForegroundColor Red
            Write-Host "============================================" -ForegroundColor Red
            Write-Host ""
            Get-Content $LogFile | Write-Host
            exit 1
          }

      # ============================================================
      # CDP TESTS - Real app functionality testing via Chrome DevTools Protocol
      # Tests BOTH offline (SQLite) AND online (PostgreSQL) modes
      # Uses Gitea secrets for credentials (not hardcoded)
      # ============================================================
      - name: Run CDP Integration Tests
        env:
          # Gitea secrets for central server connection
          # To configure: Gitea repo â†’ Settings â†’ Secrets
          CI_DB_HOST: ${{ secrets.CI_DB_HOST }}
          CI_TEST_USER: ${{ secrets.CI_TEST_USER }}
          CI_TEST_PASS: ${{ secrets.CI_TEST_PASS }}
        run: |
          Write-Host ""
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  CDP INTEGRATION TESTS" -ForegroundColor Cyan
          Write-Host "  Testing: SQLite (offline) + PostgreSQL (online)" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan

          $installDir = "C:\LocaNextSmokeTest"
          $cdpPort = 9222
          $appDataPath = "$env:APPDATA\LocaNext"

          function Log($msg) {
            $timestamp = Get-Date -Format "HH:mm:ss"
            Write-Host "[$timestamp] $msg"
          }

          function Cleanup {
            Get-Process -Name "LocaNext*" -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
            Get-Process -Name "python*" -ErrorAction SilentlyContinue | Where-Object { $_.Path -like "*LocaNextSmokeTest*" } | Stop-Process -Force -ErrorAction SilentlyContinue
            Start-Sleep -Seconds 2
          }

          function WaitForCDP {
            for ($i = 0; $i -lt 30; $i++) {
              try {
                $response = Invoke-RestMethod -Uri "http://127.0.0.1:$cdpPort/json" -TimeoutSec 2 -ErrorAction SilentlyContinue
                if ($response) { return $true }
              } catch { }
              Start-Sleep -Seconds 2
            }
            return $false
          }

          function LaunchApp($mode, $dbHost) {
            Cleanup

            # Create server-config
            if (!(Test-Path $appDataPath)) { New-Item -ItemType Directory -Path $appDataPath -Force | Out-Null }

            if ($mode -eq "sqlite") {
              $serverConfig = @{ database_mode = "sqlite"; sqlite_path = "$appDataPath\locanext.db" } | ConvertTo-Json
            } else {
              $serverConfig = @{
                database_mode = "postgresql"
                database_host = $dbHost
                database_port = 5432
                database_name = "locanext"
              } | ConvertTo-Json
            }
            $serverConfig | Out-File -FilePath "$appDataPath\server-config.json" -Encoding UTF8

            # Launch
            $appPath = "$installDir\LocaNext.exe"
            $env:DATABASE_MODE = $mode
            Start-Process -FilePath $appPath -ArgumentList "--remote-debugging-port=$cdpPort" -WindowStyle Hidden
            Start-Sleep -Seconds 3

            return WaitForCDP
          }

          try {
            # === PHASE 1: Setup ===
            Log "=== PHASE 1: SETUP ==="
            Cleanup

            # Install ws module
            $cdpDir = "testing_toolkit\cdp"
            if (!(Test-Path $cdpDir)) { throw "CDP test directory not found" }
            Push-Location $cdpDir
            & npm install ws --silent 2>&1 | Out-Null
            Pop-Location
            Log "OK: ws module installed"

            $appPath = "$installDir\LocaNext.exe"
            if (!(Test-Path $appPath)) { throw "App not found at $appPath" }

            # ============================================
            # TEST 1: OFFLINE MODE (SQLite)
            # ============================================
            Log ""
            Log "========================================"
            Log "TEST 1: OFFLINE MODE (SQLite)"
            Log "========================================"

            if (LaunchApp "sqlite" $null) {
              Log "OK: App launched in SQLite mode, CDP ready"
              Start-Sleep -Seconds 5

              Push-Location $cdpDir
              Log "Running quick_check.js (SQLite mode)..."
              $result = & node quick_check.js 2>&1
              if ($LASTEXITCODE -eq 0) {
                Log "OK: SQLite mode - quick_check.js PASSED"
              } else {
                Log "WARN: SQLite mode - quick_check.js returned $LASTEXITCODE"
              }
              Pop-Location
            } else {
              Log "WARN: SQLite mode - CDP not available"
            }

            Cleanup
            Start-Sleep -Seconds 3

            # ============================================
            # TEST 2: ONLINE MODE (PostgreSQL)
            # Requires: CI_DB_HOST, CI_TEST_USER, CI_TEST_PASS secrets
            # ============================================
            Log ""
            Log "========================================"
            Log "TEST 2: ONLINE MODE (PostgreSQL)"
            Log "========================================"

            $dbHost = $env:CI_DB_HOST
            $testUser = $env:CI_TEST_USER
            $testPass = $env:CI_TEST_PASS

            if (!$dbHost -or !$testUser -or !$testPass) {
              Log "SKIP: Online tests - secrets not configured"
              Log "To enable: Add CI_DB_HOST, CI_TEST_USER, CI_TEST_PASS in Gitea secrets"
            } else {
              Log "Connecting to: $dbHost"
              Log "Test user: $testUser (credentials from Gitea secrets)"

              if (LaunchApp "postgresql" $dbHost) {
                Log "OK: App launched in PostgreSQL mode, CDP ready"
                Start-Sleep -Seconds 8  # More time for DB connection

                Push-Location $cdpDir

                # Set credentials for login.js via environment
                $env:CDP_TEST_USER = $testUser
                $env:CDP_TEST_PASS = $testPass

                Log "Running login.js..."
                $result = & node login.js 2>&1
                if ($LASTEXITCODE -eq 0) {
                  Log "OK: login.js PASSED"

                  Log "Running quick_check.js..."
                  $result = & node quick_check.js 2>&1
                  if ($LASTEXITCODE -eq 0) {
                    Log "OK: quick_check.js PASSED"
                  }

                  Log "Running test_server_status.js..."
                  $result = & node test_server_status.js 2>&1
                  if ($LASTEXITCODE -eq 0) {
                    Log "OK: test_server_status.js PASSED"
                  }
                } else {
                  Log "WARN: login.js failed - $LASTEXITCODE"
                  $result | ForEach-Object { Log "  $_" }
                }

                Pop-Location
              } else {
                Log "WARN: PostgreSQL mode - CDP not available"
              }
            }

            # === CLEANUP ===
            Cleanup
            Log "OK: Final cleanup done"

            # === SUCCESS ===
            Log ""
            Log "========================================"
            Log "CDP INTEGRATION TESTS COMPLETE"
            Log "========================================"

            Write-Host ""
            Write-Host "============================================" -ForegroundColor Green
            Write-Host "  CDP TESTS COMPLETE" -ForegroundColor Green
            Write-Host "============================================" -ForegroundColor Green

          } catch {
            Log "========================================"
            Log "CDP TESTS ERROR: $($_.Exception.Message)"
            Log "========================================"
            Cleanup

            Write-Host ""
            Write-Host "============================================" -ForegroundColor Yellow
            Write-Host "  CDP TESTS SKIPPED (non-blocking)" -ForegroundColor Yellow
            Write-Host "============================================" -ForegroundColor Yellow
          }
        shell: powershell
        continue-on-error: true

      # ============================================================
      # CREATE GITEA RELEASE + UPLOAD ARTIFACTS
      # ============================================================
      - name: Create Gitea Release
        env:
          GITEA_TOKEN: ${{ secrets.GITEA_TOKEN }}
        run: |
          Write-Host ""
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  CREATING GITEA RELEASE" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan

          $VERSION = "${{ needs.check-build-trigger.outputs.version }}"
          $TAG = "v$VERSION"
          $GITEA_URL = if ($env:GITEA_URL) { $env:GITEA_URL } else { "http://localhost:3000" }
          $GITEA_REPO = "neilvibe/LocaNext"

          Write-Host "Version: $VERSION"
          Write-Host "Tag: $TAG"
          Write-Host "Gitea: $GITEA_URL/$GITEA_REPO"

          # Check if token exists
          if (-not $env:GITEA_TOKEN) {
            Write-Host "[SKIP] No GITEA_TOKEN - skipping release creation" -ForegroundColor Yellow
            Write-Host "To enable: Add GITEA_TOKEN secret in Gitea repo settings"
            exit 0
          }

          # Check if release already exists
          try {
            $existingRelease = curl.exe -s "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/tags/$TAG" `
              -H "Authorization: token $env:GITEA_TOKEN" | ConvertFrom-Json
            if ($existingRelease.id) {
              Write-Host "[SKIP] Release $TAG already exists (ID: $($existingRelease.id))" -ForegroundColor Yellow
              exit 0
            }
          } catch {
            Write-Host "No existing release found, creating new..."
          }

          # Get build type
          $BUILD_TYPE = "${{ needs.check-build-trigger.outputs.build_type }}"

          # Create release body based on build type (simplified for YAML compatibility)
          if ($BUILD_TYPE -eq "FULL") {
            $BODY = "## LocaNext v$VERSION (FULL Build)\n\nIncludes Qwen embedding model. Ready to use!\n\n*Auto-released by Gitea Actions*"
          } else {
            $BODY = "## LocaNext v$VERSION (LIGHT Build)\n\nModel downloads on first launch (~2.3GB).\n\n*Auto-released by Gitea Actions*"
          }

          # Create release via API
          $releaseName = if ($BUILD_TYPE -eq "FULL") { "LocaNext v$VERSION (FULL)" } else { "LocaNext v$VERSION (LIGHT)" }
          $releaseData = @{
            tag_name = $TAG
            name = $releaseName
            body = $BODY
            draft = $false
            prerelease = $false
          } | ConvertTo-Json -Compress

          Write-Host "Creating release..."
          Write-Host "DEBUG: releaseData = $releaseData"

          # Use Invoke-RestMethod directly instead of curl.exe to avoid encoding issues
          $response = Invoke-RestMethod -Uri "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases" `
            -Method POST `
            -Headers @{ "Authorization" = "token $env:GITEA_TOKEN"; "Content-Type" = "application/json" } `
            -Body $releaseData `
            -ErrorAction SilentlyContinue

          if (-not $response.id) {
            Write-Host "[ERROR] Failed to create release" -ForegroundColor Red
            Write-Host ($response | ConvertTo-Json)
            exit 1
          }

          $RELEASE_ID = $response.id
          Write-Host "[OK] Created release ID: $RELEASE_ID" -ForegroundColor Green

          # Upload artifacts
          Write-Host ""
          Write-Host "Uploading artifacts..."

          # Upload Installer (.exe)
          $installer = Get-ChildItem "installer_output\*Setup*.exe" | Select-Object -First 1
          if ($installer) {
            Write-Host "  Uploading: $($installer.Name)"
            curl.exe -s -X POST "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$RELEASE_ID/assets?name=$($installer.Name)" `
              -H "Authorization: token $env:GITEA_TOKEN" `
              -H "Content-Type: application/octet-stream" `
              --data-binary "@$($installer.FullName)" | Out-Null
            Write-Host "  [OK] Installer uploaded" -ForegroundColor Green
          }

          # Upload latest.yml
          $ymlFile = "installer_output\latest.yml"
          if (Test-Path $ymlFile) {
            Write-Host "  Uploading: latest.yml"
            curl.exe -s -X POST "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$RELEASE_ID/assets?name=latest.yml" `
              -H "Authorization: token $env:GITEA_TOKEN" `
              -H "Content-Type: application/octet-stream" `
              --data-binary "@$ymlFile" | Out-Null
            Write-Host "  [OK] latest.yml uploaded" -ForegroundColor Green
          }

          # Upload PATCH UPDATE assets (LAUNCHER-style)
          # manifest.json - component checksums for delta updates
          $manifestFile = "installer_output\manifest.json"
          if (Test-Path $manifestFile) {
            Write-Host "  Uploading: manifest.json (PATCH update manifest)"
            curl.exe -s -X POST "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$RELEASE_ID/assets?name=manifest.json" `
              -H "Authorization: token $env:GITEA_TOKEN" `
              -H "Content-Type: application/octet-stream" `
              --data-binary "@$manifestFile" | Out-Null
            Write-Host "  [OK] manifest.json uploaded" -ForegroundColor Green
          }

          # app.asar - frontend bundle for quick PATCH updates (~18MB vs 624MB installer)
          $asarFile = "installer_output\app.asar"
          if (Test-Path $asarFile) {
            $asarSize = [math]::Round((Get-Item $asarFile).Length/1MB, 2)
            Write-Host "  Uploading: app.asar ($asarSize MB - PATCH update component)"
            curl.exe -s -X POST "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$RELEASE_ID/assets?name=app.asar" `
              -H "Authorization: token $env:GITEA_TOKEN" `
              -H "Content-Type: application/octet-stream" `
              --data-binary "@$asarFile" | Out-Null
            Write-Host "  [OK] app.asar uploaded - PATCH UPDATES ENABLED (~97% smaller!)" -ForegroundColor Green
          }

          # Upload blockmap for SMART/DIFFERENTIAL updates
          $blockmap = Get-ChildItem "installer_output\*.blockmap" | Select-Object -First 1
          if ($blockmap) {
            Write-Host "  Uploading: $($blockmap.Name) (enables smart updates)"
            curl.exe -s -X POST "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$RELEASE_ID/assets?name=$($blockmap.Name)" `
              -H "Authorization: token $env:GITEA_TOKEN" `
              -H "Content-Type: application/octet-stream" `
              --data-binary "@$($blockmap.FullName)" | Out-Null
            Write-Host "  [OK] Blockmap uploaded - SMART UPDATES ENABLED" -ForegroundColor Green
          } else {
            Write-Host "  [WARN] No blockmap found - full download required for updates" -ForegroundColor Yellow
          }

          Write-Host ""
          Write-Host "[SUCCESS] Release created: $GITEA_URL/$GITEA_REPO/releases/tag/$TAG" -ForegroundColor Green
        shell: powershell

      # ============================================================
      # CREATE/UPDATE 'latest' RELEASE FOR AUTO-UPDATER
      # electron-updater with generic provider expects files at /releases/download/latest/
      # ============================================================
      - name: Create Latest Release (for Auto-Updater)
        env:
          GITEA_TOKEN: ${{ secrets.GITEA_TOKEN }}
        run: |
          Write-Host ""
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  CREATING 'latest' RELEASE FOR AUTO-UPDATER" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan

          $GITEA_URL = if ($env:GITEA_URL) { $env:GITEA_URL } else { "http://localhost:3000" }
          $GITEA_REPO = "neilvibe/LocaNext"

          if (-not $env:GITEA_TOKEN) {
            Write-Host "[SKIP] No GITEA_TOKEN - skipping latest release" -ForegroundColor Yellow
            exit 0
          }

          # Delete existing 'latest' release if it exists
          Write-Host "Checking for existing 'latest' release..."
          $existingRelease = curl.exe -s "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/tags/latest" `
            -H "Authorization: token $env:GITEA_TOKEN" | ConvertFrom-Json

          if ($existingRelease.id) {
            Write-Host "  Deleting existing 'latest' release (ID: $($existingRelease.id))..."
            curl.exe -s -X DELETE "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$($existingRelease.id)" `
              -H "Authorization: token $env:GITEA_TOKEN" | Out-Null

            # Also delete the tag
            Write-Host "  Deleting 'latest' tag..."
            curl.exe -s -X DELETE "$GITEA_URL/api/v1/repos/$GITEA_REPO/tags/latest" `
              -H "Authorization: token $env:GITEA_TOKEN" | Out-Null
          }

          # Get version from version.py
          $VERSION = (Select-String -Path "version.py" -Pattern 'VERSION = "([^"]+)"').Matches.Groups[1].Value

          # Get current commit SHA for target_commitish
          $COMMIT_SHA = git rev-parse HEAD
          Write-Host "Current commit: $COMMIT_SHA"

          # Create new 'latest' release
          Write-Host "Creating 'latest' release pointing to v$VERSION..."

          # Build JSON and write to temp file WITHOUT BOM (critical for curl)
          $jsonBody = "{`"tag_name`":`"latest`",`"target_commitish`":`"$COMMIT_SHA`",`"name`":`"Latest Release (v$VERSION)`",`"body`":`"Auto-updater release. Current version: v$VERSION.`",`"draft`":false,`"prerelease`":false}"
          $jsonFile = "latest_release.json"
          # Use .NET to write without BOM (Out-File -Encoding UTF8 adds BOM which breaks curl)
          [System.IO.File]::WriteAllText($jsonFile, $jsonBody)

          Write-Host "JSON Body: $jsonBody"

          $response = curl.exe -s -X POST "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases" `
            -H "Authorization: token $env:GITEA_TOKEN" `
            -H "Content-Type: application/json" `
            -d "@$jsonFile"

          Write-Host "API Response: $response"

          $latestRelease = $response | ConvertFrom-Json

          if (-not $latestRelease.id) {
            Write-Host "[ERROR] Failed to create 'latest' release" -ForegroundColor Red
            Write-Host "Response was: $response"
            exit 1
          }

          $LATEST_RELEASE_ID = $latestRelease.id
          Write-Host "[OK] 'latest' release created (ID: $LATEST_RELEASE_ID)" -ForegroundColor Green

          # Upload assets to 'latest' release
          Write-Host "Uploading assets to 'latest' release..."

          # Upload Installer
          $installer = Get-ChildItem "installer_output\*Setup*.exe" | Select-Object -First 1
          if ($installer) {
            Write-Host "  Uploading: $($installer.Name)"
            curl.exe -s -X POST "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$LATEST_RELEASE_ID/assets?name=$($installer.Name)" `
              -H "Authorization: token $env:GITEA_TOKEN" `
              -H "Content-Type: application/octet-stream" `
              --data-binary "@$($installer.FullName)" | Out-Null
          }

          # Upload latest.yml (CRITICAL for auto-updater)
          $ymlFile = "installer_output\latest.yml"
          if (Test-Path $ymlFile) {
            Write-Host "  Uploading: latest.yml"
            curl.exe -s -X POST "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$LATEST_RELEASE_ID/assets?name=latest.yml" `
              -H "Authorization: token $env:GITEA_TOKEN" `
              -H "Content-Type: application/octet-stream" `
              --data-binary "@$ymlFile" | Out-Null
          }

          # Upload PATCH UPDATE assets to 'latest' release
          $manifestFile = "installer_output\manifest.json"
          if (Test-Path $manifestFile) {
            Write-Host "  Uploading: manifest.json (PATCH update)"
            curl.exe -s -X POST "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$LATEST_RELEASE_ID/assets?name=manifest.json" `
              -H "Authorization: token $env:GITEA_TOKEN" `
              -H "Content-Type: application/octet-stream" `
              --data-binary "@$manifestFile" | Out-Null
          }

          $asarFile = "installer_output\app.asar"
          if (Test-Path $asarFile) {
            Write-Host "  Uploading: app.asar (PATCH update - 97% smaller!)"
            curl.exe -s -X POST "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$LATEST_RELEASE_ID/assets?name=app.asar" `
              -H "Authorization: token $env:GITEA_TOKEN" `
              -H "Content-Type: application/octet-stream" `
              --data-binary "@$asarFile" | Out-Null
          }

          # Upload blockmap
          $blockmap = Get-ChildItem "installer_output\*.blockmap" | Select-Object -First 1
          if ($blockmap) {
            Write-Host "  Uploading: $($blockmap.Name)"
            curl.exe -s -X POST "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$LATEST_RELEASE_ID/assets?name=$($blockmap.Name)" `
              -H "Authorization: token $env:GITEA_TOKEN" `
              -H "Content-Type: application/octet-stream" `
              --data-binary "@$($blockmap.FullName)" | Out-Null
          }

          Write-Host ""
          Write-Host "[SUCCESS] 'latest' release ready for auto-updater" -ForegroundColor Green
          Write-Host "URL: $GITEA_URL/$GITEA_REPO/releases/tag/latest" -ForegroundColor Cyan
        shell: powershell

      # ============================================================
      # CLEANUP: Keep only last N releases to save disk space
      # LIGHT builds ~100MB each, 20 releases = ~2GB max
      # ============================================================
      - name: Cleanup Old Releases
        env:
          GITEA_TOKEN: ${{ secrets.GITEA_TOKEN }}
        run: |
          Write-Host ""
          Write-Host "============================================" -ForegroundColor Cyan
          Write-Host "  CLEANING UP OLD RELEASES" -ForegroundColor Cyan
          Write-Host "============================================" -ForegroundColor Cyan

          # DISK TERRORISM PREVENTION
          # FULL builds are ~2GB each, LIGHT builds are ~150MB each
          # Keep fewer FULL releases to prevent disk bloat
          $buildType = "${{ needs.check-build-trigger.outputs.build_type }}"
          if ($buildType -eq "FULL") {
            $MAX_RELEASES = 3   # 3 x 2GB = 6GB max for FULL releases
            Write-Host "[QA FULL] Keeping only 3 releases (2GB each = 6GB max)" -ForegroundColor Yellow
          } else {
            $MAX_RELEASES = 10  # 10 x 150MB = 1.5GB max for LIGHT releases
          }
          $GITEA_URL = if ($env:GITEA_URL) { $env:GITEA_URL } else { "http://localhost:3000" }
          $GITEA_REPO = "neilvibe/LocaNext"

          if (-not $env:GITEA_TOKEN) {
            Write-Host "[SKIP] No GITEA_TOKEN - skipping cleanup" -ForegroundColor Yellow
            exit 0
          }

          # Get all releases sorted by date (newest first)
          $releases = curl.exe -s "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases" `
            -H "Authorization: token $env:GITEA_TOKEN" | ConvertFrom-Json

          $releaseCount = $releases.Count
          Write-Host "Found $releaseCount releases (keeping last $MAX_RELEASES)"

          if ($releaseCount -le $MAX_RELEASES) {
            Write-Host "[OK] No cleanup needed ($releaseCount <= $MAX_RELEASES)" -ForegroundColor Green
            exit 0
          }

          # Sort by created_at descending and get releases to delete
          $sortedReleases = $releases | Sort-Object { [DateTime]$_.created_at } -Descending
          $toDelete = $sortedReleases | Select-Object -Skip $MAX_RELEASES

          Write-Host "Deleting $($toDelete.Count) old releases..."

          foreach ($release in $toDelete) {
            $releaseId = $release.id
            $releaseName = $release.name
            $releaseTag = $release.tag_name

            Write-Host "  Deleting: $releaseName ($releaseTag)..."

            # Delete release
            curl.exe -s -X DELETE "$GITEA_URL/api/v1/repos/$GITEA_REPO/releases/$releaseId" `
              -H "Authorization: token $env:GITEA_TOKEN" | Out-Null

            # Delete tag (optional, keeps repo clean)
            curl.exe -s -X DELETE "$GITEA_URL/api/v1/repos/$GITEA_REPO/tags/$releaseTag" `
              -H "Authorization: token $env:GITEA_TOKEN" | Out-Null

            Write-Host "    [DELETED] $releaseName" -ForegroundColor Yellow
          }

          Write-Host ""
          Write-Host "[OK] Cleanup complete. Kept last $MAX_RELEASES releases." -ForegroundColor Green
        shell: powershell

      # Clean up workspace to prevent disk bloat
      # Non-ephemeral mode doesn't auto-cleanup, so we do it manually
      - name: Cleanup workspace
        if: always()
        run: |
          Write-Host "[INFO] Cleaning up workspace..."
          $workDir = "$env:GITHUB_WORKSPACE"
          if (Test-Path $workDir) {
            # Keep cache but remove build artifacts
            Get-ChildItem -Path $workDir -Exclude "_cache" | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
            Write-Host "[OK] Workspace cleaned"
          }
        shell: powershell

  # ============================================================
  # NOTE: Release creation is now handled directly in build-windows job
  # This ensures the release is created from the same runner where the
  # artifacts exist, avoiding the need for artifact transfer between jobs.
  # ============================================================
